<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>關於 Angular中的 constructor 與 ngOnInit | 永誌不忘 • 筆記簿</title>
<meta name=keywords content="angular,rxjs,life cycle">
<meta name=description content="在本篇筆記中來紀錄一下 Angular中的 constructor 與 ngOnInit 有何不同的使用情境，另也探討 ngOnInit 與 ngOnChanges 有何不同">
<meta name=author content="Theme PaperMod">
<link rel=canonical href=https://calvinegs.github.io/posts/angular-ngoninit/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://calvinegs.github.io/img/favicon.png>
<link rel=icon type=image/png sizes=16x16 href=https://calvinegs.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://calvinegs.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://calvinegs.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://calvinegs.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="關於 Angular中的 constructor 與 ngOnInit">
<meta property="og:description" content="在本篇筆記中來紀錄一下 Angular中的 constructor 與 ngOnInit 有何不同的使用情境，另也探討 ngOnInit 與 ngOnChanges 有何不同">
<meta property="og:type" content="article">
<meta property="og:url" content="https://calvinegs.github.io/posts/angular-ngoninit/"><meta property="og:image" content="https://calvinegs.github.io/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-02T00:00:00+00:00">
<meta property="article:modified_time" content="2022-01-02T00:00:00+00:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://calvinegs.github.io/papermod-cover.png">
<meta name=twitter:title content="關於 Angular中的 constructor 與 ngOnInit">
<meta name=twitter:description content="在本篇筆記中來紀錄一下 Angular中的 constructor 與 ngOnInit 有何不同的使用情境，另也探討 ngOnInit 與 ngOnChanges 有何不同">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://calvinegs.github.io/posts/"},{"@type":"ListItem","position":2,"name":"關於 Angular中的 constructor 與 ngOnInit","item":"https://calvinegs.github.io/posts/angular-ngoninit/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"關於 Angular中的 constructor 與 ngOnInit","name":"關於 Angular中的 constructor 與 ngOnInit","description":"在本篇筆記中來紀錄一下 Angular中的 constructor 與 ngOnInit 有何不同的使用情境，另也探討 ngOnInit 與 ngOnChanges 有何不同","keywords":["angular","rxjs","life cycle"],"articleBody":"Angular中的 constructor 與 ngOnInit 在本篇筆記中來紀錄一下 Angular中的 constructor 與 ngOnInit 有何不同的使用情境，也探討一下 ngOnInit() 的非必要性。\nngOnInit 與 constructor ngOnInit() 與 Class 中的其他 Method 無異，僅因為它剛好被命名為 ngOnInit，常會被與 constructor 搞混用途。其實它並非是必要的，完全取決於你。當 Angular 編譯器進行程式編譯時會將是否 Class 中有實現 ngOnInit() 的方法記錄在特定的 Flag 中，這個 Flag 會在 “變更檢測\"時決定是不是要呼叫 ngOnInit() 這個方法。\n而 constructor 則完全是另外的一件事，不管你有沒有在類別中實現它，在建立類別實例時它都會被呼叫到。\nAngular啟動時的二個主要階段：\n 建構元件樹(component tree) 執行變更檢測(change detection)  constructor 是在第一個階段被呼叫的，這就是為什麼我們不能將任何依賴於 DOM、元素、輸入數據、綁定等的初始化邏輯放在constructor— 因為它們尚不可使用。 而 ngOnInit 則在第二階段，實際上所有的生命週期鉤子都是“變更檢測”階段的一部份。\n當 Angular 開始變更檢測時，組件樹已被構建，樹中所有組件的構造函數都被調用。它已經完成了組件 DOM 的創建，通過構造函數注入了所有必需的依賴項並處理了輸入綁定。每個組件的模板節點都被添加到 DOM 中。 也可以取得初始化組件可能需要的所有資料，如：DI Provider、DOM 和輸入綁定(input bindings)。\n在實際的使用案例上 constructor 最常被使用的是用來“注入依賴項目”(當然不僅限於此)\nngOnInit 是否為必須 在之前使用 angular cli(如：14.0.6) 産生 component 會發現 component class 程式碼中是預設會使用到 ngOnInit 的。但在新版的 angular cli 中(如：15.0.4) 産生的程式架構中已預設不用使用 ngOnInit (與constructor) 了。\nangular cli 14.0.6\nangular cli 15.0.4\n其實：\n 在處理 Observables 時你不需要 ngOnInit 大多數時候，ngOnChanges 是 ngOnInit 的更好選擇  以下就要來說說如何不使用 ngOnInit 的一些寫法。\n常見的例子是 Angular 使用 Fetch 來讀取後端 API 資料顯示在畫面，寫法如下：\ndata: MyData; constructor(private readonly dataService: DataService) { } ngOnInit() { this.dataService.getData().subscribe( data = this.data = data,\t//透過訂閱取得 data 後利用資料綁定的功能將資料顯示在模版中  ); } 更完善的寫法是還要包含有取消訂閱的程式碼，如下：\ndata: MyData; private readonly onDestroy = new Subject(); ngOnInit() { this.dataService.getData() .pipe( takeUntil(this.onDestroy) ).subscribe( data = this.data = data, ); } ngOnDestroy() { this.onDestroy.next(); this.onDestroy.complete(); } Observable 與 async pipe 但其實在 Angular 中，模板裡不僅限於使用靜態值。我們可以直接在模板中使用 Observables。換句話說，很少需要在元件類別(component class)中訂閱的 Observable。實際上需要值的是模板(template)，所以我們應該在那裡訂閱。\n更好的作法是在模版中使用 AysncPipe，它用來訂閱 Observable 並監聽取得回傳值，並且它還負責在元件銷毀時取消訂閱。\n@Component({...}) export class Component { readonly data$ = this.dataService.getData(); constructor(private readonly dataService: DataService) { } } 在模版中使用 async pipe 來訂閱 data$ 這個 Observable 並取得回傳值來顯示在畫面中。使用這樣的寫法可以清楚的看出來取得資料的邏輯其實不須要存在元件類別中的。\np {{ (data$ | async).name }} p 另一個範例：\ndata?: { name: string, time: Date }; constructor(private readonly dataService: DataService) { } ngOnInit() { this.dataService.getData().subscribe( response = { const first = response.data[0]; this.data = { name: first.name, time: new Date(first.time) } } ); } 可重構成：\nreadonly data$ = this.dataService.getData().pipe( map((response) = { const first = response.data[0]; return { name: response.name, time: new Date(response.time) } }), ); constructor(private readonly dataService: DataService) { } 由上述二個例子了解，只須多利用 RxJs 的各種 Operator 與 async pipe，即可減少使用 ngOnInit hook 的使用了。\n嵌套 Observables 的較佳寫法 在使用後端資料時，常會有一種使用情境是呼收 API 時需要由 routing 中取得資料（如：ID）例如\nhero?: { name: string }; constructor( private readonly route: ActivatedRoute, private readonly heroService: HeroService, ) { } ngOnInit() { this.route.params.subscribe( (params) =  { const id = params.id; this.heroService.getHero(id).subscribe( response = this.hero = response ); } )\t} 在這個範例中看到二個問題：\n 嵌套 Observables 的寫法 使用 ngOnInit 的必要性  程式碼重構如下：\nreadonly hero$ = this.route.params.pipe( switchMap(params = this.heroService.getHero(params.id)) ); constructor( private readonly route: ActivatedRoute, private readonly heroService: HeroService, ) { } p {{ (hero$ | async).name }} p 可使用 Observables 寫法免除在 ngOnInit hook 中多餘的程式碼 與 使用 switchMap operator 來消除嵌套 Observables 呼叫方式。\n如何解決模板中過多的 async 使用 問題來了，當在模板中使用了過多的 async，除了混淆模板外甚至會産生一些性能的問題。\n在許多 element 中使用了單一個 Observable，如：\np {{ (hero$ | async).name }} p p {{ (hero$ | async).lastname }} p p {{ (hero$ | async).city }} p 解決這個問題可善用 NgIf 這個“指令“，代碼如下：\nng-container *ngIf=\"hero$ | async as hero\" p {{ hero.name }} p p {{ hero.surname }} p p {{ hero.city }} p ng-container 其中透過 *ngIf 指令中的 as 用法，使得我們在 p 元素中去綁定 hero 這個變數而不是 (hero$ | async)，使用這種技術來保存從 AsyncPIpe 解析出來的值，並在僅訂閱一次的情況下在許多元素中去使用它。 另外這段另一個 Angular 指令： ng-container，ng-container這個指令在實際産出時不會有任何額外的元素在 DOM 中。\n善用 RxJs Operator 來解決 component 中使用到許多的 Observable 的問題 如下範例：\nreadonly hero$ = this.route.params.pipe( switchMap(params = this.heroService.getHero(params.id)) ); readonly pet$ = this.route.params.pipe( switchMap(params = this.heroService.getPet(params.id)) ); readonly cities$ = this.heroService.getCities(); constructor( private readonly route: ActivatedRoute, private readonly heroService: HeroService, ) { } 可重構成：\nreadonly vm$ = combineLatest([ this.route.params.pipe( switchMap(params = this.heroService.getHero(params.id)) ), this.route.params.pipe( switchMap(params = this.heroService.getPet(params.id)) ), this.heroService.getCities(), ]).pipe( map(([hero, pet, cities]) = { return { hero, pet, cities } }) ); constructor( private readonly route: ActivatedRoute, private readonly heroService: HeroService, ) { } 首先，只有當 route 參數産生變化時才分別發出 getHero、getPet與 getCities 的 fetch request，同時透過 combineLatest operator 在所有的 request 都取回資料後來産生一個 Observable。 第二是將陣列資料 mapping 到具有屬性名稱的物件中。 這使得我們的模版變得簡潔了許多\nng-container *ngIf=\"vm$ | async as vm\" p {{ vm.hero.name }} p p {{ vm.hero.surname }} p p {{ vm.hero.city }} p p {{ vm.pet.name }} p ul li *ngFor=\"let city of vm.cities\" {{ city }} li ul ng-container ngOnInit 與 ngOnChanges 有時我們可能會因為誤用 ngOnInit 而産生一些 bug，特別是在一些包含有子元件的父元件中，讓我們來看看範例：\n@Component({ template: ` {{ fullName }} `, }) export class NameComponent implements OnInit { @Input() name: string; @Input() lastname: string; fullName: string; ngOnInit() { this.fullName = `${this.name}${this.lastname}`; } } 這樣的程式碼在開始時是可正常工作的，但一旦 input 值有更動時就不會更新資料。\n那麼如何在每次輸入值有更動時要能正確的顯示最新資料呢？有兩種方法：\n 使用適合的 Hook，所以要改用 ngOnChanges 使用 setters 技術  每次輸入更改時 ngOnChanges 會被運行，因此我們可以使用這個 hook 根據輸入資料更新我們的內部狀態。\n@Component({ template: ` {{ fullName }} `, }) export class NameComponent implements OnChanges { @Input() name: string; @Input() surname: string; fullName: string; ngOnChanges() { this.fullName = `${this.name}${this.surname}`; } } 在第一次 ngOnChanges 被呼叫(由 input 資料更新而觸發)後，會緊隨著呼叫 ngOnInit，但僅限一次，ngOnChanges 資料的再更新而被再次的觸發，但 ngOnInit 則不會了。 除此不同外，ngOnChanges 傳入的資料是一個相對完整的　SimpleChanges 參數，它提供了當前和先前的狀態值。\n如果你要處理的資料邏輯是如此簡單，其實可以採用相對簡易的 getters 方式來完成，如：\n@Component({ template: ` {{ fullName }} `, changeDetection: ChangeDetectionStrategy.OnPush, }) export class NameComponent { @Input() name: string; @Input() surname: string; get fullName(): string { return `${this.name}${this.surname}` } } 當然也可採用 Setters 的方式，如：\nCopy interface MyDTO { data: { name: string; time: string; }[] } @Component({ template: ` {{ time }} `, }) export class TimeComponent { @Input() set vm(value: MyDTO) { const first = value.data[0]; this.time = new Date(first.time); } time: Date; } 採用 Getters 或 Setters 的方式就可以不用管到生命週期鉤子的相關技術。如果你要的結果不會依賴一個以上的 input value，那麼這種技術是很好用的。\n","wordCount":"761","inLanguage":"en","datePublished":"2022-01-02T00:00:00Z","dateModified":"2022-01-02T00:00:00Z","author":{"@type":"Person","name":"Theme PaperMod"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://calvinegs.github.io/posts/angular-ngoninit/"},"publisher":{"@type":"Organization","name":"永誌不忘 • 筆記簿","logo":{"@type":"ImageObject","url":"https://calvinegs.github.io/img/favicon.png"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://calvinegs.github.io/ accesskey=h title="永誌不忘 • 筆記簿 (Alt + H)">永誌不忘 • 筆記簿</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://calvinegs.github.io/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://calvinegs.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://calvinegs.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://calvinegs.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://calvinegs.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://calvinegs.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://calvinegs.github.io/posts/>Posts</a></div>
<h1 class=post-title>
關於 Angular中的 constructor 與 ngOnInit
</h1>
<div class=post-description>
在本篇筆記中來紀錄一下 Angular中的 constructor 與 ngOnInit 有何不同的使用情境，另也探討 ngOnInit 與 ngOnChanges 有何不同
</div>
<div class=post-meta><span title="2022-01-02 00:00:00 +0000 UTC">January 2, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href=https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/angular-ngonInit.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#angular%e4%b8%ad%e7%9a%84-constructor-%e8%88%87-ngoninit aria-label="Angular中的 constructor 與 ngOnInit">Angular中的 constructor 與 ngOnInit</a><ul>
<li>
<a href=#ngoninit-%e8%88%87-constructor aria-label="ngOnInit 與 constructor">ngOnInit 與 constructor</a></li>
<li>
<a href=#ngoninit-%e6%98%af%e5%90%a6%e7%82%ba%e5%bf%85%e9%a0%88 aria-label="ngOnInit 是否為必須">ngOnInit 是否為必須</a></li>
<li>
<a href=#observable-%e8%88%87-async-pipe aria-label="Observable 與 async pipe">Observable 與 async pipe</a></li>
<li>
<a href=#%e5%b5%8c%e5%a5%97-observables-%e7%9a%84%e8%bc%83%e4%bd%b3%e5%af%ab%e6%b3%95 aria-label="嵌套 Observables 的較佳寫法">嵌套 Observables 的較佳寫法</a></li>
<li>
<a href=#%e5%a6%82%e4%bd%95%e8%a7%a3%e6%b1%ba%e6%a8%a1%e6%9d%bf%e4%b8%ad%e9%81%8e%e5%a4%9a%e7%9a%84-async-%e4%bd%bf%e7%94%a8 aria-label="如何解決模板中過多的 async 使用">如何解決模板中過多的 async 使用</a></li>
<li>
<a href=#%e5%96%84%e7%94%a8-rxjs-operator-%e4%be%86%e8%a7%a3%e6%b1%ba-component-%e4%b8%ad%e4%bd%bf%e7%94%a8%e5%88%b0%e8%a8%b1%e5%a4%9a%e7%9a%84-observable-%e7%9a%84%e5%95%8f%e9%a1%8c aria-label="善用 RxJs Operator 來解決 component 中使用到許多的 Observable 的問題">善用 RxJs Operator 來解決 component 中使用到許多的 Observable 的問題</a></li>
<li>
<a href=#ngoninit-%e8%88%87-ngonchanges aria-label="ngOnInit 與 ngOnChanges">ngOnInit 與 ngOnChanges</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=angular中的-constructor-與-ngoninit>Angular中的 constructor 與 ngOnInit<a hidden class=anchor aria-hidden=true href=#angular中的-constructor-與-ngoninit>#</a></h1>
<p>在本篇筆記中來紀錄一下 Angular中的 constructor 與 ngOnInit 有何不同的使用情境，也探討一下 ngOnInit() 的非必要性。</p>
<h2 id=ngoninit-與-constructor>ngOnInit 與 constructor<a hidden class=anchor aria-hidden=true href=#ngoninit-與-constructor>#</a></h2>
<p>ngOnInit() 與 Class 中的其他 Method 無異，僅因為它剛好被命名為 ngOnInit，常會被與 constructor 搞混用途。其實它並非是必要的，完全取決於你。當 Angular 編譯器進行程式編譯時會將是否 Class 中有實現 ngOnInit() 的方法記錄在特定的 Flag 中，這個 Flag 會在 &ldquo;變更檢測"時決定是不是要呼叫 ngOnInit() 這個方法。</p>
<p>而 constructor 則完全是另外的一件事，不管你有沒有在類別中實現它，在建立類別實例時它都會被呼叫到。</p>
<p>Angular啟動時的二個主要階段：</p>
<ul>
<li>建構元件樹(component tree)</li>
<li>執行變更檢測(change detection)</li>
</ul>
<p>constructor 是在第一個階段被呼叫的，這就是為什麼我們不能將任何依賴於 DOM、元素、輸入數據、綁定等的初始化邏輯放在constructor— 因為它們尚不可使用。
而 ngOnInit 則在第二階段，實際上所有的生命週期鉤子都是“變更檢測”階段的一部份。</p>
<p>當 Angular 開始變更檢測時，組件樹已被構建，樹中所有組件的構造函數都被調用。它已經完成了組件 DOM 的創建，通過構造函數注入了所有必需的依賴項並處理了輸入綁定。每個組件的模板節點都被添加到 DOM 中。 也可以取得初始化組件可能需要的所有資料，如：DI Provider、DOM 和輸入綁定(input bindings)。</p>
<p>在實際的使用案例上 constructor 最常被使用的是用來“注入依賴項目”(當然不僅限於此)</p>
<h2 id=ngoninit-是否為必須>ngOnInit 是否為必須<a hidden class=anchor aria-hidden=true href=#ngoninit-是否為必須>#</a></h2>
<p>在之前使用 angular cli(如：14.0.6) 産生 component 會發現 component class 程式碼中是預設會使用到 ngOnInit 的。但在新版的 angular cli 中(如：15.0.4) 産生的程式架構中已預設不用使用 ngOnInit (與constructor) 了。</p>
<p><code>angular cli 14.0.6</code></p>
<p><img loading=lazy src=https://user-images.githubusercontent.com/21993717/210241077-61b92621-3aeb-4595-9be4-02ef2a9425ac.png alt=v13ComponentClass>
</p>
<p><code>angular cli 15.0.4</code></p>
<p><img loading=lazy src=https://user-images.githubusercontent.com/21993717/210241108-46594182-a3c6-454b-b39e-a0f0bfeb57da.png alt="v15 0 4ComponentClass">
</p>
<p>其實：</p>
<ul>
<li>在處理 Observables 時你不需要 ngOnInit</li>
<li>大多數時候，ngOnChanges 是 ngOnInit 的更好選擇</li>
</ul>
<p>以下就要來說說如何不使用 ngOnInit 的一些寫法。</p>
<p>常見的例子是 Angular 使用 Fetch 來讀取後端 API 資料顯示在畫面，寫法如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#a6e22e>data</span>: <span style=color:#66d9ef>MyData</span>;

<span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>dataService</span>: <span style=color:#66d9ef>DataService</span>) { }

<span style=color:#a6e22e>ngOnInit() {</span>
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dataService</span>.<span style=color:#a6e22e>getData</span>().<span style=color:#a6e22e>subscribe</span>(
    <span style=color:#a6e22e>data</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>data</span>,	<span style=color:#75715e>//透過訂閱取得 data 後利用資料綁定的功能將資料顯示在模版中
</span><span style=color:#75715e></span>  );
}
</code></pre></div><p>更完善的寫法是還要包含有取消訂閱的程式碼，如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#a6e22e>data</span>: <span style=color:#66d9ef>MyData</span>;

<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>onDestroy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Subject</span>();

<span style=color:#a6e22e>ngOnInit() {</span>
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dataService</span>.<span style=color:#a6e22e>getData</span>()
    .<span style=color:#a6e22e>pipe</span>(
      <span style=color:#a6e22e>takeUntil</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>onDestroy</span>)
    ).<span style=color:#a6e22e>subscribe</span>(
      <span style=color:#a6e22e>data</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>data</span>,
    );
}

<span style=color:#a6e22e>ngOnDestroy() {</span>
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>onDestroy</span>.<span style=color:#a6e22e>next</span>();
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>onDestroy</span>.<span style=color:#a6e22e>complete</span>();
}
</code></pre></div><h2 id=observable-與-async-pipe>Observable 與 async pipe<a hidden class=anchor aria-hidden=true href=#observable-與-async-pipe>#</a></h2>
<p>但其實在 Angular 中，模板裡不僅限於使用靜態值。我們可以直接在模板中使用 Observables。換句話說，很少需要在元件類別(component class)中訂閱的 Observable。實際上需要值的是模板(template)，所以我們應該在那裡訂閱。</p>
<p>更好的作法是在模版中使用 AysncPipe，它用來訂閱 Observable 並監聽取得回傳值，並且它還負責在元件銷毀時取消訂閱。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#66d9ef>@Component</span>({...})
<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Component</span> {
  
  <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>data$</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dataService</span>.<span style=color:#a6e22e>getData</span>();
	
  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>dataService</span>: <span style=color:#66d9ef>DataService</span>) { }
}
</code></pre></div><p>在模版中使用 async pipe 來訂閱 data$ 這個 Observable 並取得回傳值來顯示在畫面中。使用這樣的寫法可以清楚的看出來取得資料的邏輯其實不須要存在元件類別中的。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>p</span>&gt; {{ (data$ | async).name }} &lt;/<span style=color:#f92672>p</span>&gt;
</code></pre></div><p>另一個範例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#a6e22e>data</span><span style=color:#f92672>?:</span> { <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>time</span>: <span style=color:#66d9ef>Date</span> };

<span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>dataService</span>: <span style=color:#66d9ef>DataService</span>) { }

<span style=color:#a6e22e>ngOnInit() {</span>
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dataService</span>.<span style=color:#a6e22e>getData</span>().<span style=color:#a6e22e>subscribe</span>(
    <span style=color:#a6e22e>response</span> <span style=color:#f92672>=&gt;</span> {
      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>first</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>0</span>];
      
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> {
        <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>first.name</span>,
        <span style=color:#a6e22e>time</span>: <span style=color:#66d9ef>new</span> Date(<span style=color:#a6e22e>first</span>.<span style=color:#a6e22e>time</span>)
      }
    }
  );
}
</code></pre></div><p>可重構成：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>data$</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dataService</span>.<span style=color:#a6e22e>getData</span>().<span style=color:#a6e22e>pipe</span>(
  <span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>response</span>) <span style=color:#f92672>=&gt;</span> {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>first</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>0</span>];
    
    <span style=color:#66d9ef>return</span> {
      <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>response.name</span>,
      <span style=color:#a6e22e>time</span>: <span style=color:#66d9ef>new</span> Date(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>time</span>)
    }
  }),
);

<span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>dataService</span>: <span style=color:#66d9ef>DataService</span>) { }
</code></pre></div><p>由上述二個例子了解，只須多利用 RxJs 的各種 Operator 與 async pipe，即可減少使用 ngOnInit hook 的使用了。</p>
<h2 id=嵌套-observables-的較佳寫法>嵌套 Observables 的較佳寫法<a hidden class=anchor aria-hidden=true href=#嵌套-observables-的較佳寫法>#</a></h2>
<p>在使用後端資料時，常會有一種使用情境是呼收 API 時需要由 routing 中取得資料（如：ID）例如</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#a6e22e>hero</span><span style=color:#f92672>?:</span> { <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span> };

<span style=color:#66d9ef>constructor</span>(
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>route</span>: <span style=color:#66d9ef>ActivatedRoute</span>,
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>heroService</span>: <span style=color:#66d9ef>HeroService</span>,
) { }

<span style=color:#a6e22e>ngOnInit() {</span>
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>route</span>.<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>subscribe</span>(
    (<span style=color:#a6e22e>params</span>) <span style=color:#f92672>=</span> <span style=color:#f92672>&gt;</span> {
      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>id</span>;

      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>heroService</span>.<span style=color:#a6e22e>getHero</span>(<span style=color:#a6e22e>id</span>).<span style=color:#a6e22e>subscribe</span>(
        <span style=color:#a6e22e>response</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>hero</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>response</span>
      );
    }
  )	
}
</code></pre></div><p>在這個範例中看到二個問題：</p>
<ul>
<li>嵌套 Observables 的寫法</li>
<li>使用 ngOnInit 的必要性</li>
</ul>
<p>程式碼重構如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>hero$</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>route</span>.<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>pipe</span>(
  <span style=color:#a6e22e>switchMap</span>(<span style=color:#a6e22e>params</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>heroService</span>.<span style=color:#a6e22e>getHero</span>(<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>id</span>))
);

<span style=color:#66d9ef>constructor</span>(
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>route</span>: <span style=color:#66d9ef>ActivatedRoute</span>,
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>heroService</span>: <span style=color:#66d9ef>HeroService</span>,
) { }
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>p</span>&gt; {{ (hero$ | async).name }} &lt;/<span style=color:#f92672>p</span>&gt;
</code></pre></div><p>可使用 Observables 寫法免除在 ngOnInit hook 中多餘的程式碼 與 使用 switchMap operator 來消除嵌套 Observables 呼叫方式。</p>
<h2 id=如何解決模板中過多的-async-使用>如何解決模板中過多的 async 使用<a hidden class=anchor aria-hidden=true href=#如何解決模板中過多的-async-使用>#</a></h2>
<p>問題來了，當在模板中使用了過多的 async，除了混淆模板外甚至會産生一些性能的問題。</p>
<p>在許多 element 中使用了單一個 Observable，如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>p</span>&gt; {{ (hero$ | async).name }} &lt;/<span style=color:#f92672>p</span>&gt;
&lt;<span style=color:#f92672>p</span>&gt; {{ (hero$ | async).lastname }} &lt;/<span style=color:#f92672>p</span>&gt;
&lt;<span style=color:#f92672>p</span>&gt; {{ (hero$ | async).city }} &lt;/<span style=color:#f92672>p</span>&gt;
</code></pre></div><p>解決這個問題可善用 NgIf 這個“指令“，代碼如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>ng-container</span> <span style=color:#960050;background-color:#1e0010>*</span><span style=color:#a6e22e>ngIf</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;hero$ | async as hero&#34;</span>&gt;
  &lt;<span style=color:#f92672>p</span>&gt; {{ hero.name }} &lt;/<span style=color:#f92672>p</span>&gt;
  &lt;<span style=color:#f92672>p</span>&gt; {{ hero.surname }} &lt;/<span style=color:#f92672>p</span>&gt;
  &lt;<span style=color:#f92672>p</span>&gt; {{ hero.city }} &lt;/<span style=color:#f92672>p</span>&gt;
&lt;/<span style=color:#f92672>ng-container</span>&gt;
</code></pre></div><p>其中透過 *ngIf 指令中的 as 用法，使得我們在 p 元素中去綁定 hero 這個變數而不是 (hero$ | async)，使用這種技術來保存從 <code>AsyncPIpe</code> 解析出來的值，並在僅訂閱一次的情況下在許多元素中去使用它。
另外這段另一個 Angular 指令： ng-container，ng-container這個指令在實際産出時不會有任何額外的元素在 DOM 中。</p>
<h2 id=善用-rxjs-operator-來解決-component-中使用到許多的-observable-的問題>善用 RxJs Operator 來解決 component 中使用到許多的 Observable 的問題<a hidden class=anchor aria-hidden=true href=#善用-rxjs-operator-來解決-component-中使用到許多的-observable-的問題>#</a></h2>
<p>如下範例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>hero$</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>route</span>.<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>pipe</span>(
  <span style=color:#a6e22e>switchMap</span>(<span style=color:#a6e22e>params</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>heroService</span>.<span style=color:#a6e22e>getHero</span>(<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>id</span>))
);

<span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>pet$</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>route</span>.<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>pipe</span>(
  <span style=color:#a6e22e>switchMap</span>(<span style=color:#a6e22e>params</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>heroService</span>.<span style=color:#a6e22e>getPet</span>(<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>id</span>))
);

<span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>cities$</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>heroService</span>.<span style=color:#a6e22e>getCities</span>();

<span style=color:#66d9ef>constructor</span>(
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>route</span>: <span style=color:#66d9ef>ActivatedRoute</span>,
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>heroService</span>: <span style=color:#66d9ef>HeroService</span>,
) { }
</code></pre></div><p>可重構成：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>vm$</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>combineLatest</span>([
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>route</span>.<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>pipe</span>(
    <span style=color:#a6e22e>switchMap</span>(<span style=color:#a6e22e>params</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>heroService</span>.<span style=color:#a6e22e>getHero</span>(<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>id</span>))
  ),
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>route</span>.<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>pipe</span>(
    <span style=color:#a6e22e>switchMap</span>(<span style=color:#a6e22e>params</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>heroService</span>.<span style=color:#a6e22e>getPet</span>(<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>id</span>))
  ),
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>heroService</span>.<span style=color:#a6e22e>getCities</span>(),
]).<span style=color:#a6e22e>pipe</span>(
  <span style=color:#a6e22e>map</span>(([<span style=color:#a6e22e>hero</span>, <span style=color:#a6e22e>pet</span>, <span style=color:#a6e22e>cities</span>]) <span style=color:#f92672>=&gt;</span> {
    <span style=color:#66d9ef>return</span> {
      <span style=color:#a6e22e>hero</span>,
      <span style=color:#a6e22e>pet</span>,
      <span style=color:#a6e22e>cities</span>
    }
  })
);


<span style=color:#66d9ef>constructor</span>(
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>route</span>: <span style=color:#66d9ef>ActivatedRoute</span>,
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>heroService</span>: <span style=color:#66d9ef>HeroService</span>,
) { }
</code></pre></div><p>首先，只有當 route 參數産生變化時才分別發出 getHero、getPet與 getCities 的 fetch request，同時透過 combineLatest operator 在所有的 request 都取回資料後來産生一個 Observable。
第二是將陣列資料 mapping 到具有屬性名稱的物件中。
這使得我們的模版變得簡潔了許多</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>ng-container</span> <span style=color:#960050;background-color:#1e0010>*</span><span style=color:#a6e22e>ngIf</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;vm$ | async as vm&#34;</span>&gt;
  &lt;<span style=color:#f92672>p</span>&gt; {{ vm.hero.name }} &lt;/<span style=color:#f92672>p</span>&gt;
  &lt;<span style=color:#f92672>p</span>&gt; {{ vm.hero.surname }} &lt;/<span style=color:#f92672>p</span>&gt;
  &lt;<span style=color:#f92672>p</span>&gt; {{ vm.hero.city }} &lt;/<span style=color:#f92672>p</span>&gt;
  
  &lt;<span style=color:#f92672>p</span>&gt; {{ vm.pet.name }} &lt;/<span style=color:#f92672>p</span>&gt;
  
  &lt;<span style=color:#f92672>ul</span>&gt;
    &lt;<span style=color:#f92672>li</span> <span style=color:#960050;background-color:#1e0010>*</span><span style=color:#a6e22e>ngFor</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;let city of vm.cities&#34;</span>&gt; {{ city }} &lt;/<span style=color:#f92672>li</span>&gt;
  &lt;/<span style=color:#f92672>ul</span>&gt;
&lt;/<span style=color:#f92672>ng-container</span>&gt;
</code></pre></div><h2 id=ngoninit-與-ngonchanges>ngOnInit 與 ngOnChanges<a hidden class=anchor aria-hidden=true href=#ngoninit-與-ngonchanges>#</a></h2>
<p>有時我們可能會因為誤用 ngOnInit 而産生一些 bug，特別是在一些包含有子元件的父元件中，讓我們來看看範例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#66d9ef>@Component</span>({
  <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`&lt;p&gt; {{ fullName }} &lt;/p&gt;`</span>,
})
<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NameComponent</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>OnInit</span> {
  <span style=color:#66d9ef>@Input</span>() <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
  <span style=color:#66d9ef>@Input</span>() <span style=color:#a6e22e>lastname</span>: <span style=color:#66d9ef>string</span>;

  <span style=color:#a6e22e>fullName</span>: <span style=color:#66d9ef>string</span>;

  <span style=color:#a6e22e>ngOnInit() {</span>
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>fullName</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lastname</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
  }
}
</code></pre></div><p>這樣的程式碼在開始時是可正常工作的，但一旦 input 值有更動時就不會更新資料。</p>
<p>那麼如何在每次輸入值有更動時要能正確的顯示最新資料呢？有兩種方法：</p>
<ul>
<li>使用適合的 Hook，所以要改用 ngOnChanges</li>
<li>使用 setters 技術</li>
</ul>
<p>每次輸入更改時 ngOnChanges 會被運行，因此我們可以使用這個 hook 根據輸入資料更新我們的內部狀態。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#66d9ef>@Component</span>({
  <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`&lt;p&gt; {{ fullName }} &lt;/p&gt;`</span>,
})
<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NameComponent</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>OnChanges</span> {
  <span style=color:#66d9ef>@Input</span>() <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
  <span style=color:#66d9ef>@Input</span>() <span style=color:#a6e22e>surname</span>: <span style=color:#66d9ef>string</span>;

  <span style=color:#a6e22e>fullName</span>: <span style=color:#66d9ef>string</span>;

  <span style=color:#a6e22e>ngOnChanges() {</span>
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>fullName</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>surname</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
  }
}
</code></pre></div><p>在第一次 ngOnChanges 被呼叫(由 input 資料更新而觸發)後，會緊隨著呼叫 ngOnInit，但僅限一次，ngOnChanges 資料的再更新而被再次的觸發，但 ngOnInit 則不會了。
除此不同外，ngOnChanges 傳入的資料是一個相對完整的　SimpleChanges 參數，它提供了當前和先前的狀態值。</p>
<p>如果你要處理的資料邏輯是如此簡單，其實可以採用相對簡易的 getters 方式來完成，如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#66d9ef>@Component</span>({
  <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`&lt;p&gt; {{ fullName }} &lt;/p&gt;`</span>,
  <span style=color:#a6e22e>changeDetection</span>: <span style=color:#66d9ef>ChangeDetectionStrategy.OnPush</span>,
})
<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NameComponent</span> {
  <span style=color:#66d9ef>@Input</span>() <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
  <span style=color:#66d9ef>@Input</span>() <span style=color:#a6e22e>surname</span>: <span style=color:#66d9ef>string</span>;

  <span style=color:#66d9ef>get</span> <span style=color:#a6e22e>fullName</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>surname</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>
  }
}
</code></pre></div><p>當然也可採用 Setters 的方式，如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=color:#a6e22e>Copy</span>
<span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>MyDTO</span> {
  <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
    <span style=color:#a6e22e>time</span>: <span style=color:#66d9ef>string</span>;
  }[]
}

<span style=color:#66d9ef>@Component</span>({
  <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`&lt;p&gt; {{ time }} &lt;/p&gt;`</span>,
})
<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TimeComponent</span> {
  <span style=color:#66d9ef>@Input</span>() 
  <span style=color:#66d9ef>set</span> <span style=color:#a6e22e>vm</span>(<span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>MyDTO</span>) {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>first</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>0</span>];
   
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>time</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Date(<span style=color:#a6e22e>first</span>.<span style=color:#a6e22e>time</span>);
  }

  <span style=color:#a6e22e>time</span>: <span style=color:#66d9ef>Date</span>;
}
</code></pre></div><p>採用 Getters 或 Setters 的方式就可以不用管到生命週期鉤子的相關技術。如果你要的結果不會依賴一個以上的 input value，那麼這種技術是很好用的。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://calvinegs.github.io/tags/angular/>angular</a></li>
<li><a href=https://calvinegs.github.io/tags/rxjs/>rxjs</a></li>
<li><a href=https://calvinegs.github.io/tags/life-cycle/>life cycle</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://calvinegs.github.io/posts/dotnet5-webapi/>
<span class=title>« Prev Page</span>
<br>
<span>ASP.NET Core 5 Web API - 從無到有</span>
</a>
<a class=next href=https://calvinegs.github.io/posts/nvs-using/>
<span class=title>Next Page »</span>
<br>
<span>使用 nvs 來管理不同版本 Node.js 執行環境</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share 關於 Angular中的 constructor 與 ngOnInit on twitter" href="https://twitter.com/intent/tweet/?text=%e9%97%9c%e6%96%bc%20Angular%e4%b8%ad%e7%9a%84%20constructor%20%e8%88%87%20ngOnInit&url=https%3a%2f%2fcalvinegs.github.io%2fposts%2fangular-ngoninit%2f&hashtags=angular%2crxjs%2clifecycle"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 關於 Angular中的 constructor 與 ngOnInit on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcalvinegs.github.io%2fposts%2fangular-ngoninit%2f&title=%e9%97%9c%e6%96%bc%20Angular%e4%b8%ad%e7%9a%84%20constructor%20%e8%88%87%20ngOnInit&summary=%e9%97%9c%e6%96%bc%20Angular%e4%b8%ad%e7%9a%84%20constructor%20%e8%88%87%20ngOnInit&source=https%3a%2f%2fcalvinegs.github.io%2fposts%2fangular-ngoninit%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 關於 Angular中的 constructor 與 ngOnInit on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcalvinegs.github.io%2fposts%2fangular-ngoninit%2f&title=%e9%97%9c%e6%96%bc%20Angular%e4%b8%ad%e7%9a%84%20constructor%20%e8%88%87%20ngOnInit"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 關於 Angular中的 constructor 與 ngOnInit on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcalvinegs.github.io%2fposts%2fangular-ngoninit%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 關於 Angular中的 constructor 與 ngOnInit on whatsapp" href="https://api.whatsapp.com/send?text=%e9%97%9c%e6%96%bc%20Angular%e4%b8%ad%e7%9a%84%20constructor%20%e8%88%87%20ngOnInit%20-%20https%3a%2f%2fcalvinegs.github.io%2fposts%2fangular-ngoninit%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 關於 Angular中的 constructor 與 ngOnInit on telegram" href="https://telegram.me/share/url?text=%e9%97%9c%e6%96%bc%20Angular%e4%b8%ad%e7%9a%84%20constructor%20%e8%88%87%20ngOnInit&url=https%3a%2f%2fcalvinegs.github.io%2fposts%2fangular-ngoninit%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
<div>
<div id=disqus_thread></div>
<script type=text/javascript>(function(){var a,b;if(window.location.hostname=="localhost")return;a=document.createElement('script'),a.type='text/javascript',a.async=!0,b='calvinegs-github-io',a.src='//'+b+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=https://calvinegs.github.io/>永誌不忘 • 筆記簿</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>