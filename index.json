[{"content":"在此要討論的是有關 TypeScript 的 型別推論(type inference) 與 型別註記(type annotation)\n關於 Javascript 的型別 Javascript 是個動態型別的語言，也就是說擁有 \u0026lsquo;型別\u0026rsquo; 的是 \u0026lsquo;值\u0026rsquo; 而不是變數。\nlet myVar; console.log(`${myVar}: ${typeof myVar}`); // undefined : undefined myVar = 20; console.log(`${myVar}: ${typeof myVar}`); // 20 : number myVar = \u0026#34;Hi\u0026#34;; console.log(`${myVar}: ${typeof myVar}`); // Hi : string myVar = true; console.log(`${myVar}: ${typeof myVar}`); // true : boolean Type Annotation (型別註記) TypeScript 提供靜型別功能，讓我們可以明確指定變數的型別。編譯器在轉譯過程即可偵測到使用不同型別時主動抛出錯誤訊息。下面的例子就是使用型別註記來定義靜態型別:\nfunction calculateTax(amount: number): number { return amount * 1.2; } console.log(`${20}: ${calculateTax(20)}`); //20: 24 console.log(`${\u0026#34;Hello\u0026#34;}: ${calculateTax(\u0026#34;Hello\u0026#34;)}`); //error console.log(`${true}: ${calculateTax(true)}`); //error Type inference (型別推論) TypeScript 編譯器可以根據變數宣告時給定的值來推論它的型別。\nfunction calculateTax(amount: number): number { return amount * 1.2; } let price = 100; //未給定資料型別，由給定的值推論此時的 price 變數型別為 number let taxAmount = calculateTax(price); //未給定資料型別，由回傳值推論此時的變數型別為 number，因為 calculateTax 型別註記為 number let halfShare = taxAmount / 2; //未給定資料型別，由計算結果值推論此時的變數型別為 number console.log(`Full amount in tax: ${taxAmount}`); //Full amount in tax: 120 console.log(`Half share: ${halfShare}`); //Half share: 60 調整 tsc 編輯參數來查看編譯器所採用的型別 tsc 編譯器推論的型別若與預期的有出入，可以在 tscconfig.json \u0026ldquo;compilerOptions\u0026quot;中加入一條\u0026quot;declaration\u0026rdquo;: true 的設定值\n{ \u0026quot;compilerOptions\u0026quot;: { \u0026quot;target\u0026quot;: \u0026quot;es2020\u0026quot;, \u0026quot;outDir\u0026quot;: \u0026quot;./dist\u0026quot;, \u0026quot;rootDir\u0026quot;: \u0026quot;./src\u0026quot;, \u0026quot;declaration\u0026quot;: true } } 上述範例改成:\nfunction calculateTax(amount: number) { return (amount * 1.2).toFixed(2); } let price = 100; //未給定資料型別，由給定的值推論此時的 price 變數型別為 number let taxAmount = calculateTax(price); //未給定資料型別，由回傳值推論此時的變數型別為 string，因為 calculateTax function toFixed(2) 結果是 string let halfShare = taxAmount / 2; // 產生錯誤 console.log(`Full amount in tax: ${taxAmount}`); //Full amount in tax: 120 console.log(`Half share: ${halfShare}`); //Half share: 60 由於 toFixed(2) 回傳的是 string，導致 taxAmount 變數型別被推論成 string 而產生錯誤警告。 tsc 因為在 tscconfig.json 多加入了編輯參數 \u0026ldquo;declaration\u0026rdquo;: true，這個參數告訴編譯器，除了輸出程式碼轉譯外，還要輸芔包含型別宣告資訊的 .d.ts 檔，所以會在 build 目錄中產生一個 index.d.js，內容如下圖，可以看到 taxAmount 被推論成 string\ndeclare function calculateTax(amount: number): string; declare let price: number; declare let taxAmount: string; declare let halfShare: number; 關於 Any 的型別推論 將範例改成如下圖，calculateTax 回傳值及傳入參數皆註記成為 any\nfunction calculateTax(amount: any): any { return (amount * 1.2).toFixed(2); } let price = 100; //未給定資料型別，由給定的值推論此時的 price 變數型別為 number let taxAmount = calculateTax(price); //由於 calcaulateTax 型別註記為 any，故被推論成 any let halfShare = taxAmount / 2; // 未給定資料型別，(any / 2) 計算結果會被推論成 number console.log(`Full amount in tax: ${taxAmount}`); //Full amount in tax: 120.00 console.log(`Half share: ${halfShare}`); //Half share: 60 結果發現在 index.d.js 檔中 taxAmount 也被推論成 any，且編譯結果正常。\ndeclare function calculateTax(amount: any): any; declare let price: number; declare let taxAmount: any; declare let halfShare: number; 但這樣的使用 any 型別，你會發現這和寫 javascript 程式碼無任何差別，也就是說你讓程式自行承擔結東，而沒有用到 TypeScript 靜態型別的好處(編譯時期即可檢查出程式可能出問題的地方)。\n我們來測試一下，將 calculateTax function 改成如下:\nfunction calculateTax(amount: any): any { return `$${(amount * 1.2).toFixed(2)}`; } 再執行看看，發現編譯程式時正常，確在執行時期產生非預期結果\nFull amount in tax: $120.00 Half share: NaN 結論就是你應該儘可能的不要有 any 這樣的型別註記。\nContextual Typing (依照背景來進行的型態推論) TypeScript 使用變量的位置來推斷它們的類型，這就是所謂的 contextual typing\ndocument.addEventListener(\u0026#34;click\u0026#34;, function (event) { console.log(event.button); // }); 在這個例子中，TypeScript 因為 click 事件而知道 event 參數是 MouseEvent 的一個實例。\ndocument.addEventListener(\u0026#34;scroll\u0026#34;, function (event) { console.log(event.button); // compiler error }); 而在這個例子中，因為是 \u0026lsquo;scroll\u0026rsquo; 事件，所以參數中不能是 button，因此轉譯時會產生錯誤。\nwindow.onmousedown = function(mouseEvent) { console.log(mouseEvent.button); //\u0026lt;- OK console.log(mouseEvent.kangaroo); //\u0026lt;- Error! }; Typescript 型別檢查器使用 Window.onmousedown 函數的型別來推斷賦值右邊的函數運算式的型別。因此，它能夠推斷出 mouseEvent 參數的型別，它確實包含一個按鈕屬性，但不包含袋鼠屬性。\n","permalink":"https://calvinegs.github.io/posts/ts-type-inferenc-annotation/","summary":"在此要討論的是有關 TypeScript 的 型別推論(type inference) 與 型別註記(type annotation)\n關於 Javascript 的型別 Javascript 是個動態型別的語言，也就是說擁有 \u0026lsquo;型別\u0026rsquo; 的是 \u0026lsquo;值\u0026rsquo; 而不是變數。\nlet myVar; console.log(`${myVar}: ${typeof myVar}`); // undefined : undefined myVar = 20; console.log(`${myVar}: ${typeof myVar}`); // 20 : number myVar = \u0026#34;Hi\u0026#34;; console.log(`${myVar}: ${typeof myVar}`); // Hi : string myVar = true; console.log(`${myVar}: ${typeof myVar}`); // true : boolean Type Annotation (型別註記) TypeScript 提供靜型別功能，讓我們可以明確指定變數的型別。編譯器在轉譯過程即可偵測到使用不同型別時主動抛出錯誤訊息。下面的例子就是使用型別註記來定義靜態型別:\nfunction calculateTax(amount: number): number { return amount * 1.2; } console.","title":"型別推論(type inference) 與 型別註記(type annotation)"},{"content":"TodoApp(Donet 5): Sqlite + EF + Asp.net Code Generator 使用 dotnet cli 建立專案 $ dotnet --version # 檢查 dotnet 版本，目前版本為: 5.0.201 $ dotnet new webapi -n \u0026#34;Todo5\u0026#34; \u0026amp;\u0026amp; cd \u0026#34;Todo5\u0026#34; $ ls # 查看 專案檔案結構 $ dotnet new gitignore # 使用 dotnet cli 來產生預設的 git ignore 檔案 建立 git 初始版本 $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝本機工具 此方式安裝的工具，僅限本機存取(只針對目前的目錄和子目錄)， 首先透過 dotnet new tool-manifest 命令來產生工具資訊清單檔，再使用 dotnet tool install 來安裝各式工具程式。這樣的方式好處是在專案若多人協助方式時，則可利用 dotnet tool restore 命令將紀錄在 .config/dotnet-tools.json 的工具資訊清單檔重建在不同協助人員的電腦中。\n$ dotnet new tool-manifest #會產生 .config/dotnet-tools.json 檔案 $ dotnet tool install dotnet-ef --version 5.0.13 #使用 local 安裝方式來安裝 Entity Framework 工具 $ dotnet tool install dotnet-aspnet-codegenerator --version 5.0.2 #使用 local 安裝方式來安裝 Code Generator 工具 $ cat .\\.config\\dotnet-tools.json # 查看安裝上述二項工具後的設定資訊 { \u0026#34;version\u0026#34;: 1, \u0026#34;isRoot\u0026#34;: true, \u0026#34;tools\u0026#34;: { \u0026#34;dotnet-ef\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;5.0.13\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-ef\u0026#34;] }, \u0026#34;dotnet-aspnet-codegenerator\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;5.0.2\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-aspnet-codegenerator\u0026#34;] } } } 安裝程式使用的相關套件 $ dotnet add package Microsoft.EntityFrameworkCore.Sqlite --version 5.0.13 #Sqlite 使用的套件 $ dotnet add package Microsoft.EntityFrameworkCore.Tools --version 5.0.13 #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.Design --version 5.0.13 #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 5.0.13 #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 5.0.2 #搭配 dotnet-aspnet-codegenerator 使用 安裝的程式套件資訊紀錄在 \u0026ldquo;專案\u0026rdquo;.csproj 檔案中\n$ cat .\\Todo5.csproj #查看 安裝套件的相關設定值 \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;RootNamespace\u0026gt;_5Todo\u0026lt;/RootNamespace\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Design\u0026#34; Version=\u0026#34;5.0.13\u0026#34;\u0026gt; \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Sqlite\u0026#34; Version=\u0026#34;5.0.13\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.SqlServer\u0026#34; Version=\u0026#34;5.0.13\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;5.0.13\u0026#34;\u0026gt; \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;5.0.2\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;5.6.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; 建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add EFCore NuGet packages\u0026#34; 新增 database context (自動產生) $ dotnet ef dbcontext scaffold \u0026#34;Data Source=app.db; Cache=Shared\u0026#34; Microsoft.EntityFrameworkCore.Sqlite -c ApiDbContext -o Data #在專案目錄 ./Data 子目錄下新建立一個 ApiDbContext.cs 的 DB Context file $ dotnet run #可使用 dotnet watch run 命令來自動監控程式碼的變動 開啟瀏覽器查看以下網址 \u0026ldquo;https://localhost:5001/WeatherForecast\u0026rdquo; [ { \u0026#34;date\u0026#34;: \u0026#34;2022-01-11T11:44:43.1899069+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: -6, \u0026#34;temperatureF\u0026#34;: 22, \u0026#34;summary\u0026#34;: \u0026#34;Hot\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-12T11:44:43.190114+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 28, \u0026#34;temperatureF\u0026#34;: 82, \u0026#34;summary\u0026#34;: \u0026#34;Balmy\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-13T11:44:43.1901167+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 23, \u0026#34;temperatureF\u0026#34;: 73, \u0026#34;summary\u0026#34;: \u0026#34;Hot\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-14T11:44:43.1901169+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 42, \u0026#34;temperatureF\u0026#34;: 107, \u0026#34;summary\u0026#34;: \u0026#34;Warm\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-15T11:44:43.1901171+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 22, \u0026#34;temperatureF\u0026#34;: 71, \u0026#34;summary\u0026#34;: \u0026#34;Cool\u0026#34; } ] 開啟瀏覽器查看以下 Swagger 網址 \u0026ldquo;https://localhst:5001/swagger/index.html\u0026rdquo; 建立另一個 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Create dbcontext classes using dotnet-ef\u0026#34; Open VS Code $ Code . 在 Models 目錄下新增一個 model(模型) class - ItemData namespace Todo5.Models { public class ItemData { public int Id { get; set; } public string Title { get; set; } public string Details { get; set; } public bool Done { get; set; } } } 在 ApiDbContext.cs 中宣告一個 ItemData table public DbSet\u0026lt;ItemData\u0026gt; ItemDatas { get; set; }\nusing System; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata; using Todo5.Models; #nullable disable namespace Todo5.Data { public partial class ApiDbContext : DbContext { public DbSet\u0026lt;ItemData\u0026gt; ItemDatas { get; set; } public ApiDbContext() { } //...  } } 在 appsettings.json 檔案中新增 ConnectionString 設定資料 \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;DefaultConnection\u0026#34;: \u0026#34;Data Source=app.db;Cache=Shared\u0026#34; }, 在 Startup.cs 檔案中註冊 database context (連絡到 Sqlite DB) services.AddDbContext\u0026lt;ApiDbContext\u0026gt;(options =\u0026gt; options.UseSqlite( Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;) ) ); namespace TodoApp { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } // This method gets called by the runtime. Use this method to add services to the container.  public void ConfigureServices(IServiceCollection services) { services.AddDbContext\u0026lt;ApiDbContext\u0026gt;(options =\u0026gt; options.UseSqlite( Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;) ) ); services.AddControllers(); // ...  } }; } 移除預設產生的樣本程式碼的 WeatherForecast.cs \u0026amp; WeatherForecastController.cs Add the initial migration to create the database $ dotnet build $ dotnet ef migrations add \u0026#34;Initial Migrations\u0026#34; $ dotnet ef database update (在根目錄產生 app.db sqlite database) 使用 ASPNET Codegenerator 自動產生 Todo Controller $ dotnet aspnet-codegenerator controller -name TodoController -async -api -m ItemData -dc ApiDbContext -outDir Controllers 執行 Swagger 開啟瀏覽器查看以下網址 \u0026ldquo;https://localhst:5001/swagger/index.html\u0026rdquo;\n透過 POST Method 新增一筆資料\n使用 GET Method 查詢資料 ","permalink":"https://calvinegs.github.io/posts/dotnet5-webapi/","summary":"TodoApp(Donet 5): Sqlite + EF + Asp.net Code Generator 使用 dotnet cli 建立專案 $ dotnet --version # 檢查 dotnet 版本，目前版本為: 5.0.201 $ dotnet new webapi -n \u0026#34;Todo5\u0026#34; \u0026amp;\u0026amp; cd \u0026#34;Todo5\u0026#34; $ ls # 查看 專案檔案結構 $ dotnet new gitignore # 使用 dotnet cli 來產生預設的 git ignore 檔案 建立 git 初始版本 $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝本機工具 此方式安裝的工具，僅限本機存取(只針對目前的目錄和子目錄)， 首先透過 dotnet new tool-manifest 命令來產生工具資訊清單檔，再使用 dotnet tool install 來安裝各式工具程式。這樣的方式好處是在專案若多人協助方式時，則可利用 dotnet tool restore 命令將紀錄在 .","title":"ASP.NET Core 5 Web API"},{"content":"Angular 的版本更新迭代的相當快 (所有的前端開於工具都有相同的情形)，安裝及使用 Angular Cli 時必須在有 Node.js 的環境下才能進行。\n當你在同一台電腦中使用不同版本的 Angular 時就容易在安裝相關套件時遇到警語，原因常是因為 Angular 與 Node.js 版本搭配的關係。\n至於為何有同時使用不同版本的 Angular 呢? 除了開發的專案沒有全部都一起升級至統一版本(這是一件複雜的事)的因素外，個人最常遇到的狀況是: 當在網上(github)找到很棒的 Demo / Sample 程式，在 git clone 回電腦後發現它的版本是舊版本 Angular 所撰寫，使用 npm install 安裝相關套件時，出現警告訊息，甚至無法安裝成功。\n為了要管理同一台電腦中存在著有不同版 Node.js，讓你很容易在各版本中自由的進行切換 (甚至在進入不同目錄時自動切換對應的 Node.js 版本)，你需要 Node.js 版本管理工具，如: NVM 或 NVS，在這個筆記中要記錄的是 NVS。\n安裝 nvs F:\\\u0026gt; choco list nvs #先查看是否已安裝了 nvs F:\\\u0026gt; choco install nvs #安裝 nvs F:\\\u0026gt; nvs --version #查看是否安裝成功，並顯示 nvs 版本 安裝不同版本 Node.js 以個人工作環境為例，目前使用的 Angular 是 13.0 搭配的 Node.js 版本是 V16.10.0。\n當我需要參考其他範例時，如在 github 找到一個範例程式，git clone 後，查看該專案發現它撰寫時使用 Angular 8.2.0 這個版本\nPS F:\\test\\angular-forms-workshop\u0026gt; cat package.json\n{ \u0026#34;name\u0026#34;: \u0026#34;angular-forms-workshop\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34; }, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@ng-bootstrap/ng-bootstrap\u0026#34;: \u0026#34;^5.1.0\u0026#34;, \u0026#34;@ng-dynamic-forms/core\u0026#34;: \u0026#34;^9.0.1\u0026#34;, \u0026#34;@ng-dynamic-forms/ui-ng-bootstrap\u0026#34;: \u0026#34;^9.0.1\u0026#34;, \u0026#34;angular2-text-mask\u0026#34;: \u0026#34;^9.0.0\u0026#34;, \u0026#34;bootstrap\u0026#34;: \u0026#34;^4.3.1\u0026#34;, \u0026#34;rxjs\u0026#34;: \u0026#34;~6.4.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^1.10.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.9.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;~0.802.0\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/language-service\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;~8.9.4\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~3.3.8\u0026#34;, \u0026#34;@types/jasminewd2\u0026#34;: \u0026#34;~2.0.3\u0026#34;, \u0026#34;codelyzer\u0026#34;: \u0026#34;^5.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~3.4.0\u0026#34;, \u0026#34;jasmine-spec-reporter\u0026#34;: \u0026#34;~4.2.1\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~4.1.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~2.2.0\u0026#34;, \u0026#34;karma-coverage-istanbul-reporter\u0026#34;: \u0026#34;~2.0.1\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~2.0.1\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;^1.4.0\u0026#34;, \u0026#34;protractor\u0026#34;: \u0026#34;~5.4.0\u0026#34;, \u0026#34;ts-node\u0026#34;: \u0026#34;~7.0.0\u0026#34;, \u0026#34;tslint\u0026#34;: \u0026#34;~5.15.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~3.5.3\u0026#34; } } 若直接使用 npm install 來回復此專案的套件，將會出現許多的警告訊息，如下圖:\n查閱對照表後發現 Angular 8.2 版本應該搭配的是 Node.js 10.9.0 ( Angular 與 Node.js 對照表 )\n此時可透過 nvs 來額外再安裝 Node.js 10.9.0 版本到你的系統中，並將 Node.js 使用版本 切換到 10.9.0\nPS F:\\test\\angular-forms-workshop\u0026gt; nvs add 10.9.0 PS F:\\test\\angular-forms-workshop\u0026gt; nvs use 10.9.0 完成後，使用這個 正確 的版本就可以順利安裝相關的套件了。\n同一時間，我又在 github 找到另一個合適的範例程式，git clone 後，查看該專案撰寫時是使用那個版本的 Angular，發現是 11.2.13\nPS F:\\test\\angular-forms-workshop\u0026gt; cd ..\\angular.io-example\\ PS F:\\test\\angular.io-example\u0026gt; cat package.json { \u0026#34;name\u0026#34;: \u0026#34;angular.io-example\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;rxjs\u0026#34;: \u0026#34;6.6.7\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;2.2.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;0.10.3\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;3.6.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;jasmine-marbles\u0026#34;: \u0026#34;0.6.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/animations\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;angular-in-memory-web-api\u0026#34;: \u0026#34;0.11.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;11.2.13\u0026#34; }, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;~0.1102.12\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~11.2.12\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;~11.2.13\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~3.6.0\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^12.11.1\u0026#34;, \u0026#34;codelyzer\u0026#34;: \u0026#34;^6.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~3.6.0\u0026#34;, \u0026#34;jasmine-spec-reporter\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~6.1.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~3.1.0\u0026#34;, \u0026#34;karma-coverage\u0026#34;: \u0026#34;~2.0.3\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~4.0.0\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;^1.5.0\u0026#34;, \u0026#34;protractor\u0026#34;: \u0026#34;~7.0.0\u0026#34;, \u0026#34;ts-node\u0026#34;: \u0026#34;~8.3.0\u0026#34;, \u0026#34;tslint\u0026#34;: \u0026#34;~6.1.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~4.1.5\u0026#34; } } 一樣的道理，透過 nvs 再多安裝 Node.js 12.11.1 版本\nPS F:\\test\\angular-forms-workshop\u0026gt; nvs add 12.11.1 nvs 的使用方法 查看目前所有已安裝的 Node.js 版本\nPS F:\\test\\angular-forms-workshop\u0026gt; nvs ls\nnode/16.10.0/x64 #Angular 13 所搭配的 Node.js 版本 node/14.15.5/x64 (Fermium) #Angular 12 所搭配的 Node.js 版本 node/12.11.1/x64 #Angular 11 所搭配的 Node.js 版本 node/10.9.0/x64 #Angular 8 所搭配的 Node.js 版本 node/8.9.4/x64 #Angular 7 所搭配的 Node.js 版本 手動切換 PS F:\\test\\angular-forms-workshop\u0026gt; nvs use 10 #使用(切換到)第十版，在範例中會自動切換到 10.9.0 PS F:\\test\\angular-forms-workshop\u0026gt; node -v #顯示目前使用中的 Node.js 版本 v10.9.0 PS F:\\test\\angular-forms-workshop\u0026gt; nvs ls #前導 \u0026#39;\u0026gt;\u0026#39; 符號表示是目前`使用中`的版本 node/16.10.0/x64 node/14.15.5/x64 (Fermium) node/12.11.1/x64 \u0026gt;node/10.9.0/x64 node/8.9.4/x64 (Carbon) 自動切換 每個目錄若搭配 .node-version 檔名的文字檔，且內容是 Node.js 的版本資訊:\nPS F:\\test\u0026gt; node -v \u0026gt; .node-version #將版本資訊寫入 .node-version 檔案中 PS F:\\test\u0026gt; cat .node-version #查看內容 v10.9.0 除有上述檔案及內容外，還必須搭配 開啓 nvs 自動切換 功能\nPS F:\\test\u0026gt; nvs auto on \n以上兩個條件都成立時，當切換不同現行目錄時，系統會自動選擇套用不同的 Node.js 版本\nPS F:\\test\u0026gt; cd .\\angular.io-example\\ PATH += $env:LOCALAPPDATA\\nvs\\node\\12.11.1\\x64 PS F:\\test\\angular.io-example\u0026gt; node -v v12.11.1 PS F:\\test\\angular.io-example\u0026gt; cat .\\.node-version v12.11.1 PS F:\\test\\angular.io-example\u0026gt; cd ..\\angular-forms-workshop\\ PATH -= $env:LOCALAPPDATA\\nvs\\node\\12.11.1\\x64 PATH += $env:LOCALAPPDATA\\nvs\\node\\10.9.0\\x64 PS F:\\test\\angular-forms-workshop\u0026gt; node -v v10.9.0 半自動型手動切換 若 nvs 自動切換 功能設為 off 則可視為所謂的 半自動 模式。\n無.node-version 檔案，也無 nvs 也無設定預設版本的情況:\nPS F:\\test\u0026gt; nvs use\n上述指令等同 nvs use default (nvs use auto、nvs auto 亦同義) 就是切換所在目錄的 Node.js 版本，系統第一優先查看的現行目錄中的 .node-version 檔案裡所指定的 Node.js 版本，若無 .node-version 檔案，則使用 nvs default (預設)版本，若 nvs 也無設定預設版本，則會將目前的 \u0026lsquo;使用版本\u0026rsquo; reset 成 null。\n","permalink":"https://calvinegs.github.io/posts/nvs-using/","summary":"Angular 的版本更新迭代的相當快 (所有的前端開於工具都有相同的情形)，安裝及使用 Angular Cli 時必須在有 Node.js 的環境下才能進行。\n當你在同一台電腦中使用不同版本的 Angular 時就容易在安裝相關套件時遇到警語，原因常是因為 Angular 與 Node.js 版本搭配的關係。\n至於為何有同時使用不同版本的 Angular 呢? 除了開發的專案沒有全部都一起升級至統一版本(這是一件複雜的事)的因素外，個人最常遇到的狀況是: 當在網上(github)找到很棒的 Demo / Sample 程式，在 git clone 回電腦後發現它的版本是舊版本 Angular 所撰寫，使用 npm install 安裝相關套件時，出現警告訊息，甚至無法安裝成功。\n為了要管理同一台電腦中存在著有不同版 Node.js，讓你很容易在各版本中自由的進行切換 (甚至在進入不同目錄時自動切換對應的 Node.js 版本)，你需要 Node.js 版本管理工具，如: NVM 或 NVS，在這個筆記中要記錄的是 NVS。\n安裝 nvs F:\\\u0026gt; choco list nvs #先查看是否已安裝了 nvs F:\\\u0026gt; choco install nvs #安裝 nvs F:\\\u0026gt; nvs --version #查看是否安裝成功，並顯示 nvs 版本 安裝不同版本 Node.js 以個人工作環境為例，目前使用的 Angular 是 13.0 搭配的 Node.","title":"使用 nvs 來管理不同版本 Node.js 執行環境"},{"content":" ","permalink":"https://calvinegs.github.io/posts/ngcli-nodejs-verion/","summary":" ","title":"Angular cli 與 Node.js 版本對照"},{"content":"TypeScript 不僅已可使用在主機端來進行 Node.js 程式的開發，也支援前端開發的眾多架構，使用 TypeScript 有許多額外的好處，因此學習 TypeScript 是現在軟體開發工程師不可缺的一項技能。本文是用來記錄如何設置一個簡易的 TypeScript 開發環境，用來學習 TypeScript。\n開始設置 建立一個目錄\n$ mkdir typescript-starter $ cd typescript-starter 透過 npm 產生 package.json 檔案\n$ npm init -y 在 Local 端安裝 TypeScript\n$ npm install typescript --save-dev #or -D 為 Node.js 安裝類型檔\n$ npm install @types/node --save-dev 透過 tsc 建立 TypeScript 的設定檔 (tsconfig.json)\n$ npx tsc --init P.S. 由於 typescript 是安裝在 local，執行時要透過 npx 指令(由 npm 所提供)\n指定額外的參數\n$ npx tsc --init --init --rootDir src --outDir build --esModuleInterop --resolveJsonModule --lib es6 --module commonjs --allowJs true --noImplicitAny true  rootDir: tsc 轉碼器找尋程式的地方。 outDir: TypeScript 轉譯成 JavaScript 所存放的地方。 esModuleInterop: 若使用 commonjs 為此專案的 module system，則此設定值必須設定為 true。 resolveJsonModule: 若此專案會使用 JSON，則此設定值必須設定為 true。 lib: 指定為 \u0026lsquo;es6\u0026rsquo; 指可使用到新版 JS 的一些語言特性，指定 \u0026lsquo;es5\u0026rsquo; 則會有較高的相容易。 module: 指存 module system，如: commonjs。 allowJs: 此選項將允許您在 .ts 文件中包含 .js 文件。 noImplicitAny: 值為 true 時，在 TypeScript 文件中，不允許不明確地指定類型。  將多餘不會使用的參數移除\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;lib\u0026#34;: [\u0026#34;es6\u0026#34;], \u0026#34;allowJs\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;src\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;noImplicitAny\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;resolveJsonModule\u0026#34;: true } } 建立 src 目錄，並在此目錄下寫程式\n$ mkdir src $ touch src/index.ts 程式如下:\nimport * as cowsay from \u0026#34;cowsay\u0026#34;; console.log( cowsay.say({ text: \u0026#34;I\u0026#39;m a moooodule\u0026#34;, e: \u0026#34;oO\u0026#34;, T: \u0026#34;U \u0026#34;, }) ); 因為程式中使用到額外的 library - cowsay，要先安裝\n$ npm install cowsay 利用 tsc 來轉譯 TypeScript 成為 JavaScript\n$ npx tsc 轉譯成 es5 版本 JavaScript 的結果:\n\u0026#34;use strict\u0026#34;; // const aVar = \u0026#39;abc\u0026#39;; // console.log(\u0026#39;Hello world!\u0026#39; + `${aVar}`) var __createBinding = (this \u0026amp;\u0026amp; this.__createBinding) || (Object.create ? function (o, m, k, k2) { if (k2 === undefined) k2 = k; Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; }, }); } : function (o, m, k, k2) { if (k2 === undefined) k2 = k; o[k2] = m[k]; }); var __setModuleDefault = (this \u0026amp;\u0026amp; this.__setModuleDefault) || (Object.create ? function (o, v) { Object.defineProperty(o, \u0026#34;default\u0026#34;, { enumerable: true, value: v }); } : function (o, v) { o[\u0026#34;default\u0026#34;] = v; }); var __importStar = (this \u0026amp;\u0026amp; this.__importStar) || function (mod) { if (mod \u0026amp;\u0026amp; mod.__esModule) return mod; var result = {}; if (mod != null) for (var k in mod) if (k !== \u0026#34;default\u0026#34; \u0026amp;\u0026amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k); __setModuleDefault(result, mod); return result; }; Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); var cowsay = __importStar(require(\u0026#34;cowsay\u0026#34;)); console.log( cowsay.say({ text: \u0026#34;I\u0026#39;m a moooodule\u0026#34;, e: \u0026#34;Ox\u0026#34;, T: \u0026#34;V \u0026#34;, }) ); 使用一些有用的設定及 Script 安裝 ts-node 和 nodemon\nts-node 是一個 TypeScript 執行引擎和 Node.js 的 REPL。它以JIT方式將TypeScript轉譯為 JavaScript，使你能夠直接在 Node.js上 執行 TypeScript 而不需要預轉譯。通過 node 的模組載入 API 來實現的，使其能夠與其他 Node.js 工具和程式庫一起無縫使用。\nnodemon 是一個工具，它通過檢測程式目錄中的文件更改時可以自動重新啟動應用程式(本範例中是啟動 Node.js)，以此協助應用程式開發。\n$ npm install --save-dev ts-node nodemon 新增一個 nodemon 的設定檔 nodemon.json\n$ touch nodemon.json 內容如下:\n{ \u0026#34;watch\u0026#34;: [\u0026#34;src\u0026#34;], \u0026#34;ext\u0026#34;: \u0026#34;.ts,.js\u0026#34;, \u0026#34;ignore\u0026#34;: [], \u0026#34;exec\u0026#34;: \u0026#34;npx ts-node ./src/index.ts\u0026#34; } 在 package.json 中加入啟動的 script\n\u0026#34;start\u0026#34;: \u0026#34;nodemon\u0026#34;, 執行 scripts\nPS F:\\test\\ts\\ts-starter\u0026gt; npm start # npm start 是 npm run start 的 alias \u0026gt; ts-starter@1.0.0 start \u0026gt; nodemon [nodemon] 2.0.15 [nodemon] to restart at any time, enter `rs` [nodemon] watching path(s): src\\**\\* [nodemon] watching extensions: ts,js [nodemon] starting `npx ts-node ./src/index.ts` ________________________ \u0026lt; I\u0026#39;m a slaughtered deer \u0026gt; ------------------------ \\  ^__^ \\  (Ox)\\_______ (__)\\  )\\/\\  V ||----w | || || [nodemon] clean exit - waiting for changes before restart 直接修改程式碼，將 index.ts 中的 slaughtered deer 改成 deer，存檔後，系統將自動轉譯程式碼，並透過 Node.js 顯示出結果:\n","permalink":"https://calvinegs.github.io/posts/setup-typescript-env/","summary":"TypeScript 不僅已可使用在主機端來進行 Node.js 程式的開發，也支援前端開發的眾多架構，使用 TypeScript 有許多額外的好處，因此學習 TypeScript 是現在軟體開發工程師不可缺的一項技能。本文是用來記錄如何設置一個簡易的 TypeScript 開發環境，用來學習 TypeScript。\n開始設置 建立一個目錄\n$ mkdir typescript-starter $ cd typescript-starter 透過 npm 產生 package.json 檔案\n$ npm init -y 在 Local 端安裝 TypeScript\n$ npm install typescript --save-dev #or -D 為 Node.js 安裝類型檔\n$ npm install @types/node --save-dev 透過 tsc 建立 TypeScript 的設定檔 (tsconfig.json)\n$ npx tsc --init P.S. 由於 typescript 是安裝在 local，執行時要透過 npx 指令(由 npm 所提供)\n指定額外的參數\n$ npx tsc --init --init --rootDir src --outDir build --esModuleInterop --resolveJsonModule --lib es6 --module commonjs --allowJs true --noImplicitAny true  rootDir: tsc 轉碼器找尋程式的地方。 outDir: TypeScript 轉譯成 JavaScript 所存放的地方。 esModuleInterop: 若使用 commonjs 為此專案的 module system，則此設定值必須設定為 true。 resolveJsonModule: 若此專案會使用 JSON，則此設定值必須設定為 true。 lib: 指定為 \u0026lsquo;es6\u0026rsquo; 指可使用到新版 JS 的一些語言特性，指定 \u0026lsquo;es5\u0026rsquo; 則會有較高的相容易。 module: 指存 module system，如: commonjs。 allowJs: 此選項將允許您在 .","title":"設置 TypeScript 開發環境 (Node.js)"},{"content":"Hugo 內容文件中使用基本 Markdown 語法，還額外支援由 Hugo 所提供的加強語法(也支援基本 HTML 元素)。\n標題 (Headings) 要建立標題，請在文字前添加井字符號 #(請注意井字符號後要加入一個空格)。使用的井字符號的數量應與標題級別相對應。例如，要建立三級標題 (\u0026lt;h3\u0026gt;)，請使用三個井字符號（例如，### My Header）。\n段落 (Paragraphs) 一個 Markdown 段落是由一個或多個連續的文字行組成，它的前後要有一個以上的空行。\n文字區塊引用 (Blockquotes) 在段落的第一行最前面加\u0026quot;\u0026gt;\u0026quot;\n未註明出處的文字區塊引用 (Blockquote without attribution)  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n 註明出處的文字區塊引用 (Blockquote with attribution)  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n 斷行 (Line Breaks) 要建立換行符號 (\u0026lt;br\u0026gt;)，請以兩個或多個空格結束一行，然後鍵入 return鍵。\n表格 (Tables) 表格功能並不是 Markdown 規格, 不過 Hugo 支援這個好用的功能.\n   Name Age     Bob 27   Alice 23    表格內支援內嵌 Markdown 語法    Italics Bold Code     italics bold code    表格內的對齊功能    Number Next number Previous number     Five Six Four   Ten Eleven Nine   Seven Eight Six   Two Three One    程式碼區塊 (Code Blocks) 使用 \u0026lsquo;反引號\u0026rsquo; 的程式碼區塊 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用 \u0026lsquo;四個空格\u0026rsquo; 的程式碼區塊 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  使用 Hugo 內部支援 highlight shortcode 的程式碼區塊 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用 Gist 的程式區塊 \u0026lt;script src=\u0026quot;https://gist.github.com/spf13/7896402.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n 清單 有序清單  First item Second item Third item  無序清單  List item Another item And another item  巢狀清單  Fruit  Apple Orange Banana   Dairy  Milk Cheese     First item Second item Third item  Indented item Indented item   Fourth item  以數字開頭的無序清單 將\u0026rsquo;段落\u0026rsquo;加入清單中   This is the first list item.\n  Here\u0026rsquo;s the second list item.\nI need to add another paragraph below the second list item.\n  And here\u0026rsquo;s the third list item.\n  將\u0026rsquo;文字區塊引用\u0026rsquo;加入清單中   This is the first list item.\n  Here\u0026rsquo;s the second list item.\n A blockquote would look great below the second list item.\n   And here\u0026rsquo;s the third list item.\n  將\u0026rsquo;程式區塊\u0026rsquo;加入清單中   Open the file.\n  Find the following code block on line 21:\n \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt;    Update the title to match the name of your website.\n  將\u0026rsquo;圖檔\u0026rsquo;加入清單中   Open the file containing the Linux mascot.\n  Marvel at its beauty.\n  Close the file.\n  Task List 反引號的使用 水平線 (Horizontal Rules) Try to put a blank line before\u0026hellip;\n \u0026hellip;and after a horizontal rule.\n連結 (Links) My favorite search engine is Duck Duck Go.\nI love supporting the EFF.\nThis is the Markdown Guide.\nSee the section on code.\n斜體 \u0026amp; 強調 使用 * 符號套用在文字的前後方，即可將文字改為斜體字；而使用連續兩個*加在文字的前後方則會是強調文字。\n有時候，你得停一下腳步，等一等 心靈，讓心情平和，想一想自己生活中擁有的所有 美好 的東西。\n使用跳脫字元 要顯示原本用於格式化 Markdown 文件中的文字字元，請在該字符前添加反斜線 (\\)。\n其他元素的使用 — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://calvinegs.github.io/posts/markdown-syntax/","summary":"Hugo 內容文件中使用基本 Markdown 語法，還額外支援由 Hugo 所提供的加強語法(也支援基本 HTML 元素)。\n標題 (Headings) 要建立標題，請在文字前添加井字符號 #(請注意井字符號後要加入一個空格)。使用的井字符號的數量應與標題級別相對應。例如，要建立三級標題 (\u0026lt;h3\u0026gt;)，請使用三個井字符號（例如，### My Header）。\n段落 (Paragraphs) 一個 Markdown 段落是由一個或多個連續的文字行組成，它的前後要有一個以上的空行。\n文字區塊引用 (Blockquotes) 在段落的第一行最前面加\u0026quot;\u0026gt;\u0026quot;\n未註明出處的文字區塊引用 (Blockquote without attribution)  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n 註明出處的文字區塊引用 (Blockquote with attribution)  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n 斷行 (Line Breaks) 要建立換行符號 (\u0026lt;br\u0026gt;)，請以兩個或多個空格結束一行，然後鍵入 return鍵。","title":"Hugo 中使用的 Markdown 語法介紹"},{"content":"GitHub Page 功能是 GitHub 提供的一項支援靜態網頁的服務，只要在你的 repository 中加入一個名為 gh-pages 的分支，則 GitHub 便會預設將此分支內的檔案以靜態網頁的方式呈現，因此利用此特性就可很容易的製作一個簡單的網站。GitHub Pages 提供了二種不同形態的頁面 \u0026ldquo;User or organization site\u0026rdquo; \u0026amp; \u0026ldquo;Project Site\u0026rdquo;。其中個人/組織 網站一個 GitHub 帳號只能有一個、而專案網站則可以很多個。\n https://calvinegs.github.io #只有一個 https://calvinegs.github.io/project1\nhttps://calvinegs.github.io/project2\nhttps://calvinegs.github.io/project3\n\u0026hellip;\n 安裝步驟 Step 1: 在 GitHub 上建立一個 new repository Repository name 若為 Owner_name.github.io 即所謂的 User site，Repository name 即為靜態網站的網址。以下圖為例，有效網址為 https://calvinegs.github.io\nStep 2: 使用 GitHub Action 構建 Hugo 透過 GitHub Action 功能，在你每次將新版本的 Hugo 網站內容推送到 GitHub repository 時，GitHub 將自動建置網站。\n新增一個 .github/workflows/gh-pages.yml，內容如下:\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public Step 3: GitHub Page 的設置 在第一次推送 Hugo 網站內容推送到 GitHub repository 時，透過 GitHub Action 的建置，將在你的 repository 中新新一個分支名稱叫 gh-pages。請在 GitHub Page 的設置功能中將它由 \u0026ldquo;Main\u0026rdquo; 指向 \u0026ldquo;gh-pages\u0026rdquo; 分支。\nStep 4: 設置 Hugo 設定檔 將 Hugo 設定檔 config.toml 中的 baseURL 設定成 https://Owner_name.github.io。\nbaseurl = \u0026#34;https://calvinabba.github.io\u0026#34; DefaultContentLanguage = \u0026#34;en\u0026#34; title = \u0026#34;Beautiful Blog\u0026#34; theme = \u0026#34;beautifulhugo\u0026#34; ","permalink":"https://calvinegs.github.io/posts/deployhugo-githubpages/","summary":"GitHub Page 功能是 GitHub 提供的一項支援靜態網頁的服務，只要在你的 repository 中加入一個名為 gh-pages 的分支，則 GitHub 便會預設將此分支內的檔案以靜態網頁的方式呈現，因此利用此特性就可很容易的製作一個簡單的網站。GitHub Pages 提供了二種不同形態的頁面 \u0026ldquo;User or organization site\u0026rdquo; \u0026amp; \u0026ldquo;Project Site\u0026rdquo;。其中個人/組織 網站一個 GitHub 帳號只能有一個、而專案網站則可以很多個。\n https://calvinegs.github.io #只有一個 https://calvinegs.github.io/project1\nhttps://calvinegs.github.io/project2\nhttps://calvinegs.github.io/project3\n\u0026hellip;\n 安裝步驟 Step 1: 在 GitHub 上建立一個 new repository Repository name 若為 Owner_name.github.io 即所謂的 User site，Repository name 即為靜態網站的網址。以下圖為例，有效網址為 https://calvinegs.github.io\nStep 2: 使用 GitHub Action 構建 Hugo 透過 GitHub Action 功能，在你每次將新版本的 Hugo 網站內容推送到 GitHub repository 時，GitHub 將自動建置網站。\n新增一個 .github/workflows/gh-pages.yml，內容如下:\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.","title":"在 Github Pages 部署 Hugo 靜態網站"},{"content":"Hugo 是一個静態網站生成器，搭配 git 很適合來建立個人部落格。在一系列的筆記中將介紹如何安裝/使用相關工具與技術，目的是搭建一個完全免費的個人部落格。\n使用的相關工具/技術:\n Hugo git vs code gist github page Markdown  Chocolatey Chocolatey 是一個 Windows 上的套件管理工具，它結合了 Nuget 基礎服務與 powershell 指令，提供快速安裝應用程式與工具的服務，將安裝軟體的內容封裝到一個安裝包中，在 Chocolatey 中只需要一條簡單的指令就能完成搜尋、安裝、更新、解安裝等操作。\n在 Windows 10 上安裝 Chocolatey 在命令提示字元下執行以下指令\nPS C:\\\u0026gt;Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 移除 Chocolatey 刪除 C:\\ProgramData\\chocolatey 目錄及移除環境變數即可，搜尋 \u0026ldquo;編輯系統環境變數\u0026rdquo; \\ \u0026ldquo;進階\u0026rdquo; \\ \u0026ldquo;環境變數\u0026rdquo;\n安裝 hugo Step 1: 在 Windows 10 上使用 choco 安裝 hugo C:\\\u0026gt; choco install hugo -confirm C:\\\u0026gt; choco install hugo-extended - config C:\\\u0026gt; hugo version Step 2: Create a New Site (建立部落格網站) C:\\\u0026gt; hugo new site quickstart C:\\\u0026gt; hugo new site quickstart -f yml # 若要使用 config.yaml 為 config 設定檔，則加入額外參數 Step 3: Add a Theme (新增部落格主題) 請先確認在您的作業系統中已經安裝了 git\nC:\\\u0026gt; cd quickstart C:\\\u0026gt; git init C:\\\u0026gt; git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke C:\\\u0026gt; git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 在 config.toml 中加入 theme = \u0026ldquo;ananke\u0026rdquo;\nC:\\\u0026gt; echo \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml Step 4: Add Some Content (建立新文章) C:\\\u0026gt; hugo new posts/my-first-post.md 在 md file 中加入以下內容\n # Test Page\nThis is my first test page.\n Step 5: Start the Hugo server (本機測試) C:\\\u0026gt; hugo server -D 開啟瀏覽器，輸入網址 https://localhost:1313 ","permalink":"https://calvinegs.github.io/posts/installhugo-windows/","summary":"Hugo 是一個静態網站生成器，搭配 git 很適合來建立個人部落格。在一系列的筆記中將介紹如何安裝/使用相關工具與技術，目的是搭建一個完全免費的個人部落格。\n使用的相關工具/技術:\n Hugo git vs code gist github page Markdown  Chocolatey Chocolatey 是一個 Windows 上的套件管理工具，它結合了 Nuget 基礎服務與 powershell 指令，提供快速安裝應用程式與工具的服務，將安裝軟體的內容封裝到一個安裝包中，在 Chocolatey 中只需要一條簡單的指令就能完成搜尋、安裝、更新、解安裝等操作。\n在 Windows 10 上安裝 Chocolatey 在命令提示字元下執行以下指令\nPS C:\\\u0026gt;Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 移除 Chocolatey 刪除 C:\\ProgramData\\chocolatey 目錄及移除環境變數即可，搜尋 \u0026ldquo;編輯系統環境變數\u0026rdquo; \\ \u0026ldquo;進階\u0026rdquo; \\ \u0026ldquo;環境變數\u0026rdquo;\n安裝 hugo Step 1: 在 Windows 10 上使用 choco 安裝 hugo C:\\\u0026gt; choco install hugo -confirm C:\\\u0026gt; choco install hugo-extended - config C:\\\u0026gt; hugo version Step 2: Create a New Site (建立部落格網站) C:\\\u0026gt; hugo new site quickstart C:\\\u0026gt; hugo new site quickstart -f yml # 若要使用 config.","title":"在 Windows 10 使用 Hugo"}]