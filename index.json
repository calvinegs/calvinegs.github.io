[{"content":"github Source code\nContext API in ReactJS Context API 是 ReactJS 中的一項功能，它允許跨組件樹共享資料，而不必通過樹的每一層向下傳遞 props。它提供了一種通過組件樹傳遞資料而無需使用 props 的方法，使用 props 這對於具有多層組件的大型應用程序來說可能會變得很麻煩。\n使用 vite 建立一支 react web app 樣版 使用 yarn 語法\n$ yarn create vite react-context -- --template react \u0026amp;\u0026amp; cd react-context $ yarn $ yarn dev 使用 npm 語法\n$ npm create vite react-context -- --template react \u0026amp;\u0026amp; cd react-context $ npm i $ npm run dev 使用 props 來傳遞資料 先來看看原來使用 props 來傳遞資料給子元件的方式。\n將樣版中的 App.jsx 內容先全部移除，改以下列的程式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import \u0026#39;./App.css\u0026#39; const App = () =\u0026gt; {  return( \u0026lt;ParentClass color= \u0026#34;blue\u0026#34;/\u0026gt;  ); } const ParentClass = (props) =\u0026gt; (  \u0026lt;ChildClass color= {props.color} /\u0026gt; ) const ChildClass = (props) =\u0026gt; (  \u0026lt;GrandChildClass color= {props.color} /\u0026gt; ) const GrandChildClass = (props) =\u0026gt; (  \u0026lt;p\u0026gt;Color: {props.color}\u0026lt;/p\u0026gt; )   執行程式\n$ npm run dev 結果：\n在上述範例中，可以很清楚的看到缺點，由 App 傳入的 Color 資料值，實際上的使用者是 GrandChildClass，中間的 ParentClass 及 ChildClass 都只是過水，為了讓 GrandChildClass 可以正確的接收到 App 傳遞出的 color props，中間的這二層物件不得不重覆性的接收／傳遞出相同的 color props，顯然地不是一個最佳方式。\n使用 Context api 來看看使用 Context api 是如何更簡潔地達到相同的目的。\n使用 createContext 方法建立一個 Context 物件。 為了使用 Context API，首先需要使用 createContext() 方法創建一個 Context 物件。該物件將提供一種在組件樹中未直接相連的組件之間共享資料的方法。\n新增一支 ColorContext.js 檔案，內容如下：\n1 2 3  import { createContext } from \u0026#34;react\u0026#34;; export const ColorContext = createContext(\u0026#34;yellow\u0026#34;);   註：context 可以傳遞的不僅限於\u0026rsquo;值`，也可以是\n定義一個可提供資料給子元件的 provider component 函式、物件及陣列等等 新增一支 ColorProvider.js 程式，內容如下;\n1 2 3 4 5 6 7 8 9  function ColorProvider(props) { const [color, setColor] = useState(\u0026#34;blue\u0026#34;); return ( \u0026lt;ColorContext.Provider value={{ color, setColor }}\u0026gt; {props.children} \u0026lt;/ColorContext.Provider\u0026gt; ); }   建立子元件 新增最底層子元件 - GrandChild Component。\n在這個元件中使用 useContext hook 來取得最上層程式由 context 傳來的 State 資料 (color)。\n1 2 3 4 5 6 7 8 9 10 11 12  import { useContext } from \u0026#34;react\u0026#34;; import { ColorContext } from \u0026#34;./ColorContext\u0026#34;;  const GrandChildComponent = () =\u0026gt; { const { color, setColor} = useContext(ColorContext);  return ( \u0026lt;p\u0026gt;Color: {color}\u0026lt;/p\u0026gt; ) } export default GrandChildComponent;   新增次底層子元件 - Child Component，在這個‘過渡’層中不須任何傳遞資料的程式邏輯。\n1 2 3 4 5 6 7 8  import GrandChildComponent from \u0026#34;./GrandChildComponent\u0026#34;; const ChildComponent = (props) =\u0026gt; { return ( \u0026lt;GrandChildComponent\u0026gt;\u0026lt;/GrandChildComponent\u0026gt; ) } export default ChildComponent;   新增第一層子元件 - Parent Component, 這也是一個‘過渡’層中也不須任何傳遞資料的程式邏輯。\n1 2 3 4 5 6 7 8 9  import ChildComponent from \u0026#34;./ChildComponent\u0026#34;; function ParentComponent() { return ( \u0026lt;ChildComponent\u0026gt;\u0026lt;/ChildComponent\u0026gt; ) } export default ParentComponent;   將子元件包裹在 ColorContext Provider 中 在 App 程式中將 State 資料透過 Context Api (Context Provider) 傳給最底層的子元件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import \u0026#39;./App.css\u0026#39; import { ColorContext } from \u0026#39;./ColorContext\u0026#39;; import { useState } from \u0026#39;react\u0026#39;; import ParentComponent from \u0026#39;./ParentComponent\u0026#39;; const App = (props) =\u0026gt; { const [color, setColor] = useState(\u0026#34;pink\u0026#34;); return ( \u0026lt;ColorContext.Provider value={{ color, setColor }}\u0026gt; \u0026lt;ParentComponent/\u0026gt; \u0026lt;/ColorContext.Provider\u0026gt; ) } export default App   整個程式，由 App function 來設定 color 值，而由最底層的子元件來顯示 color 值，使用 Context Api 來傳值是不是顯得比使用 props 來得更為簡潔許多！\n","permalink":"https://calvinegs.github.io/posts/react-context/","summary":"github Source code\nContext API in ReactJS Context API 是 ReactJS 中的一項功能，它允許跨組件樹共享資料，而不必通過樹的每一層向下傳遞 props。它提供了一種通過組件樹傳遞資料而無需使用 props 的方法，使用 props 這對於具有多層組件的大型應用程序來說可能會變得很麻煩。\n使用 vite 建立一支 react web app 樣版 使用 yarn 語法\n$ yarn create vite react-context -- --template react \u0026amp;\u0026amp; cd react-context $ yarn $ yarn dev 使用 npm 語法\n$ npm create vite react-context -- --template react \u0026amp;\u0026amp; cd react-context $ npm i $ npm run dev 使用 props 來傳遞資料 先來看看原來使用 props 來傳遞資料給子元件的方式。","title":"Context API in ReactJS"},{"content":"Typed Form in angular 從 Angular 14 開始，Angular 為 Reactive Forms 添加了完整的內建類型安全功能，FormGroup、FormControl、FormArray、FormBuilder 皆預設具備有型別，好處當然就是在開發階段就可以避免一些因為型別而産生的問題錯誤。\n而原有在 Angular 13 中的 FormGroup、FormControl、FormArray、FormBuilder被改名成 UntypedFormGroup、UntypedFormControl、UnTypedFormArray、UnTypedFormBuilder，若有需要使用到跨型別表單的用法，可以透過這些原有的功能來完成。\n使用這些內建 Typeed form 功能除了獲得額外的型別安全好處，更令人高興的是無需對原程式進行任何代碼更改，就來看看要如何取得這些優點。\n以下面的 login Compoenet 為例，和舊版的程式相同，使用 FormBuilder API 來宣告 email 和 password 兩個表單欄位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Component({ selector: \u0026#39;login\u0026#39;, templateUrl: \u0026#39;./login.component.html\u0026#39;, styleUrls: [\u0026#39;./login.component.css\u0026#39;] }) export class LoginComponent { loginForm = this.fb.group({ email: [\u0026#39;\u0026#39;, { validators: [Validators.required, Validators.email] }], password: [\u0026#39;\u0026#39;, [Validators.required, Validators.minLength(8)]] }); constructor(private fb: FormBuilder) { } onLogin() { } }   Typed form 好處 auto-completion 當你要輸入以下程式碼時\nconst email = this.loginForm.value.email; 在 this.loginform.value. 後面 VSCode 就自動顯示表單所有的欄位供你選擇，如下圖：\n建議提示 欄位值給定不正確值(錯誤型態)時也不會從編譯器獲得有用的錯誤訊息 檔你輸入不正確的欄位值時，VSCode 也會得到有用的編譯器錯誤消息，以防我們將錯誤類型的值傳遞給特定的表單欄位。如：給 email 欄位指定“數值”\nthis.loginForm.patchValue({ email: 21 }) vSCode 告訴我們不能把數值指定給 字串欄位\n避免使用陷阱 以下程式看似平常，宣告一個 FormGroup 的變數，然後在 ngOnInit 中去初始化它。當這樣的使用方式不再建議使用，因為它會阻止您享用類型安全的好處。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  @Component({ selector: \u0026#39;login\u0026#39;, templateUrl: \u0026#39;./login.component.html\u0026#39;, styleUrls: [\u0026#39;./login.component.css\u0026#39;] }) export class LoginComponent implements OnInit { constructor(private fb: FormBuilder) { } ngOnInit() { loginForm: FormGroup = this.fb.group({ email: [\u0026#34;\u0026#34;, { validators: [Validators.required, Validators.email] }], password: [\u0026#39;\u0026#39;, [Validators.required, Validators.minLength(8)]] }); } }   你會發現在存取 form value 時不僅 auto-completion 的支援功能不見了，在使用 patchValue 方法時，也不再有欄位名稱的建議提示，欄位值給定不正確值(錯誤型態)時也不會從編譯器獲得有用的錯誤訊息。\n原因很簡單：因為我們將表單宣告為 FormGroup 類型，它隱式默認為 FormGroup\u0026lt;any\u0026gt;，這意味著你宣告的表單值將是 any 類型。眾所皆知的，any 本質上意味著編譯器沒有關於表單值的任何類型訊息，因此所有類型安全都被關閉，表單不再是類型安全的。\n因為只要善用 typescript 推論功能，不必特地去為 loginForm 指定為 FormGroup 型別。如果一定要，也就須一併為它宣告成“自定型別” － loginForm: FormGroup\u0026lt;T\u0026gt;\n使用或不使用 空值 null 預設的情況下，所有表單欄位都被認為是可以為空值的。這是因為當我們呼叫表單 reset() 方法時，我們通常希望 Angular 會將所有表單欄位設置為 null 值。當然可以選擇將表單欄位宣告為不可為空值，這意味著表單欄位將重置為其初始值而不是 null。\n下面的程式碼表示，欄位 email 不可以為空值： （透過 nonNullable 語法）\n1 2 3 4 5 6  form = this.fb.group({ email: this.fb.nonNullable.control(\u0026#34;\u0026#34;, {  validators: [Validators.required, Validators.email], }), password: [\u0026#39;\u0026#39;, [Validators.required, Validators.minLength(8)]] });   如果想要所有在 form group 中的欄位皆不可為 null 值，可以透過 fb.nonNullable 的語法來達成\n1 2 3 4 5 6  form = this.fb.nonNullable.group({  email: [\u0026#39;\u0026#39;, { validators: [Validators.required, Validators.email] }], password: [\u0026#39;\u0026#39;, [Validators.required, Validators.minLength(8)]] });   或則直接使用 NonNullableFormBuilder 也可達到相同效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  @Component({ selector: \u0026#39;login\u0026#39;, templateUrl: \u0026#39;./login.component.html\u0026#39;, styleUrls: [\u0026#39;./login.component.css\u0026#39;] }) export class LoginComponent { form = this.fb.group({ email: [\u0026#34;\u0026#34;, { validators: [Validators.required, Validators.email] }], password: [\u0026#34;\u0026#34;, [Validators.required, Validators.minLength(8)] ] });; constructor(private fb: NonNullableFormBuilder) { }  }   在上述情況下，當你 reset form 時會發現欄位值不會是空值而變成是空字串\n1 2 3 4 5 6 7  reset() { this.loginForm.reset(); console.log(this.loginForm.value); }   ","permalink":"https://calvinegs.github.io/posts/angular-typedform/","summary":"Typed Form in angular 從 Angular 14 開始，Angular 為 Reactive Forms 添加了完整的內建類型安全功能，FormGroup、FormControl、FormArray、FormBuilder 皆預設具備有型別，好處當然就是在開發階段就可以避免一些因為型別而産生的問題錯誤。\n而原有在 Angular 13 中的 FormGroup、FormControl、FormArray、FormBuilder被改名成 UntypedFormGroup、UntypedFormControl、UnTypedFormArray、UnTypedFormBuilder，若有需要使用到跨型別表單的用法，可以透過這些原有的功能來完成。\n使用這些內建 Typeed form 功能除了獲得額外的型別安全好處，更令人高興的是無需對原程式進行任何代碼更改，就來看看要如何取得這些優點。\n以下面的 login Compoenet 為例，和舊版的程式相同，使用 FormBuilder API 來宣告 email 和 password 兩個表單欄位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Component({ selector: \u0026#39;login\u0026#39;, templateUrl: \u0026#39;./login.component.html\u0026#39;, styleUrls: [\u0026#39;./login.component.css\u0026#39;] }) export class LoginComponent { loginForm = this.","title":"Typed Form in angular 15"},{"content":"在 Angular 中實現 CAPTCHA 驗證碼功能 先來看看完成後的效果：\n關於 reCAPTCHA 目前 reCAPTCHA 共有 v2、v3、Enterprise 三種版本。在此我們將採用 v2。使用 reCAPTCHA 需先申在 google 網站上申請 API Key，申請完成後會有二個 API Key，一個是被用來放在前端 App 中，另一個是使用在呼叫 Google API 取得驗證結果時要用的。申請網站在 https://www.google.com/recaptcha/admin，使用 Gmail 帳號登入，若從未申請過會跳到註冊新網站頁面：\n 識別這組 Key 用的標籤文字 reCAPTCHA 類型 (使用 v2) 應用網域 (本機測試可加 localhost) 登入 Gmail 是預設擁有者，可加入其他管理者 接受服務條款 傳送通知給擁有者（發生問題或流量異常時發送通知）  使用 Gmail 帳號進行登入 輸入好資料後按下提交\n完成後會産生二個 api key:\n按下“複製網站金鑰”備用。（將放至 angular login component 中）\n設置專案環境 這個專案不會從頭從無到有紀錄每一個建置的步驟，而是採取套用 “使用 Angular 14 建立 Reactive Form 表單驗證範例” 這篇筆記所完成的程式碼來擴充 reCAPTCHA 功能。\n複製即有專案 首先 git clone 即有的 MySQL 專案\n$ git clone https://github.com/calvinegs/angular14-auth-jwt.git angular-recaptcha $ cd angular-recaptcha 安裝 ngx-captcha 套件 由於我們的 angular 專案是 v14，所以安裝 ngx-captcha 時請指定 v12 版本。\n$ npm i ngx-captcha@12.0.2 在 App.module.ts 中匯入 NgxCaptchaModule 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { BoardAdminComponent } from \u0026#39;./pages/board-admin/board-admin.component\u0026#39;; import { BoardModeratorComponent } from \u0026#39;./pages/board-moderator/board-moderator.component\u0026#39;; import { BoardUserComponent } from \u0026#39;./pages/board-user/board-user.component\u0026#39;; import { authInterceptorProviders } from \u0026#39;./shared/interceptor/auth.interceptor\u0026#39;; import { NgxCaptchaModule } from \u0026#39;ngx-captcha\u0026#39;;  @NgModule({ declarations: [ AppComponent, LoginComponent, RegisterComponent, HomeComponent, ProfileComponent, BoardAdminComponent, BoardModeratorComponent, BoardUserComponent ], imports: [ BrowserModule, AppRoutingModule, ReactiveFormsModule, HttpClientModule, NgxCaptchaModule  ], providers: [authInterceptorProviders], bootstrap: [AppComponent] }) export class AppModule { }   將前述取得的 api key 寫入到 appSettings 中 appSettings.ts\n1 2 3 4 5 6  export const AppSettings = { API_URL : \u0026#39;http://localhost:5000/api/\u0026#39;, recaptcha: { siteKey: \u0026#39;6LeE4BwlAAAAADWMaRf8C8o8R91PYaoGfO3YQ2_f\u0026#39;, }, }   在 login component class 中加入相關程式 先在程式中(app.component.ts) 取得 AppSettings 中的 api key :\n1  siteKey: string = AppSettings.recaptcha.siteKey;   在原有的 login component 中登錄功能的表單僅有“user name“ 及 \u0026ldquo;password\u0026rdquo; 二個欄位，新加入 \u0026ldquo;recaptcha\u0026rdquo; 這個欄位。\n1 2 3 4 5 6 7  this.form = this.formBuilder.group( { username: [\u0026#39;\u0026#39;,[Validators.required]], password: [\u0026#39;\u0026#39;,[Validators.required]], recaptcha: [\u0026#39;\u0026#39;,[Validators.required]]  } )   在 login component view template 中加入 recaptcha 欄位 在 login.component.html 中加入新欄位的設定程式\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;ngx-recaptcha2 #captchaElem [siteKey]=\u0026#34;this.siteKey\u0026#34; formControlName=\u0026#34;recaptcha\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;recaptcha\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;recaptcha\u0026#39;].errors }\u0026#34; \u0026gt; \u0026lt;/ngx-recaptcha2\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;recaptcha\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;recaptcha\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;請勾選\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   完整的 login.component.html 程式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  \u0026lt;div class=\u0026#34;container-fluid register-form\u0026#34;\u0026gt; \u0026lt;form *ngIf=\u0026#34;!isLoggedIn\u0026#34; needs-validation [formGroup]=\u0026#34;form\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; 使用者登入 \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; autofocus formControlName=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;username\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Username 為必填\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;password\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Password 為必填\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;ngx-recaptcha2 #captchaElem [siteKey]=\u0026#34;this.siteKey\u0026#34; formControlName=\u0026#34;recaptcha\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;recaptcha\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;recaptcha\u0026#39;].errors }\u0026#34; \u0026gt; \u0026lt;/ngx-recaptcha2\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;recaptcha\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;recaptcha\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;請勾選\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;送出\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;onReset()\u0026#34; class=\u0026#34;btn btn-warning float-end\u0026#34;\u0026gt; 重置 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alert alert-warning\u0026#34; *ngIf=\u0026#34;isLoginFailed\u0026#34;\u0026gt; Signin failed!\u0026lt;br /\u0026gt;{{ errorMessage }} \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;alert alert-success\u0026#34; *ngIf=\u0026#34;isLoggedIn\u0026#34;\u0026gt; 登入者具備的角色 {{ roles }}. \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   完整的 login.component.ts 程式如下： 除前述的相關功能外，還額外在“重置”按鈕中加入了 reloadCaptcha 的功能， 來重置 reloadCaptcha 選項勾選的狀態。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  import { Component, OnInit, ViewChild } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormControl, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; import { ReCaptcha2Component } from \u0026#39;ngx-captcha\u0026#39;; import { AppSettings } from \u0026#39;src/app/shared/helpers/appSettings\u0026#39;; import { AuthService } from \u0026#39;src/app/shared/services/auth.service\u0026#39;; import { TokenStorageService } from \u0026#39;src/app/shared/services/token-storage.service\u0026#39;; @Component({ selector: \u0026#39;app-login\u0026#39;, templateUrl: \u0026#39;./login.component.html\u0026#39;, styleUrls: [\u0026#39;./login.component.scss\u0026#39;] }) export class LoginComponent implements OnInit { @ViewChild(\u0026#39;captchaElem\u0026#39;) captchaElem: ReCaptcha2Component | undefined; form: FormGroup = new FormGroup({ username: new FormControl(\u0026#39;\u0026#39;), password: new FormControl(\u0026#39;\u0026#39;), recaptcha: new FormControl(\u0026#39;\u0026#39;) }); siteKey: string = AppSettings.recaptcha.siteKey; isLoggedIn = false; isLoginFailed = false; submitted = false; errorMessage = \u0026#39;\u0026#39;; roles: string[] = []; constructor(private formBuilder: FormBuilder, private authService: AuthService, private tokenStorage: TokenStorageService) { } ngOnInit(): void { if (this.tokenStorage.getToken()) { this.isLoggedIn = true; this.roles = this.tokenStorage.getUser().roles; } this.form = this.formBuilder.group( { username: [\u0026#39;\u0026#39;,[Validators.required]], password: [\u0026#39;\u0026#39;,[Validators.required]], recaptcha: [\u0026#39;\u0026#39;,[Validators.required]] } ) } get f(): { [key: string]: AbstractControl } { return this.form.controls; } onSubmit(): void { this.submitted = true; if (this.form.invalid) { return; } const { username, password } = this.form.getRawValue(); this.authService.login(username, password).subscribe({ next: data =\u0026gt; { this.tokenStorage.saveToken(data.accessToken); this.tokenStorage.saveUser(data); this.isLoggedIn = true; this.roles = this.tokenStorage.getUser().roles; this.roloadPage(); }, error: err =\u0026gt; { this.errorMessage = err.error.message; this.isLoginFailed = true; } }) } roloadPage(): void { this.submitted = false; location.reload(); } onReset(): void { this.submitted = false; this.isLoginFailed = false; this.form.reset(); this.captchaElem?.reloadCaptcha(); } }   測試結果 按下“送出”時，所有必填欄位皆會檢核是否正確填妥資料。\n正常的登入流程，使用者僅須輸入“user name”、“password” 及 “勾選” “我不是機器人”選項即可送出\n當系統判斷出有可疑登入時便自動切人工輸入的方式來進行驗證\n","permalink":"https://calvinegs.github.io/posts/angular-recaptcha/","summary":"在 Angular 中實現 CAPTCHA 驗證碼功能 先來看看完成後的效果：\n關於 reCAPTCHA 目前 reCAPTCHA 共有 v2、v3、Enterprise 三種版本。在此我們將採用 v2。使用 reCAPTCHA 需先申在 google 網站上申請 API Key，申請完成後會有二個 API Key，一個是被用來放在前端 App 中，另一個是使用在呼叫 Google API 取得驗證結果時要用的。申請網站在 https://www.google.com/recaptcha/admin，使用 Gmail 帳號登入，若從未申請過會跳到註冊新網站頁面：\n 識別這組 Key 用的標籤文字 reCAPTCHA 類型 (使用 v2) 應用網域 (本機測試可加 localhost) 登入 Gmail 是預設擁有者，可加入其他管理者 接受服務條款 傳送通知給擁有者（發生問題或流量異常時發送通知）  使用 Gmail 帳號進行登入 輸入好資料後按下提交\n完成後會産生二個 api key:\n按下“複製網站金鑰”備用。（將放至 angular login component 中）\n設置專案環境 這個專案不會從頭從無到有紀錄每一個建置的步驟，而是採取套用 “使用 Angular 14 建立 Reactive Form 表單驗證範例” 這篇筆記所完成的程式碼來擴充 reCAPTCHA 功能。","title":"在 Angular 中實現 CAPTCHA 驗證碼功能"},{"content":"github Source code\n如何在 Angular 中使用 Standalone Components 本篇將要紀錄如何使 Angular 15 環境中使用 Standlone component。從版本 14 起就開始支援 Standalone component，Angular 15則正式的引入了獨立組件作為構建無模塊應用程序的簡單方法。獨立組件的好處之一是它們使新開發人員更容易學習和使用 Angular，因為它們可以不用使用到 NgModule。\nAngular 從第二個版本起，@NgModule就已是一個重要的核必功能，透過 @NgModule 為一個個單位來組織我們的應用程式，包含整個應用程式的啟動，所以每個 angular 應用程式都至少要有一個模組（也稱為根模組），由此可見它的重要性。說它是 Angular 的特色之一一點也不為過。但近年來這個特色功能卻也成為其他類似架構的攻擊目標，為了使系統支援更多樣化，Angular 15 正式引入了 Standalone 的各式運用。\n在本篇筆記中會提及如何建立及使用一個 Standalone component、如何在一個 Standalone component中去使用另一個 Standalone 子元件、如何在原有模式中(有 @NgModule)中載入 Standalone component，到最後如何在一個專案中完全不使用到 @NgModule 功能。\n建立新專案 透過 npm init @angular 語法來建立一個 angular project。\n$ npm init @angular standAloneComponent -- --routing --style=scss \u0026amp;\u0026amp; cd standaloneComponent 建立 Standalone Component $ npx ng g c components/containerLayout --standalone --inline-style --inline-template --flat 在由 cli 産生的程式碼架構中(container-layout.component.ts)，可以看到 meta data 中多了 standalone: true 與 imports: [CommonModule] m二個屬性設定資料。imports 中預設加入了 CommonModule，你也可以依需求自行加入其他模組，如：HttpClientModule，formsModule..等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import { Component } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; @Component({ selector: \u0026#39;app-container-layout\u0026#39;, standalone: true,  imports: [CommonModule], template: ` \u0026lt;p\u0026gt; container-layout works! \u0026lt;/p\u0026gt; `, styles: [ ] }) export class ContainerLayoutComponent { }   同時打開 app.module.ts 會發現 ng cli 不會再把 standalone component 自動加入到 NgModule 模塊中了。\n在 NgModule 中註冊 Standalone Component 首先，來看看如何在 NgMoudle 中註冊一個 standalone component。\n打開 app.module.ts 在 imports 宣告處加入前述新增的 standalone component - ContainerLayoutComponent。 (特別注意不是加在 declarations處，而是放在 imports 裡)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { ContainerLayoutComponent } from \u0026#39;./components/container-layout.component\u0026#39;;  @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, ContainerLayoutComponent  ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }   使用 Standalone Component 修改 app.component.html 內容如下:\n\u0026lt;app-container-layout\u0026gt;\u0026lt;/app-container-layout\u0026gt; 使用 npm start 啟動程式發現已經可以正確的使用 standalone component 了。\n建立 Standalone 子元件 接下來要來看看如何在 standalone component 中使用 standalone 子元件。\n再新建立一個 名為 logo 的 standalone 子元件\n$ npx ng g c components/logo --standalone --inline-style --inline-template --flat 我們要在這個子元件中顯示一個預設由網路上捉取到的一個 logo 圖示，所以 將建立好的 LogoComponent Component Class 內容修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import { Component, Input } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; @Component({ selector: \u0026#39;app-logo\u0026#39;, standalone: true, imports: [CommonModule], template: ` \u0026lt;img [src]=\u0026#34;logoName\u0026#34;\u0026gt; `, styles: [` img { padding: 1rem; } `] }) export class LogoComponent { @Input() logoName = \u0026#39;https://global-uploads.webflow.com/5e157547d6f791d34ea4e2bf/6087f7f9e5ecc6623f3ecbbe_logo-example2.svg\u0026#39; }   在 Standalone 元件中使用 Standalone 子元件 將建立好的子元件放置在 Container Layout 元件中，使用子元件方式一樣只須在 imports 中引用子元件即可，使用起來相當方便。\nimport { Component } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { LogoComponent } from \u0026#39;./logo.component\u0026#39;; @Component({ selector: \u0026#39;app-container-layout\u0026#39;, standalone: true, imports: [CommonModule, LogoComponent], template: ` \u0026lt;app-logo\u0026gt;\u0026lt;/app-logo\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;ng-content\u0026gt;\u0026lt;/ng-content\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;footer\u0026gt;2023\u0026lt;/footer\u0026gt; `, styles: [` .container { display: flex; background-color: #f5f5f5; height: 50vh; flex-direction: column; padding: 3rem; } ` ] }) export class ContainerLayoutComponent { } 執行的結果：\n在 standalone component 如何使用外部模組 接著來看看如何在 standalone 元件中使用外部模組的功能。\n在 standalone component 中使用 ReactiveFormModule 新增一個 register standalone 元件，並在此元件中使用 angular 的 Reactive Form Module，用它來實作一個 可進行註冊的表單程式。\n$ npx ng g c components/register --standalone --inline-style --inline-template --flat 在 register.component.ts 中使用 FormGroup, FormControl 來宣告一個有 name 及 email 的註冊表單。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  import { Component } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { FormControl, FormGroup, ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;;  @Component({ selector: \u0026#39;app-register\u0026#39;, standalone: true, imports: [CommonModule, ReactiveFormsModule], template: ` \u0026lt;form [formGroup]=\u0026#34;registerForm\u0026#34; (ngSubmit)=\u0026#34;sendForm()\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;first-name\u0026#34;\u0026gt;Name: \u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;first-name\u0026#34; type=\u0026#34;text\u0026#34; formControlName=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;email\u0026#34; type=\u0026#34;email\u0026#34; formControlName=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Send\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; `, styles: [` :host { flex: 1; padding: 4rem; display:flex; align-items: center; background: #fff; } form { display: flex; flex-direction: column; } input { margin-bottom: 1rem; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; min-width: 300px; } label { margin-bottom: 0.5rem; } button { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; background: #fff; cursor: pointer; width: 140px } button:active { background: #efe; } button:hover { background: #88aae1 } ` ] } export class RegisterComponent { registerForm = new FormGroup({ name: new FormControl(\u0026#39;\u0026#39;), email: new FormControl(\u0026#39;\u0026#39;), }); sendForm() { console.log(this.registerForm.valid); } }   在 standalone component 中使用 RouterModule 新增一個名為 navigation 的 standalone 元件，並在此元件中使用 RouterModule，用它來實作如何 瀏覽各個系統功能頁面。\n$ npx ng g c components/navigation --standalone --inline-style --inline-template --flat 在 navigation.component.ts 中使用 router 相關功能來切換各個功能頁面（有 Home、Other Domain、About等）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  import { Component } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { RouterModule } from \u0026#39;@angular/router\u0026#39;;  @Component({ selector: \u0026#39;app-navigation\u0026#39;, standalone: true, imports: [CommonModule, RouterModule],  template: ` \u0026lt;ul class=\u0026#34;navigation\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a routerLink=\u0026#34;/home\u0026#34; routerLinkActive=\u0026#34;active\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a routerLink=\u0026#34;/domains\u0026#34; routerLinkActive=\u0026#34;active\u0026#34;\u0026gt;Others Domains\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a routerLink=\u0026#34;/about\u0026#34; routerLinkActive=\u0026#34;active\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; `,  styles: [` ul.navigation { } li { display: inline; margin: 0 10px; } li:hover { margin: 0 10px; cursor: pointer; } .active { font-weight: bold; } `] }) export class NavigationComponent { }   將各子元件組合至 ContainerLayoutComponent 中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import { Component } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { LogoComponent } from \u0026#39;./logo.component\u0026#39;; import { NavigationComponent } from \u0026#39;./navigation.component\u0026#39;;  @Component({ selector: \u0026#39;app-container-layout\u0026#39;, standalone: true, imports: [CommonModule, LogoComponent, NavigationComponent], template: ` \u0026lt;app-logo\u0026gt;\u0026lt;/app-logo\u0026gt; \u0026lt;app-navigation\u0026gt;\u0026lt;/app-navigation\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;ng-content\u0026gt;\u0026lt;/ng-content\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;footer\u0026gt;2023\u0026lt;/footer\u0026gt; `, styles: [` .container { display: flex; background-color: #f5f5f5; height: 20vh; flex-direction: column; padding: 3rem; } ` ] }) export class ContainerLayoutComponent { }   程式至此，執行結果如下：\n建立子頁面（功能） 在前述的 NavigationComponent 中我們已經預先設好三個 routerLink 分別要去載入 Home、Other Domain、About等三個子功能（頁面），所以接下來使用 angular cli 來新增這三個子功能。\n$ npx ng g c pages/home --standalone --inline-style --inline-template --flat $ npx ng g c pages/domain --standalone --inline-style --inline-template --flat $ npx ng g c pages/about --standalone --inline-style --inline-template --flat 分別在這三個功能置入一些內容：\nabout component    other domain component 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // domain.conponent.ts import { Component } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; @Component({ selector: \u0026#39;app-domain\u0026#39;, standalone: true, imports: [CommonModule], template: ` \u0026lt;h2\u0026gt;Other domains\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;www.aprendetesting.com\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;www.aprende-singlespa.com\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; `, styles: [ ] }) export class DomainComponent { }   home component 在 HomeComponent 中我們要展現如何使用子元件 - RegisterCompoent，因此記得在 imports 中匯入 RegisterCompoent。並在 template 中使用它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // home.component.ts import { Component } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { RegisterComponent } from \u0026#39;../components/register.component\u0026#39;; @Component({ selector: \u0026#39;app-home\u0026#39;, standalone: true, imports: [CommonModule, RegisterComponent], template: ` \u0026lt;div class=\u0026#34;sections\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;welcome\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Yes, {{domainName}} available for sale\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;For instantly purchase. please make a paypal request\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;Buy now for {{price | currency}}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;app-register\u0026gt;\u0026lt;/app-register\u0026gt; \u0026lt;/div\u0026gt; `, styles: [ ] }) export class HomeComponent { domainName = \u0026#34;www.aprendetypescript.com\u0026#34;; price = 100; }   完成路由設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { AboutComponent } from \u0026#39;./pages/about.component\u0026#39;; import { DomainComponent } from \u0026#39;./pages/domain.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home.component\u0026#39;; const routes: Routes = [ { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;home\u0026#39;, component: HomeComponent, }, { path: \u0026#39;domains\u0026#39;, component: DomainComponent }, { path: \u0026#39;about\u0026#39;, component: AboutComponent } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   最後在 app.component.html 中加回 router-outlet，好讓 App 有一個可以呈現功能的地方。\n\u0026lt;!-- app.component.html --\u0026gt; \u0026lt;app-container-layout\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; \u0026lt;/app-container-layout\u0026gt; 查看完成後的結果 在 Home Page 中可以看到 standalone compoent 再嵌入 standalone 子元件的效果\n延遲載入 Standalone component (lazy load Standalone component) 筆記至此，我們已看到了 Standalone 的各式使用情境。接下來再來看看如何延遲載入 Standalone component。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // app-routingmmodule.ts // ... const routes: Routes = [ { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;home\u0026#39;, // component: HomeComponent,  loadComponent: () =\u0026gt; import(\u0026#39;./pages/home.component\u0026#39;).then(m =\u0026gt; m.HomeComponent)  }, { path: \u0026#39;domains\u0026#39;, // component: DomainComponent  loadComponent: () =\u0026gt; import(\u0026#39;./pages/domain.component\u0026#39;).then(m =\u0026gt; m.DomainComponent)  }, { path: \u0026#39;about\u0026#39;, // component: AboutComponent  loadComponent: () =\u0026gt; import(\u0026#39;./pages/about.component\u0026#39;).then(m =\u0026gt; m.AboutComponent)  } ]; // ...   使用 Standalone 元件來啟動程式 如何不再需要 ngModule，直接使用 Standalone 元件來啟動程式呢?\n刪除 app.module.ts \u0026amp; app-routing.module.ts 兩個 @NgModule 在移除 AppModule(app.module.ts) 之前先來看看其中的程式碼：\n 在程式第4和第14行匯入了路由的相關設定 (這部份的程式將會移入到 main.ts 中) 在程式第5和第10及第18行匯入了 AppComponent 及 設定 AppComponent 為程式啟動的元件 (這部份的程式也將會一併移入到 main.ts 中) 在程式第6行匯入了 AppComponent 內會使用到的子元件 ContainerLayoutComponent (這部份的程式將被實現在 AppComponent 中)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { ContainerLayoutComponent } from \u0026#39;./components/container-layout.component\u0026#39;;  @NgModule({ declarations: [ AppComponent  ], imports: [ BrowserModule, AppRoutingModule, ContainerLayoutComponent  ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }   而在 AppRoutingModule 中的 routes 設定也會一併由 main.ts 的修改程式碼來取代\n修改 app.component.ts 將 AppComponent 修改內容有：\n 程式第7行：加入 standalone: true 將 AppComponent 變成是一個 Standalone component 程式第3和8行：匯入 ComtainerLayoutComponent 子元件 程式第8行：匯入 RouterModule 模組是因為 AppComponent template中使用到了  這個 Directive  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import { Component } from \u0026#39;@angular/core\u0026#39;; import { RouterModule } from \u0026#39;@angular/router\u0026#39;; import { ContainerLayoutComponent } from \u0026#39;./components/container-layout.component\u0026#39;;  @Component({ selector: \u0026#39;app-root\u0026#39;, standalone: true, imports: [RouterModule, ContainerLayoutComponent],  templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent { title = \u0026#39;standAloneComponent\u0026#39;; }   修改 main.ts 移除 Import platformBrowserDynamic 的指令\nimport { AppModule } from \u0026#39;./app/app.module\u0026#39;; import { platformBrowserDynamic } from \u0026#39;@angular/platform-browser-dynamic\u0026#39;; 移除 platformBrowserDynamic().bootstrapModule 指令\nplatformBrowserDynamic().bootstrapModule(AppModule) .catch(err =\u0026gt; console.error(err)); 新加入的程式碼除了新的 bootstrap 方式，就是 routes 的相關設定：\n 程式的第1、3、5行：採取由 AppComponent 來啟動程式。 程式第2行及第6行之後就是有關 routes 的設定（也就是原有的 AppRoutingModule @NgMoudle 的功能）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import { bootstrapApplication } from \u0026#34;@angular/platform-browser\u0026#34;; import { provideRouter } from \u0026#34;@angular/router\u0026#34;; import { AppComponent } from \u0026#34;./app/app.component\u0026#34;; bootstrapApplication(AppComponent, { providers:[ provideRouter([ { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39; }, { path: \u0026#39;home\u0026#39;, loadComponent: () =\u0026gt; import(\u0026#39;./app/pages/home.component\u0026#39;).then(m =\u0026gt; m.HomeComponent) }, { path: \u0026#39;domains\u0026#39;, loadComponent: () =\u0026gt; import(\u0026#39;./app/pages/domain.component\u0026#39;).then(m =\u0026gt; m.DomainComponent) }, { path: \u0026#39;about\u0026#39;, loadComponent: () =\u0026gt; import(\u0026#39;./app/pages/about.component\u0026#39;).then(m =\u0026gt; m.AboutComponent) } ]) ] }).catch(err =\u0026gt; console.error(err));   以上調整完成後，就可以安心的把 AppModule ＆ AppRoutingModule 這倆支 @NgModule 程式給移除掉。也就是說到此刻，你的應用程式已是一個 Module-Less Application了。\n","permalink":"https://calvinegs.github.io/posts/angular-standlone-component/","summary":"github Source code\n如何在 Angular 中使用 Standalone Components 本篇將要紀錄如何使 Angular 15 環境中使用 Standlone component。從版本 14 起就開始支援 Standalone component，Angular 15則正式的引入了獨立組件作為構建無模塊應用程序的簡單方法。獨立組件的好處之一是它們使新開發人員更容易學習和使用 Angular，因為它們可以不用使用到 NgModule。\nAngular 從第二個版本起，@NgModule就已是一個重要的核必功能，透過 @NgModule 為一個個單位來組織我們的應用程式，包含整個應用程式的啟動，所以每個 angular 應用程式都至少要有一個模組（也稱為根模組），由此可見它的重要性。說它是 Angular 的特色之一一點也不為過。但近年來這個特色功能卻也成為其他類似架構的攻擊目標，為了使系統支援更多樣化，Angular 15 正式引入了 Standalone 的各式運用。\n在本篇筆記中會提及如何建立及使用一個 Standalone component、如何在一個 Standalone component中去使用另一個 Standalone 子元件、如何在原有模式中(有 @NgModule)中載入 Standalone component，到最後如何在一個專案中完全不使用到 @NgModule 功能。\n建立新專案 透過 npm init @angular 語法來建立一個 angular project。\n$ npm init @angular standAloneComponent -- --routing --style=scss \u0026amp;\u0026amp; cd standaloneComponent 建立 Standalone Component $ npx ng g c components/containerLayout --standalone --inline-style --inline-template --flat 在由 cli 産生的程式碼架構中(container-layout.","title":"How to using Angular Standalone Component"},{"content":"github Source code\n本文將記錄如何一步步從無到有，使用 Dotnet Core 7.0 建立 ASP.NET Core Web API，其中將會使用到下列技術:\n Dotnet CLI Entity Framework 7.0 Json Web Token PostgreSQL DB (Docker Version) ASP.NET Core Generator  專案完成後的檔案結構 ./專案目錄 ├── .config/ │ └── dotnet-tools.json ├── .vscode/ │ ├── launch.js │ └── tasks.json ├── Controller/ │ ├── AuthenticateController.cs │ ├── TodoController.cs │ └── WeatherForecast.cs ├── Data/ │ └── ApiDbContext.cs ├── Migrations/ ├── Models/ │ ├── AuthenticateData.cs │ └── TodoList.cs ├── obj/ ├── Properties/ │ └── launchSettings.json ├── .gitignore ├── appsettings.Development.json ├── appsettings.json ├── dotnet7-webapi-jwt.csproj ├── global.json ├── Program.cs ├── README.md └── WeatherForecast.cs 專案完成後所提供的 API 端點    Methods Urls Actions     POST /api/Authenticate/login 註冊新使用者帳號   POST /api/Authenticate/register 使用者帳號登入   POST /api/Authenticate/register-admin 管理者帳號登入   GET /api/Todos get all Todos   POST /api/Todos add New Todo   GET /api/Todos/:id get Todo by id   PUT /api/Todos/:id update Todo by id   DELETE /api/Todos/:id remove Todo by id    建置新專案 dotnet 版本管理檢查 你的 Local 可能已安裝了多個版本的 dotnet 環境，使用以下指令來檢查目前的 dotnet 版本\n$ dotnet --version # 顯示目前所使用的版本 7.0.201 # 預設是最新的版本 使用 dotnet cli 建立新專案 $ dotnet new webapi -o dotnet7-webapi-jwt 歡迎使用 .NET 7.0! --------------------- SDK 版本: 7.0.201 遙測 --------- .NET 工具會收集使用資料，協助我們改進您的體驗。資料會由 Microsoft 收集，並分享給社群使用。您可以選擇退出遙測，只要使用您慣用的殼層，將 DOTNET_CLI_TELEMETRY_OPTOUT 環境變數設定為 \u0026#39;1\u0026#39; 或 \u0026#39;true\u0026#39; 即可。 閱讀更多有關 .NET CLI 工具遙測的內容: https://aka.ms/dotnet-cli-telemetry ---------------- 已安裝 ASP.NET Core HTTPS 開發憑證。 若要信任憑證，請執行 \u0026#39;dotnet dev-certs https --trust\u0026#39; (僅限 Windows 與 macOS )。 深入了解 HTTPS: https://aka.ms/dotnet-https ---------------- 撰寫第一個應用程式: https://aka.ms/dotnet-hello-world 了解全新功能: https://aka.ms/dotnet-whats-new 探索文件: https://aka.ms/dotnet-docs 於 GitHub 回報問題和尋找來源: https://github.com/dotnet/core Use \u0026#39;dotnet --help\u0026#39; 查看可用的命令或瀏覽: https://aka.ms/dotnet-cli -------------------------------------------------------------------------------------- 範本「ASP.NET Core Web API」已成功建立。 正在處理建立後的動作... 正在還原 /home/egs/cal-data/Sources/nhis/dotnet7-webapi-jwt/dotnet7-webapi-jwt.csproj: 正在判斷要還原的專案... 已還原 /home/egs/cal-data/Sources/nhis/dotnet7-webapi-jwt/dotnet7-webapi-jwt.csproj (4.93 sec 內)。 還原成功。 新專案\n$ cd dotnet7-webapi-jwt $ ls -al 總用量 40 drwxrwxr-x 5 egs egs 4096 3月 6 10:23 . drwxrwxr-x 5 egs egs 4096 3月 6 10:22 .. -rw-rw-r-- 1 egs egs 127 3月 6 10:22 appsettings.Development.json -rw-rw-r-- 1 egs egs 151 3月 6 10:22 appsettings.json drwxrwxr-x 2 egs egs 4096 3月 6 10:22 Controllers -rw-rw-r-- 1 egs egs 463 3月 6 10:22 dotnet7-webapi-jwt.csproj drwxrwxr-x 2 egs egs 4096 3月 6 10:23 obj -rw-rw-r-- 1 egs egs 557 3月 6 10:22 Program.cs drwxrwxr-x 2 egs egs 4096 3月 6 10:22 Properties -rw-rw-r-- 1 egs egs 267 3月 6 10:22 WeatherForecast.cs dotnet 版本管理 $ dotnet --list-sdks # 顯示已安裝的 sdk 版本資訊 5.0.408 [/usr/share/dotnet/sdk] 6.0.406 [/usr/share/dotnet/sdk] 7.0.201 [/usr/share/dotnet/sdk] $ dotnet --list-runtimes Microsoft.AspNetCore.App 5.0.17 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.14 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.3 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.NETCore.App 5.0.17 [/usr/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.14 [/usr/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.3 [/usr/share/dotnet/shared/Microsoft.NET# .App] 由於 dotnet 版本演化滿快的，所以會建議在專案目錄中要指定使用 SDK 的版本，以免當你又安裝了更新的版本（如8.0）後程式執行出問題。\n$ dotnet new globaljson --sdk-version 7.0.201 範本「global.json 檔案」已成功建立。 $ cat global.json { \u0026#34;sdk\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;7.0.201\u0026#34; } } 版本控管 使用 dotnet cli 來產生預設的 git ignore 檔案\n$ dotnet new gitignore 建立 git 初始版本\n$ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝本機工具 此方式安裝的工具，僅限本機存取(只針對目前的目錄和子目錄)， 首先透過 dotnet new tool-manifest 命令來產生工具資訊清單檔，再使用 dotnet tool install 來安裝各式工具程式。這樣的方式好處是在專案若多人協助方式時，則可利用 dotnet tool restore 命令將紀錄在 ./.config/dotnet-tools.json 的工具資訊清單檔重建在不同協助人員的電腦中。\n$ dotnet new tool-manifest #會產生 .config/dotnet-tools.json 檔案 $ dotnet tool install --local dotnet-ef #使用 local 安裝方式來安裝 Entity Framework 工具 您可使用下列命令，從此目錄叫用工具: \u0026#39;dotnet tool run dotnet-ef\u0026#39; 或 \u0026#39;dotnet dotnet-ef\u0026#39;。 已成功安裝工具 \u0026#39;dotnet-ef\u0026#39; (版本 \u0026#39;7.0.3\u0026#39;)。項目已新增至資訊清單檔 /home/egs/cal-data/Sources/nhis/dotnet7-webapi-jwt/.config/dotnet-tools.json。 $ dotnet tool install --local dotnet-aspnet-codegenerator #使用 local 安裝方式來安裝 Code Generator 工具 您可使用下列命令，從此目錄叫用工具: \u0026#39;dotnet tool run dotnet-aspnet-codegenerator\u0026#39; 或 \u0026#39;dotnet dotnet-aspnet-codegenerator\u0026#39;。 已成功安裝工具 \u0026#39;dotnet-aspnet-codegenerator\u0026#39; (版本 \u0026#39;7.0.4\u0026#39;)。項目已新增至資訊清單檔 /home/egs/cal-data/Sources/nhis/dotnet7-webapi-jwt/.config/dotnet-tools.json。 $ cat ./.config/dotnet-tools.json { \u0026#34;version\u0026#34;: 1, \u0026#34;isRoot\u0026#34;: true, \u0026#34;tools\u0026#34;: { \u0026#34;dotnet-ef\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;7.0.3\u0026#34;, \u0026#34;commands\u0026#34;: [ \u0026#34;dotnet-ef\u0026#34; ] }, \u0026#34;dotnet-aspnet-codegenerator\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;7.0.4\u0026#34;, \u0026#34;commands\u0026#34;: [ \u0026#34;dotnet-aspnet-codegenerator\u0026#34; ] } } } 安裝程式使用的相關套件 $ dotnet add package Microsoft.EntityFrameworkCore.Tools #使用 dotnet Entity Framework 時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.Design #使用 dotnet Entity Framework 時必須安裝此套件 $ dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore #使用 Identity Framework 時必須安裝此套件 $ dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL #使用 PostgreSQL DB 當後端資料庫須安裝此套件 $ dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer #要使用 Token Base 權限管理須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.SqlServer #使用 dotnet aspnet-codegenerator 時必須安裝此套件  $ dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design #搭配 dotnet-aspnet-codegenerator 使用 $ dotnet add package System.Configuration.ConfigurationManager #搭配 dotnet-aspnet-codegenerator 使用 安裝的程式套件資訊紀錄在 \u0026ldquo;專案\u0026rdquo;.csproj 檔案中\n$ cat dotnet7-webapi-jwt.csproj #查看 安裝套件的相關設定值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net7.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;RootNamespace\u0026gt;dotnet7_webapi_jwt\u0026lt;/RootNamespace\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; Version=\u0026#34;7.0.3\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Identity.entityframeworkCore\u0026#34; Version=\u0026#34;7.0.3\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.OpenApi\u0026#34; Version=\u0026#34;7.0.3\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Design\u0026#34; Version=\u0026#34;7.0.3\u0026#34;\u0026gt;  \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.SqlServer\u0026#34; Version=\u0026#34;7.0.3\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;7.0.3\u0026#34;\u0026gt;  \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.codeGeneration.Design\u0026#34; Version=\u0026#34;7.0.4\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Npgsql.entityFrameworkCore.PostgreSQL\u0026#34; Version=\u0026#34;7.0.3\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;6.4.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;system.Configuration.ConfigurationManager\u0026#34; Version=\u0026#34;7.0.0\u0026#34; /\u0026gt;  \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;   建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add EFCore NuGet packages\u0026#34; 執行程式 $ dotnet watch 打開 VS Code\n$ code . 目前産生的程式架構\n設置使用 Entity Framework相關設定 新增 database context (自動產生) 使用 dotnet ef 工具在專案目錄 ./Data 子目錄下新建立一個 ApiDbContext.cs 的 DB Context file\n註：在使用前先把 後端資料庫 環境備妥，安裝 PostGreSQL DB 可參考此篇筆紀　使用 Docker 執行 PostgresSQL \n$ dotnet ef dbcontext scaffold \u0026#34;User ID =docker;Password=docker;Server=localhost;Port=5432;Database=pg_testdb; Integrated Security=true;Pooling=true\u0026#34; Npgsql.entityFrameworkCore.PostgreSQL -c ApiDbContext -o Data Build started... Build succeeded. To protect potentially sensitive information in your connection string, you should move it out of source code. You can avoid scaffolding the connection string by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148. For more guidance on storing connection strings, see http://go.microsoft.com/fwlink/?LinkId=723263. using System; using System.Collections.Generic; using Microsoft.EntityFrameworkCore; namespace dotnet7_webapi_jwt.Data; public partial class ApiDbContext : DbContext { public ApiDbContext() { } public ApiDbContext(DbContextOptions\u0026lt;ApiDbContext\u0026gt; options) : base(options) { } // protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)  // =\u0026gt; optionsBuilder.UseNpgsql(\u0026#34;User ID =docker;Password=docker;Server=localhost;Port=5432;Database=pg_testdb; Integrated Security=true;Pooling=true\u0026#34;);  protected override void OnModelCreating(ModelBuilder modelBuilder) { OnModelCreatingPartial(modelBuilder); } partial void OnModelCreatingPartial(ModelBuilder modelBuilder); } 在 appsettings.json 檔案中加入 Connection String\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;User ID =docker;Password=docker;Server=localhost;Port=5432;Database=pg_testdb; Integrated Security=true;Pooling=true\u0026#34; } } 使用 Asp.Net Core Identity framework 來管理使用者使用權限 ASP.NET Core Identity:\n 支援使用者介面 (UI) 登入功能的 API。 管理使用者、密碼、設定檔資料、角色、宣告、權杖、電子郵件確認等。  ASP.Net Core Identity Framework 是一個方便且還完善的使用權限管理架構。\n將相關 Asp.Net Core Identity framework 功能注入到 container 中 除了安裝相關套件外，還要調整相關程式:\n 在 Program.cs 檔案中將加入以下程式碼 (before services.AddControllers())  ConfigurationManager _configuration = builder.Configuration; // Add services to the container. builder.Services.AddDbContext\u0026lt;ApiDbContext\u0026gt;( options =\u0026gt; options.UseSqlServer( _configuration.GetConnectionString(\u0026#34;ConnStr\u0026#34;) ) ); builder.Services.AddIdentity\u0026lt;IdentityUser, IdentityRole\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApiDbContext\u0026gt;() .AddDefaultTokenProviders();  使用 AspNetCore Identity，則 DataContext (ApiDbContext.cs 中) 必須要繼承 IdentityDbContext， 同時 Model creationg 時要改成呼叫 base.OnModelCreation  1 2 3 4 5 6 7 8 9 10 11 12 13 14  public partial class ApiDbContext : IdentityDbContext\u0026lt;IdentityUser\u0026gt; { public ApiDbContext() { } // ...  protected override void OnModelCreating(ModelBuilder modelBuilder) { // OnModelCreatingPartial(modelBuilder);  base.OnModelCreating(modelBuilder);  } }   新增一個 entity framework 遷移 並 更新資料庫 完成上述程式調整後，來執行資料庫遷移(migrations)\n$ dotnet ef migrations add \u0026#34;Add Identity Framework\u0026#34; Build started... Build succeeded. Done. To undo this action, use \u0026#39;ef migrations remove\u0026#39; $ dotnet ef database update 在　dotnet ef migrations add \u0026ldquo;Add Identity Framework\u0026rdquo; 指令完成後，可以在專案目錄下發生産生新的子目錄 Migrations，並有三個新檔案\n在 dotnet ef database update 指令完成後，PostgreSQL pg_testdb 資料庫中產生 Identity Framework 會使用到的資料表\n建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;新增一個 entity framework 遷移 並 更新資料庫\u0026#34; 使用 Jason Web Token 在 appsettings.json 中自定JWT實作會使用到的設定值 { // ...  \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;User ID =docker;Password=docker;Server=localhost;Port=5432;Database=pg_testdb; Integrated Security=true;Pooling=true\u0026#34; }, \u0026#34;JwtSettings\u0026#34;: { \u0026#34;ValidIssuer\u0026#34;: \u0026#34;Dotnet7WebApiDemo\u0026#34;, \u0026#34;ValidAudience\u0026#34;: \u0026#34;Dotnet7WebApiDemo\u0026#34;, \u0026#34;Secret\u0026#34;: \u0026#34;Dotnet7 WebApi Demo. Using Json Web Token Technology to keep user info.\u0026#34; } } 新增 使用者註冊和登入時使用的 Data model class (Models/AuthenticateData.cs) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  using System.ComponentModel.DataAnnotations; namespace dotnet7_webapi_jwt.Models; public class Response { public string? Status { get; set; } public string? Message { get; set; } } public class LoginModel { [EmailAddress] [Required(ErrorMessage = \u0026#34;Eamil Address is required\u0026#34;)] public string? Email { get; set; } [Required(ErrorMessage = \u0026#34;Password is required\u0026#34;)] public string? Password { get; set; } } public class RegisterModel { [Required(ErrorMessage = \u0026#34;User Name is required\u0026#34;)] public string? Username { get; set; } [EmailAddress] [Required(ErrorMessage = \u0026#34;Email Address is required\u0026#34;)] public string? Email { get; set; } [Required(ErrorMessage = \u0026#34;Password is required\u0026#34;)] public string? Password { get; set; } } public static class UserRoles { public const string Admin = \u0026#34;Admin\u0026#34;; public const string User = \u0026#34;User\u0026#34;; }   新增 註冊和登入邏輯 (Controllers/AuthenticateControll.cs) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139  using System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using System.Text; using dotnet7_webapi_jwt.Models; using Microsoft.AspNetCore.Identity; using Microsoft.AspNetCore.Mvc; using Microsoft.IdentityModel.Tokens; namespace dotnet7_webapi_jwt.Controllers; [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class AuthenticateController : ControllerBase { private readonly UserManager\u0026lt;IdentityUser\u0026gt; _userManager; private readonly RoleManager\u0026lt;IdentityRole\u0026gt; _roleManager; private readonly IConfiguration _configuration; public AuthenticateController( UserManager\u0026lt;IdentityUser\u0026gt; userManager, RoleManager\u0026lt;IdentityRole\u0026gt; roleManager, IConfiguration configuration) { _userManager = userManager; _roleManager = roleManager; _configuration = configuration; } [HttpPost] [Route(\u0026#34;login\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Login([FromBody] LoginModel userModel) { var user = await _userManager.FindByEmailAsync(userModel.Email); if (user != null \u0026amp;\u0026amp; await _userManager.CheckPasswordAsync(user, userModel.Password)) { var userRoles = await _userManager.GetRolesAsync(user); var claims = new List\u0026lt;Claim\u0026gt; { new Claim(ClaimTypes.Name, user.UserName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()), }; foreach (var userRole in userRoles) { claims.Add(new Claim(ClaimTypes.Role, userRole)); } var token = CreateToken(claims); return Ok(new { token = new JwtSecurityTokenHandler().WriteToken(token), expiration = token.ValidTo }); } return Unauthorized(); } [HttpPost] [Route(\u0026#34;register\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Register([FromBody] RegisterModel model) { var userExists = await _userManager.FindByEmailAsync(model.Email); if (userExists != null) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User already exists!\u0026#34; }); IdentityUser user = new() { Email = model.Email, SecurityStamp = Guid.NewGuid().ToString(), UserName = model.Username }; var result = await _userManager.CreateAsync(user, model.Password); if (!result.Succeeded) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User creation failed! Please check user details and try again.\u0026#34; }); return Ok(new Response { Status = \u0026#34;Success\u0026#34;, Message = \u0026#34;User created successfully!\u0026#34; }); } [HttpPost] [Route(\u0026#34;register-admin\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; RegisterAdmin([FromBody] RegisterModel model) { var userExists = await _userManager.FindByEmailAsync(model.Email); if (userExists != null) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User already exists!\u0026#34; }); IdentityUser user = new() { Email = model.Email, SecurityStamp = Guid.NewGuid().ToString(), UserName = model.Username }; var result = await _userManager.CreateAsync(user, model.Password); if (!result.Succeeded) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User creation failed! Please check user details and try again.\u0026#34; }); if (!await _roleManager.RoleExistsAsync(UserRoles.Admin)) await _roleManager.CreateAsync(new IdentityRole(UserRoles.Admin)); if (!await _roleManager.RoleExistsAsync(UserRoles.User)) await _roleManager.CreateAsync(new IdentityRole(UserRoles.User)); if (await _roleManager.RoleExistsAsync(UserRoles.Admin)) { await _userManager.AddToRoleAsync(user, UserRoles.Admin); } if (await _roleManager.RoleExistsAsync(UserRoles.Admin)) { await _userManager.AddToRoleAsync(user, UserRoles.User); } return Ok(new Response { Status = \u0026#34;Success\u0026#34;, Message = \u0026#34;User created successfully!\u0026#34; }); } private JwtSecurityToken CreateToken(List\u0026lt;Claim\u0026gt; claims) { var secretkey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes( _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;))); // _configuration.GetSection(\u0026#34;JwtSettings:Secret\u0026#34;).Value)  var credentials = new SigningCredentials(secretkey, SecurityAlgorithms.HmacSha512Signature); var token = new JwtSecurityToken( // 亦可使用　SecurityTokenDescriptor　來産生 Token  issuer: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidIssuer\u0026#34;), audience: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidAudience\u0026#34;), expires: DateTime.Now.AddDays(1), claims: claims, signingCredentials: credentials); return token; } }   有關實作 JWT 的流程 透過 JWT 的實作可以讓你的專案實現 Token-base 的身份驗證與授權。 （Json Web Token) 實作的過程大致可以分成三個部分:\n 在登入成功後産生合法的 JWT Token 每次收到 request 時驗證是否為合法有效的 JWT Token 在特定 API Endpoint 上驗證是否帶有 “合法有效的 JWT Token”，以達到權限管理的需求  産生合法的 Jason Web Token 在上述 AuthenticateController.cs 程式中，我們建立一個 CreateToken() 的 function，並在登入檢核成功時産生一個 token 回傳。\n設置驗證是否為合法有效的 JWT Token 第一步，透過 DI 將 JWT 相關設定設置好，在 Programe.cs 檔案中的 ”builder.Services.AddControllers();“ 程式碼之前加入以下有關使用 JWT 使用者授權驗證的程式邏輯：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; }) .AddJwtBearer(options =\u0026gt; { // 當驗證失敗時，回應標頭會包含 WWW-Authenticate 標頭，這裡會顯示失敗的詳細錯誤原因  options.IncludeErrorDetails = true; // 預設值為 true，有時會特別關閉  options.TokenValidationParameters = new TokenValidationParameters { // 透過這項宣告，就可以從 \u0026#34;NAME\u0026#34; 取值  NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, // 透過這項宣告，就可以從 \u0026#34;Role\u0026#34; 取值，並可讓 [Authorize] 判斷角色  RoleClaimType = \u0026#34;http://schemas.microsoft.com/ws/2008/06/identity/claims/role\u0026#34;, // 驗證 Issuer (一般都會)  ValidateIssuer = true, ValidIssuer = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidIssuer\u0026#34;), // 驗證 Audience (通常不太需要)  ValidateAudience = false, //ValidAudience = = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidAudience\u0026#34;),  // 驗證 Token 的有效期間 (一般都會)  ValidateLifetime = true, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已  ValidateIssuerSigningKey = false, // 應該從 IConfiguration 取得  IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)) }; });   同時宣告一個 Secret 變數，並由 appsettings.json 系統配置檔中讀出 Jwt Secret 的設定。\n1 2 3 4  // ... ConfigurationManager _configuration = builder.Configuration; var secret = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;); // ...   第二步，要啟動 request pipeline 中的 Middleware (UseAuthentication \u0026amp; UseAuthorization 都需要)\n1 2 3 4  // ... app.UseAuthentication(); app.UseAuthorization(); // ...   在特定 API EndPoint 上驗證是否帶有合法有效的 JWT Token 在 WeatherForecastController.cs Get() function 上加入 “[Authorize]” 即可\n1 2 3 4 5 6 7 8 9 10 11 12  [Authorize] [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); }   使用 OpenApi Swagger 來測試 API 如上程式加入[Authorize]後，以dotnet watch執行程式，進入 OpenApi Swagger 網頁瀏覽 weatherforecast endpoint，會回傳 Status: 401 Unauthorized 的錯誤訊息。\n在 OpenApi Swagger 網頁點選 register endpoint 來註冊一個新使用者\n輸入註冊資料，執行送出，畫面顯示成功！\n可查看資料庫結果，已在 AspNetUsers Table 中新建立一筆使用者資料：\nOpenApi Swagger 來測試 API 時, Swagger 測試網頁預設是沒有設定 Token 的功能,必須將程式碼中的 “builder.Services.AddSwaggerGen();”改成以下內容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  builder.Services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;JwtDemo\u0026#34;, Version = \u0026#34;v1\u0026#34; }); c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { In = ParameterLocation.Header, Description = \u0026#34;Please enter JWT with Bearer into field\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, Type = SecuritySchemeType.ApiKey }); c.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} }, new string[] {} } }); });   有了上述的程式設定，當再次 dotnet watch 啟動程式後，瀏覽器呈現的 Swagger 畫面右上角會多出了｀Authorize｀ 的按鈕。按下按鈕就是讓你填入登入成功後回傳的 Token\n使用合法（已完成註冊）使用者帳號／密碼來登入：\n登入成功後回傳的 response 中會包含 token：\n在 \u0026ldquo;Value:\u0026rdquo;\u0026quot; 文字框內填入 \u0026ldquo;Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTUxMiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZ\u0026hellip;..\u0026quot;，再按下 Authorize 按鈕即表下在接下來的 Request 中都會自動帶入 Token 傳給 WebApi Server。 （請注意 Bearer後再先接著一個空白字元再加上 Token值）\n再次執行　\u0026ldquo;WeatherForecast\u0026rdquo; 的測試(Execute)　就可正常的取得回傳值了\n加入 git 版本控制 $ git commit -m \u0026#34;finished JWT function\u0026#34; -a 使用　aspnet-codegenerator　工具來自動産生程式碼 最後我們來看看如何使用工具來自動産生程式去維護一個新的資料表\n在 Models 目錄下新增一個 model(模型) class - ItemData 使用 dotnet cli 來新增一個 class\n$ dotnet new class -o Models -n TodoList 産生出來的空的程式框架：\n將 Models/ItemData.cs 補齊欄位設定\n1 2 3 4 5 6 7 8  namespace dotnet7_webapi_jwt.Models; public class TodoList { public int Id { get; set; } public string? Title { get; set; } public string? Details { get; set; } public bool Done { get; set; } }   在 ApiDbContext.cs 中宣告一個 TodoList table public DbSet\u0026lt;TodoList\u0026gt;? TodoList { get; set; } #放在程式最後面 新增一個遷移與更新資料庫 $ dotnet build $ dotnet ef migrations add \u0026#34;Add New Table - TodoList\u0026#34; $ dotnet ef database update 註：｀$ dotnet ef migrations remove｀ 可移除最後一個 migration\n使用 ASPNET Codegenerator 自動產生 Todo Controller $ dotnet aspnet-codegenerator controller -name TodoController -async -api -m TodoList -dc ApiDbContext -outDir Controllers Building project ... Finding the generator \u0026#39;controller\u0026#39;... Running the generator \u0026#39;controller\u0026#39;... Minimal hosting scenario! Attempting to compile the application in memory. Attempting to figure out the EntityFramework metadata for the model and DbContext: \u0026#39;TodoList\u0026#39; Using database provider \u0026#39;Npgsql.EntityFrameworkCore.PostgreSQL\u0026#39;! Added Controller : \u0026#39;/Controllers/TodoController.cs\u0026#39;. RunTime 00:00:08.68 TodoController.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; using Microsoft.EntityFrameworkCore; using dotnet7_webapi_jwt.Data; using dotnet7_webapi_jwt.Models; namespace dotnet7_webapi_jwt.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class TodoController : ControllerBase { private readonly ApiDbContext _context; public TodoController(ApiDbContext context) { _context = context; } // GET: api/Todo [HttpGet] public async Task\u0026lt;ActionResult\u0026lt;IEnumerable\u0026lt;ItemData\u0026gt;\u0026gt;\u0026gt; GetItemData() { if (_context.ItemData == null) { return NotFound(); } return await _context.ItemData.ToListAsync(); } // GET: api/Todo/5 [HttpGet(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;ItemData\u0026gt;\u0026gt; GetItemData(int id) { if (_context.ItemData == null) { return NotFound(); } var itemData = await _context.ItemData.FindAsync(id); if (itemData == null) { return NotFound(); } return itemData; } // PUT: api/Todo/5  // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754 [HttpPut(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; PutItemData(int id, ItemData itemData) { if (id != itemData.Id) { return BadRequest(); } _context.Entry(itemData).State = EntityState.Modified; try { await _context.SaveChangesAsync(); } catch (DbUpdateConcurrencyException) { if (!ItemDataExists(id)) { return NotFound(); } else { throw; } } return NoContent(); } // POST: api/Todo  // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754 [HttpPost] public async Task\u0026lt;ActionResult\u0026lt;ItemData\u0026gt;\u0026gt; PostItemData(ItemData itemData) { if (_context.ItemData == null) { return Problem(\u0026#34;Entity set \u0026#39;ApiDbContext.ItemData\u0026#39; is null.\u0026#34;); } _context.ItemData.Add(itemData); await _context.SaveChangesAsync(); return CreatedAtAction(\u0026#34;GetItemData\u0026#34;, new { id = itemData.Id }, itemData); } // DELETE: api/Todo/5 [HttpDelete(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; DeleteItemData(int id) { if (_context.ItemData == null) { return NotFound(); } var itemData = await _context.ItemData.FindAsync(id); if (itemData == null) { return NotFound(); } _context.ItemData.Remove(itemData); await _context.SaveChangesAsync(); return NoContent(); } private bool ItemDataExists(int id) { return (_context.ItemData?.Any(e =\u0026gt; e.Id == id)).GetValueOrDefault(); } } }   測試新功能 在 open api - swagger 網頁上透過 POST 的 EndPoint 新增一筆 Toto list\n送出新增的資料，回覆新增成功\n由資料庫中可以查詢到新建立的 record\n!透過 GET 的 EndPoint 也可以查詢到新增 Toto list\n以上可以發現使用 ASPNET Codegenerator 自動産生的程式就可簡單的完成資料表格的新增、查詢、修改、刪除等日常功能，真是方便呢！\nCORS 議題 Web App 與 Web Api Server 若處於“不同源”時，當 App 使用 http request 呼叫 Web Api Server 上端點時就會有“同源策略“的問題，這個狀況在測試環境中尤為明顯。 要解決這個問題就必須透過 CORS (Cross-Origin Resource Sharing) 相關設定來應對。在 DotNet Core 中設定相關簡易，僅須在 Program.cs 中加入以下二段程式碼即可：\n以下程式碼放在 “builder.Services.AddControllers();” 之前：\n1 2 3 4 5 6 7 8 9  var MyAllOrigins = \u0026#34;allowAll\u0026#34;; builder.Services.AddCors(option =\u0026gt; option.AddPolicy(name: MyAllOrigins, policy =\u0026gt; { policy.WithOrigins(\u0026#34;http://localhost:4200\u0026#34;).AllowAnyMethod().AllowAnyHeader(); } ) );   以及\n以下程式碼放在 “app.UseHttpsRedirection();” 之前：\napp.UseCors(MyAllOrigins); 完成後，當前端 Web App (如： angular 在測試環境下預設是使用 localhost:4200) 使用 http request 呼叫後端 Web Api (本例中 Web Api 使用的是 localhost:5023) 時就可避到同源策略的要求。\nProgram.cs 完整程式碼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113  using System.Text; using dotnet7_webapi_jwt.Data; using Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.AspNetCore.Identity; using Microsoft.EntityFrameworkCore; using Microsoft.IdentityModel.Tokens; using Microsoft.OpenApi.Models; var builder = WebApplication.CreateBuilder(args); ConfigurationManager _configuration = builder.Configuration; var secret = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;); // Add services to the container. builder.Services.AddDbContext\u0026lt;ApiDbContext\u0026gt;( options =\u0026gt; options.UseNpgsql( _configuration.GetConnectionString(\u0026#34;ConnStr\u0026#34;) ) ); builder.Services.AddIdentity\u0026lt;IdentityUser, IdentityRole\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApiDbContext\u0026gt;() .AddDefaultTokenProviders(); builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; }) .AddJwtBearer(options =\u0026gt; { // 當驗證失敗時，回應標頭會包含 WWW-Authenticate 標頭，這裡會顯示失敗的詳細錯誤原因  options.IncludeErrorDetails = true; // 預設值為 true，有時會特別關閉  options.TokenValidationParameters = new TokenValidationParameters { // 透過這項宣告，就可以從 \u0026#34;NAME\u0026#34; 取值  NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, // 透過這項宣告，就可以從 \u0026#34;Role\u0026#34; 取值，並可讓 [Authorize] 判斷角色  RoleClaimType = \u0026#34;http://schemas.microsoft.com/ws/2008/06/identity/claims/role\u0026#34;, // 驗證 Issuer (一般都會)  ValidateIssuer = true, ValidIssuer = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidIssuer\u0026#34;), // 驗證 Audience (通常不太需要)  ValidateAudience = false, //ValidAudience = = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidAudience\u0026#34;),  // 驗證 Token 的有效期間 (一般都會)  ValidateLifetime = true, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已  ValidateIssuerSigningKey = false, // 應該從 IConfiguration 取得  IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)) }; }); var allOrigins = \u0026#34;allowAll\u0026#34;; builder.Services.AddCors(option =\u0026gt; option.AddPolicy(name: allOrigins, policy =\u0026gt; { policy.WithOrigins(\u0026#34;http://localhost:4200\u0026#34;).AllowAnyMethod().AllowAnyHeader(); } ) ); builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;JwtDemo\u0026#34;, Version = \u0026#34;v1\u0026#34; }); c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { In = ParameterLocation.Header, Description = \u0026#34;Please enter JWT with Bearer into field\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, Type = SecuritySchemeType.ApiKey }); c.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} }, new string[] {} } }); }); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseCors(allOrigins); app.UseAuthentication(); app.UseAuthorization(); app.MapControllers(); app.Run();   ","permalink":"https://calvinegs.github.io/posts/dotnet7-webapi-jwt/","summary":"github Source code\n本文將記錄如何一步步從無到有，使用 Dotnet Core 7.0 建立 ASP.NET Core Web API，其中將會使用到下列技術:\n Dotnet CLI Entity Framework 7.0 Json Web Token PostgreSQL DB (Docker Version) ASP.NET Core Generator  專案完成後的檔案結構 ./專案目錄 ├── .config/ │ └── dotnet-tools.json ├── .vscode/ │ ├── launch.js │ └── tasks.json ├── Controller/ │ ├── AuthenticateController.cs │ ├── TodoController.cs │ └── WeatherForecast.cs ├── Data/ │ └── ApiDbContext.cs ├── Migrations/ ├── Models/ │ ├── AuthenticateData.cs │ └── TodoList.cs ├── obj/ ├── Properties/ │ └── launchSettings.","title":"使用 .NET 7.0 建立使用 以 JWT 身份驗證機制的 ASP.NET Web Api（並使用 Microsoft Identity 框架來存儲使用者和角色等資料）"},{"content":"使用 Docker Compose 執行 MSSQL Server 2022 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 MSSQL 2022。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 23.0.1 API version: 1.42 Go version: go1.19.5 Git commit: a5ee5b1 Built: Thu Feb 9 19:46:56 2023 OS/Arch: linux/amd64 Context: default Server: Docker Engine - Community Engine: Version: 23.0.1 API version: 1.42 (minimum version 1.12) Go version: go1.19.5 Git commit: bc3805a Built: Thu Feb 9 19:46:56 2023 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.18 GitCommit: 2456e983eb9e37e47538f59ea18f2043c9a73640 runc: Version: 1.1.4 GitCommit: v1.1.4-0-g5fd4c4d docker-init: Version: 0.19.0 GitCommit: de40ad0 檢查是否已安裝了 docker compose $ docker compose version Docker Compose version v2.16.0 使用 docker compose 來執行 MSSQL Server 2022 建置專案目錄結構 $ mkdir mssql \u0026amp;\u0026amp; cd mssql $ touch docker-compose.yml 建立 docker-compose.yml 在這個 compose command file 中一個 services: mssql，用來下載並啟動 MSSQL Server 2022。指令與說明如下：\n特別注意到 “command:” 這行的設定，它的用意是希望在第一次啟動這個 conatiner 時可以在 MSSQL 啟動成功後，自動建立一個名為 testdb 的資料庫，由於在 compose file 也有設定 volume，所以第一次啟動成功自動建立的 testdb 也會被永久保存在 local 資料庫，不會因為 docker 結束後而消失，所以這行指令可在成功建立 testdb 後把它註解掉。\nversion: \u0026#39;3.3\u0026#39; services: mssql: container_name: sql-server-2022 image: mcr.microsoft.com/mssql/server:2022-latest restart: always environment: ACCEPT_EULA: \u0026#34;Y\u0026#34; SA_PASSWORD: \u0026#34;\u0026lt;password\u0026gt;\u0026#34; # 把 \u0026lt;password\u0026gt; 替換成你需要的密碼 ports: - 1433:1433 volumes: - volume2022:/var/opt/mssql2022  # 將 SQL Server 的 Data file 等映射到 local 的目錄中來，其中 ”volume2022“ 是 volume 名稱，而“/var/opt/mssql2022\u0026#34; 則為 server 端資料庫檔案放置的目錄名稱 command: /bin/sh -c \u0026#34;(/opt/mssql/bin/sqlservr \u0026amp;) \u0026amp;\u0026amp; sleep 10s \u0026amp;\u0026amp; /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P \u0026lt;password\u0026gt; -d master -Q \u0026#39;CREATE DATABASE [testdb]\u0026#39; \u0026amp;\u0026amp; sleep infinity\u0026#34;  #  volumes: volume2022: 執行 docker compose 上述的目錄與檔案內容準備完成後，在與 docker-compose.yml 的相同目錄中執行 docker compose up -d來啟動 db Services，啟動成功後可使用 ｀$ docker ps｀ 指令查看容器啟動狀況\n$ docker compose up sql-server-2022 | /opt/mssql/bin/permissions_check.sh: line 4: [: : integer expression expected sql-server-2022 | /opt/mssql/bin/permissions_check.sh: line 59: [: : integer expression expected sql-server-2022 | SQL Server 2022 will run as non-root by default. sql-server-2022 | This container is running as user mssql. sql-server-2022 | To learn more visit https://go.microsoft.com/fwlink/?linkid=2099216. # .... [+] Running 1/1 ⠿ Container sql-server-2022 Stopped 查看 docker 執行的情況 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b9ec8aa9e83e mcr.microsoft.com/mssql/server:2022-latest \u0026#34;/opt/mssql/bin/perm…\u0026#34; 5 seconds ago Up 5 seconds 0.0.0.0:1433-\u0026gt;1433/tcp, :::1433-\u0026gt;1433/tcp sql-server-2022 使用 dbeaver-cd 連結到 MSSQL DB 開啟 dbeaver-cd 程式，按下 ｀New Database Connection` 按鈕\n開始設置連線資料設定，選擇資料庫 - MSSQL 按下 ｀Next`\n輸入相關資訊，如 Database name、Username、Password\u0026hellip;等，按下｀Test Connectiono\u0026hellip;｀來測試設定是否成功。\n在 testdb 中建立資料表 use testdb; CREATE TABLE Inventory (id INT, name NVARCHAR(50), quantity INT); INSERT INTO Inventory VALUES (1, \u0026#39;banana\u0026#39;, 150); INSERT INTO Inventory VALUES (2, \u0026#39;orange\u0026#39;, 154); 查看 volume 相關資訊 $ docker volume inspect mssql2022_volume2022 [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2023-02-26T11:12:47+08:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: { \u0026#34;com.docker.compose.project\u0026#34;: \u0026#34;mssql2022\u0026#34;, \u0026#34;com.docker.compose.version\u0026#34;: \u0026#34;2.16.0\u0026#34;, \u0026#34;com.docker.compose.volume\u0026#34;: \u0026#34;volume2022\u0026#34; }, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/mssql2022_volume2022/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;mssql2022_volume2022\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] 資料庫的實際檔案存放在 Local 的 /var/opt/mssql 目錄中 使用作業系統管理者權限來查看此目錄\n$ sudo ls -al /var/lib/docker/volumes/mssql2022_volume2022/_data 總用量 24 drwxrwx--- 6 root root 4096 2月 26 11:12 . drwx-----x 3 root root 4096 2月 26 11:12 .. drwxr-xr-x 2 10001 root 4096 2月 26 11:12 data drwxr-xr-x 2 10001 root 4096 2月 26 11:12 log drwxr-xr-x 2 10001 root 4096 2月 26 11:12 secrets drwxr-xr-x 5 10001 root 4096 2月 26 11:12 .system 重新啟動 docker compose 關閉 docker\n$ docker compose down [+] Running 2/2 ⠿ Container sql-server-2022 Removed 10.5s ⠿ Network mssql2022_default Removed 重新使用 docker compose up -d 來啟動 MSSQL Server 2022 container。\n提醒： compose file 中“command:” 這行的設定記得把它註解掉！\n啟動成功後，再開啟 DBeaver 會發現前面新建立的 Inventory Table 及 資料都還存在！\n","permalink":"https://calvinegs.github.io/posts/docker-compose-mssql/","summary":"使用 Docker Compose 執行 MSSQL Server 2022 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 MSSQL 2022。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 23.0.1 API version: 1.42 Go version: go1.19.5 Git commit: a5ee5b1 Built: Thu Feb 9 19:46:56 2023 OS/Arch: linux/amd64 Context: default Server: Docker Engine - Community Engine: Version: 23.0.1 API version: 1.42 (minimum version 1.12) Go version: go1.19.5 Git commit: bc3805a Built: Thu Feb 9 19:46:56 2023 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.","title":"使用 Docker Compose 執行 MSSQL Server 2022"},{"content":"github Source code\nAngular Intercoptor 使用案例二：搭配 Jason Web Token + Session Storage 來實現使用者身份驗證功能 使用者驗證在所有的應用程式中都是很重要的一個環節。本篇筆記中將使用 Angular Interceptor + Jason Web Token 以及 Session Storage 來實現這個重點功能。\n本篇這個“前端登入功能”所搭配的後端程式可詳見 “使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api”\n執行步驟如下：\n 取得預備的程式碼 建立 appSettings 來存放程式參數值 建立 auth.service.ts 建立 token-storage.service.ts 完成 login page component 中的程式碼 執行測試 建立 interceptor 程式 建立 Guard 程式  取得預備的程式碼 在 \u0026ldquo;使用 Angular Material 建立一個簡易的 Admin Template II\u0026rdquo; 已經使用 Material UI Component 設計好登入畫面，接下來就直接捉取這個版本的程式碼來接續完成使用者登入功能的所有程式。\n可使用以下 git clone 指令來取得該版本的 Source Code “git clone \u0026ndash;branch v2.0 https://github.com/calvinegs/Angular_Material_Admin_Template jwtAuth”\n$ git clone --branch v2.0 https://github.com/calvinegs/Angular_Material_Admin_Template jwtAuth 正複製到 \u0026#39;jwtAuth\u0026#39;... remote: Enumerating objects: 112, done. remote: Counting objects: 100% (112/112), done. remote: Compressing objects: 100% (77/77), done. remote: Total 112 (delta 37), reused 104 (delta 29), pack-reused 0 接收物件中: 100% (112/112), 229.41 KiB | 1.35 MiB/s, 完成. 處理 delta 中: 100% (37/37), 完成. 註：切換至 “14330473003d6fe7c52cf5218113e1aa52f6b19c”。 您正處於「分離 HEAD」狀態。您可以檢視、進行實驗性修改並提交， 而且您可以在切回分支時，捨棄在此狀態下所做的提交 而不對分支造成影響。 如果您想要透過建立分支來保留在此狀態下所做的提交， 您可以現在或稍後在 switch 指令使用 -c 選項。例如： git switch -c \u0026lt;新分支名稱\u0026gt; 或者是使用下述命令復原此動作： git switch - 將組態變數 advice.detachedHead 設定為 false，即可關閉本建議 $ cd jwtAuth $ git swithc -c main $ npm i $ code . # 開啟 VS Code 建立 appSettings 來存放程式參數值 考慮到彈性應用，新增一支 appSettings.ts 程式。在 shared 目錄下新增一個　helpers 的子目錄，並新增一支 appSettings.ts 程式，內容如下：\n設置一個靜態常數 API_URL，並把它 export 出來，讓外面的程式可以引用它。\nexport class AppSettings { static API_URL = \u0026#39;https://localhost:7087/api/\u0026#39;; } 建立 auth.service.ts 使用 angular cli 建立一支 Service 程式，用來呼叫後端 API。\n$ npx ng g s services/auth 這支 service 程式中透過使用 httpClient 來連結 web api 端點（https://localhost:7087/api/Authenticate/login）來進行使用者資料驗證。\nauth.service.ts 內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { AppSettings } from \u0026#39;../shared/helpers/appSettings\u0026#39;; const API_URL = AppSettings.API_URL + \u0026#39;Authenticate/\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class AuthService {  constructor(private http: HttpClient) { } logint(email: string, password: string): Observable\u0026lt;any\u0026gt; { return this.http.post(API_URL + \u0026#39;login\u0026#39;, { email, password })  } }   建立 jwt-storage.service.ts 接著建立一支處理 jwt 存放在 Session Storage 中及由 Session Storage 讀取已完成驗證的 JWT 功能的 service 程式。\n$ npx ng g s services/jwtStorage jwt-storage.service.ts 內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import { Injectable } from \u0026#39;@angular/core\u0026#39;; const TOKEN_KEY = \u0026#39;auth-token\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class JwtStorageService { constructor() { } logout(): void { window.sessionStorage.clear(); } isLogin() { return (sessionStorage.getItem(TOKEN_KEY)); } saveToken(token: string): void { sessionStorage.removeItem(TOKEN_KEY); sessionStorage.setItem(TOKEN_KEY, token); } }   完成 login page component 中的程式碼 login.component.ts 內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  import { Component } from \u0026#39;@angular/core\u0026#39;; import { FormBuilder, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; import { AuthService } from \u0026#39;src/app/services/auth.service\u0026#39;; import { JwtStorageService } from \u0026#39;src/app/services/jwt-storage.service\u0026#39;; @Component({ selector: \u0026#39;app-login\u0026#39;, templateUrl: \u0026#39;./login.component.html\u0026#39;, styleUrls: [\u0026#39;./login.component.scss\u0026#39;] }) export class LoginComponent { hide: boolean = false; constructor(private fb: FormBuilder, private authService: AuthService, private tokenService: JwtStorageService) { } ngOnInit() { } loginForm: FormGroup = this.fb.group({ email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]], password: [\u0026#39;\u0026#39;, [Validators.required, Validators.minLength(6)]] }) onLogin() { if (!this.loginForm.valid) { return; } const { email, password } = this.loginForm.getRawValue(); this.authService.login(email, password).subscribe({ next: data =\u0026gt; { this.tokenService.saveToken(data.token); }, error: err =\u0026gt; { console.log(\u0026#39;error\u0026#39;); } }); } }   執行測試 在 Terminal 中輸入 npm start 來啟動程式，並開啟瀏覽器，輸入：（http://localhost:4200/login）\n$ npm start 在登入前，先開啟 chrome 開發者工具頁（F12），切到 Application 頁籤，此刻會發現並沒有任何一筆資料存在 Session Storage 中\n註：Session Storage 與 Local Storage 的功能及用法類似，最大的差別在 “Session Storage” 在該網頁關掉時會自動清楚，這個特性在測試環境中特別方便（不用每次測試都要手動去刪除 Local Storage 資料），所以在程式中是採用 Session Storage。\n登入成功後，可以查看一下瀏覽器中的 session storae 是否已存放對應的 JWT 的資料。\n註: 在登入前請先到使用的 SQL server 資料庫中加入一筆使用者資料。\n建立一支 interceptor 程式 程式到此已經可正常完成登入作業並取得由後端回傳的 Token。\n接下來要回到本篇筆記的“正題“，如何透過 Angular Interceptor 來幫 每個 http request 加入 Token。\n這支 Interceptor 程式用來在每個 http request 發出時，檢查若已登入檢核已完成，就會將儲存在 session storage 中的 JWT attach 到 http request Header 中，如此再搭配 web api 上的保護機制，就可以防止非法使用者去拜訪 API 上特定的 end point。\n$ npx ng g interceptor interecpt/auth auth.interceptor.ts 內容如下，程式中比較特間的地方就是，不能直接去 Interceptor 取得的 request 內容，要變更 request header時必須先使用 clone 來複製新的 request 再依需求來修改這個新的 request。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { JwtStorageService } from \u0026#39;src/app/services/jwt-storage.service\u0026#39;; @Injectable() export class AuthInterceptor implements HttpInterceptor { constructor(private tokenService: JwtStorageService) {} intercept(request: HttpRequest\u0026lt;unknown\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;unknown\u0026gt;\u0026gt; { let authReq = request; if (this.tokenService.isLogin()) { const token = this.tokenService.getToken(); authReq = request.clone({ setHeaders: { Authorization: `Bearer ${token}` } }) } return next.handle(authReq); } }   註冊 interecptor 新建立完成的 AuthInterceptor 必須在 app.module.ts 進行註冊：\nproviders: [ { provide: HTTP_INTERCEPTORS, useClass: LoadingSpinInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true } ], 建立 Guard (路由保護) 程式 路由保護器(攔截器)　是一種 local 端保護機制。透過 Route Guard 的設置可以在使用者端就能效管理各個 route 的執行權限的控管。\n$ npx ng g guard shared/guard/auth --implements CanActivate authGuard 這個路由保護器的功能就是來攔截沒有正常登入系統的使用者不得執行特定的路由。在程式中透過 tokenService.getToken() 功能來讀取 token，若 session storeage 中沒有合法 token，表示目前還沒有正確的登入系統，並將程式指向登入功能。\nauth.guard.ts 內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRouteSnapshot, CanActivate, Router, RouterStateSnapshot, UrlTree } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { JwtStorageService } from \u0026#39;src/app/services/jwt-storage.service\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class AuthGuard implements CanActivate { constructor(private router: Router, private tokenService: JwtStorageService){} canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable\u0026lt;boolean | UrlTree\u0026gt; | Promise\u0026lt;boolean | UrlTree\u0026gt; | boolean | UrlTree { if (this.tokenService.isLogin()) return true; this.router.navigate([\u0026#39;/login\u0026#39;]); return true; } }   使用 Guard 來保護 ‘getdata` 路由 在 app-routing.module.ts 程式中加入路由保護機制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { FlexboxComponent } from \u0026#39;./components/flexbox/flexbox.component\u0026#39;; import { GetDataComponent } from \u0026#39;./components/get-data/get-data.component\u0026#39;; import { LoginComponent } from \u0026#39;./components/login/login.component\u0026#39;; import { NavigationComponent } from \u0026#39;./navigation/navigation.component\u0026#39;; import { AuthGuard } from \u0026#39;./shared/guard/auth.guard\u0026#39;; const routes: Routes = [ { path: \u0026#39;\u0026#39;, component: NavigationComponent, children: [ { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;flexbox\u0026#39;, pathMatch: \u0026#39;full\u0026#39;}, { path: \u0026#39;flexbox\u0026#39;, component: FlexboxComponent }, { path: \u0026#39;getdata\u0026#39;, component: GetDataComponent, canActivate: [AuthGuard] },  ] }, { path: \u0026#39;login\u0026#39;, component: LoginComponent, }, ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   完善其他功能 最後再幫程式加入其他小功能來完善整個程式的功能及流暢度。\n 在 Navigator Header 右側加入下接選單，加入登入／登出功能 在 JwtStorageService 中加入相關功能來輔助程式可以支援動態顯示“登入／登出” 在 Login 功能中加入登入成功後自動跳轉回主畫面功能  在 navigation.component.html 中加入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!-- ... --\u0026gt; \u0026lt;button mat-icon-button [matMenuTriggerFor]=\u0026#34;menu\u0026#34; aria-label=\u0026#34;Options\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt;more_vert\u0026lt;/mat-icon\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;mat-menu #menu=\u0026#34;matMenu\u0026#34;\u0026gt; \u0026lt;button mat-menu-item (click)=\u0026#34;logout()\u0026#34; [disabled]=\u0026#34;!(isLogin$ | async)\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt;logout\u0026lt;/mat-icon\u0026gt; \u0026lt;span\u0026gt;Logout\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button mat-menu-item (click)=\u0026#34;login()\u0026#34; [disabled]=\u0026#34;isLogin$ |async\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt;login\u0026lt;/mat-icon\u0026gt; \u0026lt;span\u0026gt;Login\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/mat-menu\u0026gt; \u0026lt;!-- ... --\u0026gt;   navigation.component.ts 內容調整如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  import { Component } from \u0026#39;@angular/core\u0026#39;; import { BreakpointObserver, Breakpoints } from \u0026#39;@angular/cdk/layout\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { map, shareReplay } from \u0026#39;rxjs/operators\u0026#39;; import { LoadingService } from \u0026#39;../services/loading.service\u0026#39;; import { JwtStorageService } from \u0026#39;../services/jwt-storage.service\u0026#39;; import { Router } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-navigation\u0026#39;, templateUrl: \u0026#39;./navigation.component.html\u0026#39;, styleUrls: [\u0026#39;./navigation.component.scss\u0026#39;] }) export class NavigationComponent { isDarkTheme = false; loading$ = this._loadingService.loading$; isLogin$ = this.tokenService.isLogin$;  isHandset$: Observable\u0026lt;boolean\u0026gt; = this.breakpointObserver.observe(Breakpoints.Handset) .pipe( map(result =\u0026gt; result.matches), shareReplay() ); constructor(private breakpointObserver: BreakpointObserver, private _loadingService: LoadingService, private tokenService: JwtStorageService, private router: Router) {} ngOnInit() { this.isDarkTheme = localStorage.getItem(\u0026#39;theme\u0026#39;) === \u0026#34;Dark\u0026#34; ? true : false; this.tokenService.checkLoginStatus();  } storeThemeSelection() { localStorage.setItem(\u0026#39;theme\u0026#39;, this.isDarkTheme ? \u0026#34;Dark\u0026#34; : \u0026#34;Light\u0026#34;); } logout() { this.tokenService.logout(); } login() { this.router.navigate([\u0026#39;/login\u0026#39;]); } }   在 jwt-storage.service.ts 中加入可即時反應登入狀態的 observable:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { BehaviorSubject, Observable, of, switchMap } from \u0026#39;rxjs\u0026#39;;  const TOKEN_KEY = \u0026#39;auth-token\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class JwtStorageService { private _isLogin$ = new BehaviorSubject\u0026lt;boolean\u0026gt;(false); isLogin$: Observable\u0026lt;boolean\u0026gt; = this._isLogin$.pipe( switchMap(isLogin =\u0026gt; { if (!isLogin) { return of(false); } return of(true); }) )  constructor() { } logout(): void { window.sessionStorage.clear(); this._isLogin$.next(false); } checkLoginStatus(): void { this._isLogin$.next(!!sessionStorage.getItem(TOKEN_KEY)); } isLogin() { return (sessionStorage.getItem(TOKEN_KEY)); } getToken() { return sessionStorage.getItem(TOKEN_KEY); } saveToken(token: string): void { sessionStorage.removeItem(TOKEN_KEY); sessionStorage.setItem(TOKEN_KEY, token); } }   最後的測試結果 啟動程式\n$ npx ng s -o 在尚未登入時去執行 \u0026ldquo;loging spinner\u0026rdquo; 功能時系統會自動跳轉至‘登入’畫面要求使用者先進行身份驗證，否則無法執行’被保護‘的這項功能。\n一旦登入成功，就可以順利執行 \u0026ldquo;loging spinner\u0026rdquo; 功能，同時“登入／登出”功能也能正確切換不同的使用狀態。\n","permalink":"https://calvinegs.github.io/posts/angular-interceptor-jwt/","summary":"github Source code\nAngular Intercoptor 使用案例二：搭配 Jason Web Token + Session Storage 來實現使用者身份驗證功能 使用者驗證在所有的應用程式中都是很重要的一個環節。本篇筆記中將使用 Angular Interceptor + Jason Web Token 以及 Session Storage 來實現這個重點功能。\n本篇這個“前端登入功能”所搭配的後端程式可詳見 “使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api”\n執行步驟如下：\n 取得預備的程式碼 建立 appSettings 來存放程式參數值 建立 auth.service.ts 建立 token-storage.service.ts 完成 login page component 中的程式碼 執行測試 建立 interceptor 程式 建立 Guard 程式  取得預備的程式碼 在 \u0026ldquo;使用 Angular Material 建立一個簡易的 Admin Template II\u0026rdquo; 已經使用 Material UI Component 設計好登入畫面，接下來就直接捉取這個版本的程式碼來接續完成使用者登入功能的所有程式。","title":"Angular Intercoptor 使用案例二：搭配 Jason Web Token + Session Storage 來實現使用者身份驗證功能"},{"content":"github Source code\n註: 若只要取得本篇筆記所介紹的內容可使用以下指令: “git clone --branch v2.0 https://github.com/calvinegs/Angular_Material_Admin_Template.git”\n在本篇筆記中將繼續使用 Angular Material 中的其他 components 來加強 Admin Template。在此文中除了會使用 SnackBar component 來實做一個 Notifier ，同時也把之前介紹過的 Loading Spnner 功能也一併加入。\n除此之外也會建置一個 Login Page，身份驗證是一個應用程式中不可缺少的功能，有了這個登入畫面，將會被應用到另一篇 angular Interceptor - JWT 的應用中（待續）。\n有關 Admin Template 第一個版本的介紹請見 Loding Spinner\n加強 Admin Template 功能 預計實現的功能：\n使用 Angular Material SnackBar 為 Admin Template 加入 Notifier 功能。 使用以下步驟：\n 取得 Admin Template 第一個版本程式碼 實現基本版本 Notifier 實現客制化 Notifier 功能 使用 material 實現一個 Login Page  取得 Admin Template 第一個版本程式碼 首先要為 Admin Template 第一個版本加入 Notifier 功能，可以使用 ｀git clone｀指令取得特定版程式碼。以下指令是取得 Tag為 ver-1.0 版本的程式碼： “git clone --branch v1.1 https://github.com/calvinegs/Angular_Material_Admin_Template.git”。使用這個版本的程式碼繼續在上面加入本篇筆記的相關功能。\n實現基本版本 Notifier 將使用 angular material snackBar component 來實現 Notifier 功能。\n匯入 snackBar module 使用 material snackBar component前要先匯入 snackBarModule 到 share-material-module.ts 中，並把它也 export 出去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; import { RouterModule } from \u0026#39;@angular/router\u0026#39;; import { NavigationComponent } from \u0026#39;../navigation/navigation.component\u0026#39;; import { LayoutModule } from \u0026#39;@angular/cdk/layout\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatSidenavModule } from \u0026#39;@angular/material/sidenav\u0026#39;; import { MatIconModule } from \u0026#39;@angular/material/icon\u0026#39;; import { MatListModule } from \u0026#39;@angular/material/list\u0026#39;; import { MatSlideToggleModule } from \u0026#39;@angular/material/slide-toggle\u0026#39;; import { MatSnackBarModule } from \u0026#39;@angular/material/snack-bar\u0026#39;  @NgModule({ declarations: [ NavigationComponent ], imports: [ CommonModule, FormsModule, LayoutModule, MatToolbarModule, MatButtonModule, MatSidenavModule, MatIconModule, MatListModule, MatSlideToggleModule, MatSnackBarModule,  RouterModule ], exports: [ NavigationComponent ] }) export class ShareMaterialModule { }   建立 NotifierService 接著建立 notifier.service.ts\n$ npx ng g s services/notifier NotifierService 程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // notifier.service.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { MatSnackBar } from \u0026#39;@angular/material/snack-bar\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class NotifierService { constructor( private snackBar: MatSnackBar) { }  showNotification(displayMessage: string, buttonText: string) { this.snackBar.open(displayMessage, buttonText, { horizontalPosition: \u0026#39;center\u0026#39;, // snack Bar 顯示的水平位置  verticalPosition: \u0026#39;bottom\u0026#39;, // snack Bar 顯示的垂直位置  panelClass: \u0026#39;error\u0026#39; // 自定顏色  }) } }   客制化 css 在 NotifierService 中使用了一些客制化的 css，把 css 程式碼加入到 style.scss\n.error.mat-mdc-snack-bar-container{ --mdc-snackbar-container-color: red; // 背景 --mdc-snackbar-supporting-text-color: white; // 文字顏色 --mat-mdc-snack-bar-button-color: yellow; // 按鈕文字顏 } 使用 NotifierService 來顯示 Notifier 在 flexBox component 中加入一個功能按鈕，並在按下按鈕後呼叫 NotefierService 中的 showNotification() 方法來顯示 Notifier 在螢幕下方。\n首先在 flexBox component template 中加入以下程式碼。\n\u0026lt;!-- flexbox.component.html --\u0026gt; \u0026lt;p\u0026gt;flexbox works!\u0026lt;/p\u0026gt; \u0026lt;button mat-raised-button color=\u0026#34;primary\u0026#34; (click)=\u0026#39;showError()\u0026#39;\u0026gt;Show Error\u0026lt;/button\u0026gt; 在上述程式中使用了 mat-raised-button directive 所以要在 share module 中匯入 MatButtonModule，並且也要 export 出來。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // share-material.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; import { RouterModule } from \u0026#39;@angular/router\u0026#39;; import { NavigationComponent } from \u0026#39;../navigation/navigation.component\u0026#39;; import { LayoutModule } from \u0026#39;@angular/cdk/layout\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatSidenavModule } from \u0026#39;@angular/material/sidenav\u0026#39;; import { MatIconModule } from \u0026#39;@angular/material/icon\u0026#39;; import { MatListModule } from \u0026#39;@angular/material/list\u0026#39;; import { MatSlideToggleModule } from \u0026#39;@angular/material/slide-toggle\u0026#39;; import { MatSnackBarModule } from \u0026#39;@angular/material/snack-bar\u0026#39; @NgModule({ declarations: [ NavigationComponent ], imports: [ CommonModule, FormsModule, LayoutModule, MatToolbarModule, MatButtonModule,  MatSidenavModule, MatIconModule, MatListModule, MatSlideToggleModule, MatSnackBarModule, RouterModule ], exports: [ NavigationComponent, MatButtonModule,  ] }) export class ShareMaterialModule { }   flexBox component class 的程式碼如下：\n 先在 constructor 中注入 Notifier Service 再建立一個 showError() method，並在這個方法內呼叫 Notifier Service 中的 showNotification() 方法。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // flexbox.component.ts import { Component } from \u0026#39;@angular/core\u0026#39;; import { NotifierService } from \u0026#39;src/app/services/notifier.service\u0026#39;; @Component({ selector: \u0026#39;app-flexbox\u0026#39;, templateUrl: \u0026#39;./flexbox.component.html\u0026#39;, styleUrls: [\u0026#39;./flexbox.component.scss\u0026#39;] }) export class FlexboxComponent {  constructor(private notifierService: NotifierService) {} showError() { this.notifierService.showNotification(\u0026#39;資料讀取失敗！\u0026#39;,\u0026#39;關閉\u0026#39;);  } }   執行程式後結果 優化 NotifierService 優化的功能包含了：\n 支援不同類型的 Notifier (Success/Error) Notifier 預設五秒鐘會自動消失  修改 NotifierService 中 showNotification() method:\n1 2 3 4 5 6 7 8 9  // notifier.service.ts  showNotification(displayMessage: string, buttonText: string, messageType: \u0026#39;error\u0026#39; | \u0026#39;success\u0026#39;) {  this.snackBar.open(displayMessage, buttonText, { duration: 5000,  horizontalPosition: \u0026#39;center\u0026#39;, verticalPosition: \u0026#39;bottom\u0026#39;, panelClass: messageType  }) }   在 styles.scss 中再加入額外的 succs style 設定\n.success.mat-mdc-snack-bar-container{ --mdc-snackbar-container-color: gray; --mdc-snackbar-supporting-text-color: yellow; --mat-mdc-snack-bar-button-color: white; } 修改 flexbox.component.html：\n1 2 3 4 5 6  \u0026lt;p\u0026gt;flexbox works!\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;button-container\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; mat-raised-button color=\u0026#34;primary\u0026#34; (click)=\u0026#34;showSnackBar(\u0026#39;success\u0026#39;)\u0026#34;\u0026gt;success\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; mat-raised-button color=\u0026#34;accent\u0026#34; (click)=\u0026#34;showSnackBar(\u0026#39;error\u0026#39;)\u0026#34;\u0026gt;error\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;   修改 flexbox.component.scss:\n.container{ display: flex; } .btn{ margin: 5px; } 修改 flexbox.component.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import { Component } from \u0026#39;@angular/core\u0026#39;; import { NotifierService } from \u0026#39;src/app/services/notifier.service\u0026#39;; @Component({ selector: \u0026#39;app-flexbox\u0026#39;, templateUrl: \u0026#39;./flexbox.component.html\u0026#39;, styleUrls: [\u0026#39;./flexbox.component.scss\u0026#39;] }) export class FlexboxComponent { constructor(private notifierService: NotifierService) {} showSnackBar(typeNotifier:\u0026#39;error\u0026#39;|\u0026#39;success\u0026#39;) { if (typeNotifier === \u0026#39;success\u0026#39;) this.notifierService.showNotification(\u0026#39;資料已順利讀取完成！\u0026#39;,\u0026#39;OK\u0026#39;, typeNotifier); else this.notifierService.showNotification(\u0026#39;資料讀取失敗！\u0026#39;,\u0026#39;關閉\u0026#39;, typeNotifier);  } }   優化後的結果 優化後同一個 method showSnackBar() 已可以支援不同類型的 notifier ，並顯示出不同的 style:\n實現客制化 Notifier 功能 如果你的 notifier 需要更豐富的 UI，MatSnackBar 也支援可自定使用者介紹的方式來顯示，下面來看看如何做到客制化 UI。\n新建立一個 component 使用 ng cli 在 components 目錄下建立一個新元件\n$ npx ng g c components/notifier NotifierServer 中新的 Method 在新元件中將會使用到 NotifierServer 中新的 method，如下：\n// notifier.service.ts // ...  showCustomNotification(displayMessage: string, buttonText: string, messageType: \u0026#39;error\u0026#39; | \u0026#39;success\u0026#39;) { this.snackBar.openFromComponent(NotifierComponent, { data: { message: displayMessage, buttonText: buttonText, messageType: messageType }, duration: 5000, horizontalPosition: \u0026#39;center\u0026#39;, verticalPosition: \u0026#39;bottom\u0026#39;, panelClass: [messageType] }) }; 新 component 的程式碼 Notifier Component 程式內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // notifier.component.ts import { Component, Inject } from \u0026#39;@angular/core\u0026#39;; import { MatSnackBarRef, MAT_SNACK_BAR_DATA } from \u0026#39;@angular/material/snack-bar\u0026#39;; @Component({ selector: \u0026#39;app-notifier\u0026#39;, templateUrl: \u0026#39;./notifier.component.html\u0026#39;, styleUrls: [\u0026#39;./notifier.component.scss\u0026#39;] }) export class NotifierComponent { constructor(@Inject(MAT_SNACK_BAR_DATA) public data: any, public snackBarRef: MatSnackBarRef\u0026lt;NotifierComponent\u0026gt;) { }   Notifier Component template 內容：\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!-- notifier.component.heml --\u0026gt; \u0026lt;div\u0026gt; {{data.messageType}} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content-style\u0026#34;\u0026gt; {{data.message}} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;button-style\u0026#34;\u0026gt; \u0026lt;button mat-flat-button [ngClass]=data.messageType (click)=\u0026#34;snackBarRef.dismiss()\u0026#34;\u0026gt; {{data.buttonText}} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;   Notifier Component style 內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /* notifier.component.scss */ .success { background-color: gray; } .error { background-color: aqua; } .content-style{ border: 1px solid white; border-radius: 4px; padding: 10px; margin-top: 10px; margin-bottom: 10px; } .button-style{ text-align: center; }   flexBox Component 程式內容：\n1 2 3 4 5 6 7  // flexbox.component.ts  showCustomSnackBar(typeNotifier: \u0026#39;error\u0026#39;|\u0026#39;success\u0026#39;) { if (typeNotifier === \u0026#39;success\u0026#39;) this.notifierService.showCustomNotification(\u0026#39;資料已順利讀取完成！\u0026#39;,\u0026#39;OK\u0026#39;, typeNotifier); else this.notifierService.showCustomNotification(\u0026#39;資料讀取失敗！\u0026#39;,\u0026#39;關閉\u0026#39;, typeNotifier); }   flexBox Component template 內程式內容：\n1 2 3 4 5 6 7  \u0026lt;!-- flexbox.component.html --\u0026gt; \u0026lt;div class=\u0026#34;button-container\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; mat-raised-button color=\u0026#34;primary\u0026#34; (click)=\u0026#34;getData(\u0026#39;success\u0026#39;)\u0026#34;\u0026gt;success\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; mat-raised-button color=\u0026#34;accent\u0026#34; (click)=\u0026#34;getData(\u0026#39;error\u0026#39;)\u0026#34;\u0026gt;error\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; mat-raised-button color=\u0026#34;primary\u0026#34; (click)=\u0026#34;showCustomSnackBar(\u0026#39;success\u0026#39;)\u0026#34;\u0026gt;Custom SnackBar\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; mat-raised-button color=\u0026#34;accent\u0026#34; (click)=\u0026#34;showCustomSnackBar(\u0026#39;error\u0026#39;)\u0026#34;\u0026gt;Custom SnackBar\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;   測試 客制化 Notifier 功能 以上是如何使用 snackBar 來實現 Notifier 功能。接下來繼續來完善我們的 Admin Template\n為 Admin Template 加入 Loading spinner 建立一個 Loading Service 使用 Cli 建立一個 service\n$ npx ng g s services/loading service 程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // loading.service.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { BehaviorSubject, delay, Observable, of, switchMap } from \u0026#39;rxjs\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class LoadingService { private _loading$ = new BehaviorSubject\u0026lt;boolean\u0026gt;(false); loading$: Observable\u0026lt;boolean\u0026gt; = this._loading$.pipe( switchMap(isLoading =\u0026gt; { if (!isLoading) { return of(false); } return of(true).pipe(delay(1000)); }) ) constructor() { } show() { this._loading$.next(true); } hide() { this._loading$.next(false); } }   建立一個 interceptor 透過 Angular Cli 來建立一個 Service，這個 service 的功能是在發出每 http request 時會先顯示 loading spinner，並在 request 完成後關閉 loading spinner。\n透過Angular cli 建立 interceptor\n$ npx ng g interceptor interceptors/loadingSpin interceptor 中的程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // loading－spin.interceptor.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor } from \u0026#39;@angular/common/http\u0026#39;; import { finalize, Observable } from \u0026#39;rxjs\u0026#39;; import { LoadingService } from \u0026#39;../services/loading.service\u0026#39;; @Injectable() export class LoadingSpinInterceptor implements HttpInterceptor { constructor(private loadingServie : LoadingService) {} intercept(request: HttpRequest\u0026lt;unknown\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;unknown\u0026gt;\u0026gt; { this.loadingServie.show(); return next.handle(request).pipe( finalize(()=\u0026gt; { this.loadingServie.hide(); }) ); } }   完成的 interceptor 必須在 app.module.ts 中先註冊\n1 2 3 4 5 6 7 8  // app.module.ts // ...  providers: [{ provide: HTTP_INTERCEPTORS, useClass: LoadingSpinInterceptor, multi: true }], bootstrap: [AppComponent]   在 Admin Template 加入 Loading spinner 把 Material Spinner ui component 加入到 NavigationComponent 中，以下程式碼放在程式最前頭：\n1 2 3 4 5  \u0026lt;!-- navigation.component.html --\u0026gt; \u0026lt;ng-container *ngIf=\u0026#34;loading$ | async\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;overlay\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;mat-spinner\u0026gt;\u0026lt;/mat-spinner\u0026gt; \u0026lt;/ng-container\u0026gt;   在 navigation.component.scss 加入以下 css 用來顯示 spinner，並鎖定畫面。\nmat-spinner { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 5; } .overlay { top: 0; bottom: 0; left: 0; right: 0; position: absolute; z-index: 2; backdrop-filter: blur(2px); } 並在 component class 中加入 loading$ 變數\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import { Component } from \u0026#39;@angular/core\u0026#39;; import { BreakpointObserver, Breakpoints } from \u0026#39;@angular/cdk/layout\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { map, shareReplay } from \u0026#39;rxjs/operators\u0026#39;; import { LoadingService } from \u0026#39;../services/loading.service\u0026#39;; @Component({ selector: \u0026#39;app-navigation\u0026#39;, templateUrl: \u0026#39;./navigation.component.html\u0026#39;, styleUrls: [\u0026#39;./navigation.component.scss\u0026#39;] }) export class NavigationComponent { isDarkTheme = false; loading$ = this._loadingService.loading$;  isHandset$: Observable\u0026lt;boolean\u0026gt; = this.breakpointObserver.observe(Breakpoints.Handset) .pipe( map(result =\u0026gt; result.matches), shareReplay() ); constructor(private breakpointObserver: BreakpointObserver， private _loadingService: LoadingService) {}  ngOnInit() { this.isDarkTheme = localStorage.getItem(\u0026#39;theme\u0026#39;) === \u0026#34;Dark\u0026#34; ? true : false; } storeThemeSelection() { localStorage.setItem(\u0026#39;theme\u0026#39;, this.isDarkTheme ? \u0026#34;Dark\u0026#34; : \u0026#34;Light\u0026#34;); } }   在 ShareMaterialModule 中要匯入/出 Progress Spinner Module 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; import { RouterModule } from \u0026#39;@angular/router\u0026#39;; import { NavigationComponent } from \u0026#39;../navigation/navigation.component\u0026#39;; import { LayoutModule } from \u0026#39;@angular/cdk/layout\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatSidenavModule } from \u0026#39;@angular/material/sidenav\u0026#39;; import { MatIconModule } from \u0026#39;@angular/material/icon\u0026#39;; import { MatListModule } from \u0026#39;@angular/material/list\u0026#39;; import { MatSlideToggleModule } from \u0026#39;@angular/material/slide-toggle\u0026#39;; import { MatSnackBarModule } from \u0026#39;@angular/material/snack-bar\u0026#39; import { MatProgressSpinnerModule } from \u0026#39;@angular/material/progress-spinner\u0026#39;  @NgModule({ declarations: [ NavigationComponent ], imports: [ CommonModule, FormsModule, LayoutModule, MatToolbarModule, MatButtonModule, MatSidenavModule, MatIconModule, MatListModule, MatSlideToggleModule, MatSnackBarModule, MatProgressSpinnerModule, RouterModule ], exports: [ NavigationComponent, MatButtonModule, MatProgressSpinnerModule  ] }) export class ShareMaterialModule { }   建立一個 發送 http request 來取得遠端資料的 Service 使用 cli 建立一個具有發送 http request 的 service\n   程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; import { Injectable } from \u0026#39;@angular/core\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class GetDataService { constructor(private http: HttpClient) { } getData() { return this.http.get(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;); } }   建立一個測試 Spinner 功能的元件 使 cli 來建立一個可測試 Spinner 的元件：\n$ npx ng g c components/getData \u0026lt;!-- getData.Component.html --\u0026gt; \u0026lt;p\u0026gt;get-data works!\u0026lt;/p\u0026gt; \u0026lt;button mat-raised-button color=\u0026#34;primary\u0026#34; (click)=\u0026#34;getData()\u0026#34;\u0026gt;取得資料\u0026lt;/button\u0026gt; // getData.Component.html import { Component } from \u0026#39;@angular/core\u0026#39;; import { GetDataService } from \u0026#39;src/app/services/get-data.service\u0026#39;; @Component({ selector: \u0026#39;app-get-data\u0026#39;, templateUrl: \u0026#39;./get-data.component.html\u0026#39;, styleUrls: [\u0026#39;./get-data.component.scss\u0026#39;] }) export class GetDataComponent { data: unknown; constructor(private _getData: GetDataService) {} getData() { this._getData.getData().subscribe( data =\u0026gt; { this.data = data; }) } } 為 GetDataComponent 建立對應的 route\n// app.module.ts  const routes: Routes = [ { path: \u0026#39;flexbox\u0026#39;, component: FlexboxComponent }, { path: \u0026#39;getdata\u0026#39;, component: GetDataComponent } ]; 測試 Spinner 功能 為測試 Spinner 功能，我們要讓網路連線速度下降。可以透過使用 chrome 開發者工具中的 network 功能中的：Disable cash \u0026amp; throttling 來進行模擬。\n執行程式開啟瀏覽器後先按 F12 來開啟開發者工具，切換到 Network 功能區，先勾選“Disable cache\u0026quot;選項\n接著下拉 Throttling 選項，點選最下面的 \u0026ldquo;Add\u0026rdquo;\n再點選 “Add custom profile\u0026quot;\n建立一個 20Mbps 的連線設定檔\n測試結果：\n最後我們還可以在 LoadingSpinInterceptor 中加入 Notifier 來顯示資料已讀取完成的訊息。\n1 2 3 4 5 6 7 8 9 10  intercept(request: HttpRequest\u0026lt;unknown\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;unknown\u0026gt;\u0026gt; { this.loadingServie.show(); return next.handle(request).pipe( finalize(()=\u0026gt; { this.loadingServie.hide(); this.notifier.showCustomNotification(\u0026#39;資料讀成完成！\u0026#39;, \u0026#39;ok\u0026#39;, \u0026#39;success\u0026#39;)  }) ); }   使用 material 實現一個 Login page 現在我們 Admin Template 所具備的功能已越來越完整，在本篇筆記最後，要再使用 Material 相關 UI 來建立一個系統登入的功能畫面。\n使用 angular cli 來新增個 login component 的框架\n$ npx ng g c components/login 在 ShareMaterialModule 匯入相關的 Material Module 先在 ShareMaterialModule 匯入相關的 Material Module: MatIconModule、MatCardModule、MatInputModule等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // share-material.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; import { RouterModule } from \u0026#39;@angular/router\u0026#39;; import { NavigationComponent } from \u0026#39;../navigation/navigation.component\u0026#39;; import { LayoutModule } from \u0026#39;@angular/cdk/layout\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatSidenavModule } from \u0026#39;@angular/material/sidenav\u0026#39;; import { MatIconModule } from \u0026#39;@angular/material/icon\u0026#39;; import { MatListModule } from \u0026#39;@angular/material/list\u0026#39;; import { MatSlideToggleModule } from \u0026#39;@angular/material/slide-toggle\u0026#39;; import { MatSnackBarModule } from \u0026#39;@angular/material/snack-bar\u0026#39; import { MatProgressSpinnerModule } from \u0026#39;@angular/material/progress-spinner\u0026#39;; import { MatCardModule } from \u0026#39;@angular/material/card\u0026#39;; import { MatInputModule } from \u0026#39;@angular/material/input\u0026#39;; @NgModule({ declarations: [ NavigationComponent ], imports: [ CommonModule, FormsModule, LayoutModule, MatToolbarModule, MatButtonModule, MatSidenavModule, MatIconModule, MatListModule, MatSlideToggleModule, MatSnackBarModule, MatProgressSpinnerModule, RouterModule ], exports: [ NavigationComponent, MatButtonModule, MatProgressSpinnerModule, MatIconModule, MatCardModule, MatInputModule  ] }) export class ShareMaterialModule { }   Component Class 中的程式碼 LoginComponent Class 程式碼中使用到 Reactive Forms，記得要在 app.module.ts 中匯入 ReactiveFormsModule。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // login.component.ts import { Component } from \u0026#39;@angular/core\u0026#39;; import { FormBuilder, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-login\u0026#39;, templateUrl: \u0026#39;./login.component.html\u0026#39;, styleUrls: [\u0026#39;./login.component.scss\u0026#39;] }) export class LoginComponent { hide: boolean = false; constructor(private fb: FormBuilder) { } ngOnInit() { } loginForm: FormGroup = this.fb.group({ email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]], password: [\u0026#39;\u0026#39;, [Validators.required, Validators.minLength(6)]] }) onLogin() { if (!this.loginForm.valid) { return; } console.log(this.loginForm.value); } }   login Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  \u0026lt;!-- login.components.html --\u0026gt; \u0026lt;mat-card\u0026gt; \u0026lt;mat-card-content\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;P\u0026gt;Sign Into Your Account \u0026lt;/P\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form (ngSubmit)=\u0026#34;onLogin()\u0026#34; name=\u0026#34;loginForm\u0026#34; [formGroup]=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;emailInput\u0026#34;\u0026gt; \u0026lt;mat-form-field class=\u0026#34;full-width\u0026#34; appearance=\u0026#34;outline\u0026#34;\u0026gt; \u0026lt;mat-label\u0026gt;Email\u0026lt;/mat-label\u0026gt; \u0026lt;input formControlName=\u0026#34;email\u0026#34; matInput placeholder=\u0026#34;Enter email address\u0026#34; required /\u0026gt; \u0026lt;mat-error *ngIf=\u0026#34;!loginForm.controls[\u0026#39;email\u0026#39;].valid\u0026#34;\u0026gt; Email is required \u0026lt;/mat-error\u0026gt; \u0026lt;/mat-form-field\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt; \u0026lt;a class=\u0026#34;text-link\u0026#34; class=\u0026#34;aLink\u0026#34; routerLink=\u0026#34;/auth/forgot-password\u0026#34;\u0026gt;Forgot Password?\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;mat-form-field class=\u0026#34;full-width\u0026#34; appearance=\u0026#34;outline\u0026#34;\u0026gt; \u0026lt;mat-label\u0026gt;Password\u0026lt;/mat-label\u0026gt; \u0026lt;input formControlName=\u0026#34;password\u0026#34; matInput [type]=\u0026#34; hide ? \u0026#39;password\u0026#39; : \u0026#39;text\u0026#39;\u0026#34; required /\u0026gt; \u0026lt;button mat-icon-button matSuffix (click)=\u0026#34;hide = !hide\u0026#34; [attr.aria-label]=\u0026#34;\u0026#39;Hide Password\u0026#39;\u0026#34; [attr.aria-pressed]=\u0026#34;hide\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt; {{hide ? \u0026#39;visibility_off\u0026#39; : \u0026#39;visibility\u0026#39;}} \u0026lt;/mat-icon\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;mat-error *ngIf=\u0026#34;!loginForm.controls[\u0026#39;password\u0026#39;].valid\u0026#34;\u0026gt; Password is required \u0026lt;/mat-error\u0026gt; \u0026lt;/mat-form-field\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button mat-flat-button color=\u0026#34;primary\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;button-row\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Create New Account\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/mat-card-content\u0026gt; \u0026lt;/mat-card\u0026gt;   使用 CSS 來美化 Login Form 外觀 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  /* login.components.scss */ mat-card { max-width: 600px; margin: 2em auto; text-align: center; max-height: 600px; } .header { text-align: center; } .full-width { width: 80%; } .button-row { padding-top: 5px; } .button-row a { margin-right: 8px; text-align: center; } .forget-password { padding-left: 0px; } .emailInput { padding-top: 10px; } .contentBody { padding: 60px 1rem; background: #1b6ca8; display: block; } .aLink { float: right; padding-right: 60px; text-decoration: none; }   在 AppModule 中匯入使用到的 Module 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // app.module.ts // ... import { ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;; // ...  imports: [ BrowserModule, AppRoutingModule, BrowserAnimationsModule, ShareMaterialModule, HttpClientModule, ReactiveFormsModule  ], // ...   設定 login form route 在 AppRoutingModule 中加入 Route 的設定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { FlexboxComponent } from \u0026#39;./components/flexbox/flexbox.component\u0026#39;; import { GetDataComponent } from \u0026#39;./components/get-data/get-data.component\u0026#39;; import { LoginComponent } from \u0026#39;./components/login/login.component\u0026#39;; const routes: Routes = [ { path: \u0026#39;flexbox\u0026#39;, component: FlexboxComponent }, { path: \u0026#39;getdata\u0026#39;, component: GetDataComponent }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   測試 直接在瀏覽器 URL 輸入： http://localhost:4200/login，會見到如下圖\n雖然 Login Form 已可以順利的呈現，但可以看出來有一個問題：它嵌套在 Navigator 中，感覺是不是有點怪。接下來我們就來調整一下，讓 Login Form “獨立”出來，不要嵌套在 Navigator 中。\n首先先調整一下 Route 的設定:\n// app-routing.module.ts import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { FlexboxComponent } from './components/flexbox/flexbox.component'; import { GetDataComponent } from './components/get-data/get-data.component'; import { LoginComponent } from './components/login/login.component'; import { NavigationComponent } from './navigation/navigation.component'; const routes: Routes = [ { path: '', component: NavigationComponent, children: [ { path: '', redirectTo: 'flexbox', pathMatch: 'full'}, { path: 'flexbox', component: FlexboxComponent }, { path: 'getdata', component: GetDataComponent }, ] }, { path: 'login', component: LoginComponent, // canActivate: [NonAuthGuard] }, ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { } 再來修改 app.component.html\n\u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; 結果:\n完工!!\n","permalink":"https://calvinegs.github.io/posts/angular-material-adminui-ii/","summary":"github Source code\n註: 若只要取得本篇筆記所介紹的內容可使用以下指令: “git clone --branch v2.0 https://github.com/calvinegs/Angular_Material_Admin_Template.git”\n在本篇筆記中將繼續使用 Angular Material 中的其他 components 來加強 Admin Template。在此文中除了會使用 SnackBar component 來實做一個 Notifier ，同時也把之前介紹過的 Loading Spnner 功能也一併加入。\n除此之外也會建置一個 Login Page，身份驗證是一個應用程式中不可缺少的功能，有了這個登入畫面，將會被應用到另一篇 angular Interceptor - JWT 的應用中（待續）。\n有關 Admin Template 第一個版本的介紹請見 Loding Spinner\n加強 Admin Template 功能 預計實現的功能：\n使用 Angular Material SnackBar 為 Admin Template 加入 Notifier 功能。 使用以下步驟：\n 取得 Admin Template 第一個版本程式碼 實現基本版本 Notifier 實現客制化 Notifier 功能 使用 material 實現一個 Login Page  取得 Admin Template 第一個版本程式碼 首先要為 Admin Template 第一個版本加入 Notifier 功能，可以使用 ｀git clone｀指令取得特定版程式碼。以下指令是取得 Tag為 ver-1.","title":"使用 Angular Material 建立一個簡易的 Admin Template II"},{"content":"github Source code\n使用 Angular Material 建立一個簡易的 Admin Template Angular 是一個標準的 SPA App framework，今天要記錄的是使用 angular material 來建立一個 SPA App 的範本，除了介紹 Material 相關的功能外，完成的這個簡易型 admin template 剛好可以用來引申後續 angular 筆記範例中的㮒準介面(UI).\n想要得到的結果：\n檢視環境 在開發環境中必須有 NodeJs\n$ node -v v18.12.1 angular cli 則只需安裝在 Local 目錄中即可 ng version\n$ ng version Command \u0026#39;ng\u0026#39; not found, but can be installed with: sudo apt install ng-common 建立 Angular 專案 透過 npm init @angular 語法即可在不必安裝 angular cli 前題下來建立一個 angular project。\n下述語法中的 \u0026lt;project Name\u0026gt; 替換成實際的專案名稱（如：adminTemplate)\n$ npm init @angular \u0026lt;project Name\u0026gt; -- --routing --style=scss \u0026amp;\u0026amp; cd \u0026lt;project Name\u0026gt; CREATE adminTest/README.md (1063 bytes) CREATE adminTest/.editorconfig (274 bytes) CREATE adminTest/.gitignore (548 bytes) CREATE adminTest/angular.json (2934 bytes) CREATE adminTest/package.json (1041 bytes) CREATE adminTest/tsconfig.json (901 bytes) CREATE adminTest/tsconfig.app.json (263 bytes) CREATE adminTest/tsconfig.spec.json (273 bytes) CREATE adminTest/.vscode/extensions.json (130 bytes) CREATE adminTest/.vscode/launch.json (474 bytes) CREATE adminTest/.vscode/tasks.json (938 bytes) CREATE adminTest/src/favicon.ico (948 bytes) CREATE adminTest/src/index.html (295 bytes) CREATE adminTest/src/main.ts (214 bytes) CREATE adminTest/src/styles.scss (80 bytes) CREATE adminTest/src/assets/.gitkeep (0 bytes) CREATE adminTest/src/app/app-routing.module.ts (245 bytes) CREATE adminTest/src/app/app.module.ts (393 bytes) CREATE adminTest/src/app/app.component.scss (0 bytes) CREATE adminTest/src/app/app.component.html (23115 bytes) CREATE adminTest/src/app/app.component.spec.ts (1082 bytes) CREATE adminTest/src/app/app.component.ts (214 bytes) ✔ Packages installed successfully. Successfully initialized git. 建立成功後可使用 npx ng version 來檢視專案中使用的 angular cli 版本。\n$ npx ng version _ _ ____ _ ___ / \\  _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 15.0.5 Node: 18.12.1 Package Manager: npm 8.19.2 OS: linux x64 Angular: 15.1.4 ... animations, common, compiler, compiler-cli, core, forms ... platform-browser, platform-browser-dynamic, router Package Version --------------------------------------------------------- @angular-devkit/architect 0.1501.5 @angular-devkit/build-angular 15.1.5 @angular-devkit/core 15.1.5 @angular-devkit/schematics 15.0.5 @angular/cli 15.0.5 @schematics/angular 15.0.5 rxjs 7.5.7 typescript 4.8.4 安裝 Angular Material 使用 ng add @angular/material 指令來為專案設置要使用 Material ui component 的相關環境。(安裝 Angular Material、Component Dev Kit (CDK) 和 Angular Animations 及引用字型\u0026hellip;等)\n$ npx ng add @angular/material ℹ Using package manager: npm ✔ Found compatible package version: @angular/material@15.1.4. ✔ Package information loaded. The package @angular/material@15.1.4 will be installed and executed. Would you like to proceed? Yes ✔ Packages successfully installed. ? Choose a prebuilt theme name, or \u0026#34;custom\u0026#34; for a custom theme: Custom ? Set up global Angular Material typography styles? Yes ? Include the Angular animations module? Include and enable animations UPDATE package.json (1111 bytes) ✔ Packages installed successfully. CREATE src/custom-theme.scss (1479 bytes) UPDATE src/app/app.module.ts (502 bytes) UPDATE angular.json (2819 bytes) UPDATE src/index.html (581 bytes) UPDATE src/styles.css (181 bytes) 加入 git 新版本\n$ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add Material to project\u0026#34; 建立一個專屬的 module file 為使專案管理方便，先建立一個 material 專屬的 module file.\n$ npx ng g m ./shared/shareMaterial --flat 由上述 angular cli 所産生的 share-material.module.ts 檔案\n1 2 3 4 5 6 7 8 9 10 11 12  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; @NgModule({ declarations: [], imports: [ CommonModule ] }) export class ShareMaterialModuleModule { }   使用 material 所附加的 schematics 來建立 admin template ui 下述語法中的參數 --module ./shared/share-material，為的是將新産生的 material navigation compoent 産生在 share-material module 中。\n$ npx ng g @angular/material:navigation navigation --module ./shared/share-material 註：除上述的 @angular/material:navigation 外，還有：\n address-form dashboard table tree  使用 @angular/material:navigation schematics 除了産生 navigation component 外，也會自動在 module file (share-material.module.ts) 中自動引中必需的 module\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { NavigationComponent } from \u0026#39;../navigation/navigation.component\u0026#39;; import { LayoutModule } from \u0026#39;@angular/cdk/layout\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatSidenavModule } from \u0026#39;@angular/material/sidenav\u0026#39;; import { MatIconModule } from \u0026#39;@angular/material/icon\u0026#39;; import { MatListModule } from \u0026#39;@angular/material/list\u0026#39;; import { MatSlideToggleModule } from \u0026#39;@angular/material/slide-toggle\u0026#39;; import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; @NgModule({ declarations: [ NavigationComponent ], imports: [ CommonModule, FormsModule, LayoutModule, MatToolbarModule, MatButtonModule, MatSidenavModule, MatIconModule, MatListModule, MatSlideToggleModule ], exports: [ NavigationComponent ] }) export class ShareMaterialModule { }   把 ShareMaterialModule 匯入到 app.module.ts 檔案中 為了在專案其他地方(如：AppComponent中）使用 NavidationComponent，不要忘記在 app.module.ts 中引入 ShareMaterialModule module。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # app.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { BrowserAnimationsModule } from \u0026#39;@angular/platform-browser/animations\u0026#39;; import { ShareMaterialModule } from \u0026#39;./shared/share-material.module\u0026#39;;  @NgModule({ declarations: [ AppComponent, ], imports: [ BrowserModule, AppRoutingModule, BrowserAnimationsModule,  ShareMaterialModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }   把 NavigationComponent export 出去 同時為了在 AppComponent 中使用 NavigationComponent，也別忘了把 NavidationComponent export 出去。\nshare-material.module.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { NavigationComponent } from \u0026#39;../navigation/navigation.component\u0026#39;; import { LayoutModule } from \u0026#39;@angular/cdk/layout\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatSidenavModule } from \u0026#39;@angular/material/sidenav\u0026#39;; import { MatIconModule } from \u0026#39;@angular/material/icon\u0026#39;; import { MatListModule } from \u0026#39;@angular/material/list\u0026#39;; @NgModule({ declarations: [ NavigationComponent ], imports: [ CommonModule, LayoutModule, MatToolbarModule, MatButtonModule, MatSidenavModule, MatIconModule, MatListModule, ], exports: [ NavigationComponent  ] }) export class ShareMaterialModule { }   修改 app.component.html 將內容刪除,並將 app-navigation selector 放進 app.component.html\n\u0026lt;app-navigation\u0026gt;\u0026lt;/app-navigation\u0026gt; 執行測試 使用 $ npm start 來查看一下結果。\n新增 Dark Theme (暗黑主題) 到目前為止，已經産生了一個陽春版的 admin template 了，接下來來豐富一下這個樣本的其他功能-新增一個｀暗黑主題｀。\n在 styles.scss 新增 Dark theme 相關設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* ... */ // for Dark Mode $adminTemplate-primary-dark: mat.define-palette(mat.$purple-palette); $adminTemplate-accent-dark: mat.define-palette(mat.$green-palette, A200, A100, A400); $adminTemplate-warn-dark: mat.define-palette(mat.$red-palette); $adminTemplate-theme-dark: mat.define-dark-theme(( color: ( primary: $adminTemplate-primary-dark, accent: $adminTemplate-accent-dark, warn: $adminTemplate-warn-dark, ) )); .dark-theme-mode { @include mat.all-component-themes($adminTemplate-theme-dark); }   完成 CSS 中加入 Dark Theme 的設置後，先在 navigation.component.ts 中新增一個變數: isDarkTheme 用來記錄是否切換到 Dark 主題。\nnavigation.component.html 中的相關設置 並在 navigation.component.html 中透過 ngClass 語法加入設置好的 dark theme。\n\u0026lt;mat-sidenav-container class=\u0026#34;sidenav-container mat-app-background\u0026#34; [ngClass]=\u0026#34;{\u0026#39;dark-theme-mode\u0026#39;:isDarkTheme}\u0026#34;\u0026gt; 接著繼續在 html 中加入一個可切換的開關 component: mat-slide-toggle 並透過 ngModel 綁定到 isDarkTheme 變數\n\u0026lt;mat-slide-toggle [(ngModel)]=\u0026#34;isDarkTheme\u0026#34;\u0026gt;\u0026lt;/mat-slide-toggle\u0026gt; share-material.module.ts 要匯入相關 module 要使用 mat-slide-toggle component 必須在 module file 中 import MatSlideToggleModule\n# share-material.module.ts \u0026lt;!-- ... --\u0026gt; import { MatSlideToggleModule } from \u0026#39;@angular/material/slide-toggle\u0026#39;; \u0026lt;!-- ... --\u0026gt; imports:[ ... MatSlideToggleModule ], // ... 由於使用到了 [(ngModel)]，所以必須在 module file 中 import FormsModule\n# share-material.module.ts // ... import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; // ...  imports:[ // ... \tFormsModule ], // ... 完成後的 navigation.component.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;mat-sidenav-container class=\u0026#34;sidenav-container mat-app-background\u0026#34; [ngClass]=\u0026#34;{\u0026#39;dark-theme-mode\u0026#39;:isDarkTheme}\u0026#34;\u0026gt; \u0026lt;mat-sidenav #drawer class=\u0026#34;sidenav\u0026#34; fixedInViewport [attr.role]=\u0026#34;(isHandset$ | async) ? \u0026#39;dialog\u0026#39; : \u0026#39;navigation\u0026#39;\u0026#34; [mode]=\u0026#34;(isHandset$ | async) ? \u0026#39;over\u0026#39; : \u0026#39;side\u0026#39;\u0026#34; [opened]=\u0026#34;(isHandset$ | async) === false\u0026#34;\u0026gt; \u0026lt;mat-toolbar\u0026gt;Menu\u0026lt;/mat-toolbar\u0026gt; \u0026lt;mat-nav-list\u0026gt; \u0026lt;a mat-list-item href=\u0026#34;#\u0026#34;\u0026gt;Link 1\u0026lt;/a\u0026gt; \u0026lt;a mat-list-item href=\u0026#34;#\u0026#34;\u0026gt;Link 2\u0026lt;/a\u0026gt; \u0026lt;a mat-list-item href=\u0026#34;#\u0026#34;\u0026gt;Link 3\u0026lt;/a\u0026gt; \u0026lt;/mat-nav-list\u0026gt; \u0026lt;/mat-sidenav\u0026gt; \u0026lt;mat-sidenav-content\u0026gt; \u0026lt;mat-toolbar color=\u0026#34;primary\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; aria-label=\u0026#34;Toggle sidenav\u0026#34; mat-icon-button (click)=\u0026#34;drawer.toggle()\u0026#34; *ngIf=\u0026#34;isHandset$ | async\u0026#34;\u0026gt; \u0026lt;mat-icon aria-label=\u0026#34;Side nav toggle icon\u0026#34;\u0026gt;menu\u0026lt;/mat-icon\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;adminTest\u0026lt;/span\u0026gt; \u0026lt;mat-slide-toggle [(ngModel)]=\u0026#34;isDarkTheme\u0026#34;\u0026gt;\u0026lt;/mat-slide-toggle\u0026gt; \u0026lt;/mat-toolbar\u0026gt; \u0026lt;!-- Add Content Here --\u0026gt; \u0026lt;/mat-sidenav-content\u0026gt; \u0026lt;/mat-sidenav-container\u0026gt;   完成後的 navigation.component.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import { Component } from \u0026#39;@angular/core\u0026#39;; import { BreakpointObserver, Breakpoints } from \u0026#39;@angular/cdk/layout\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { map, shareReplay } from \u0026#39;rxjs/operators\u0026#39;; @Component({ selector: \u0026#39;app-navigation\u0026#39;, templateUrl: \u0026#39;./navigation.component.html\u0026#39;, styleUrls: [\u0026#39;./navigation.component.scss\u0026#39;] }) export class NavigationComponent { isDarkTheme= false; isHandset$: Observable\u0026lt;boolean\u0026gt; = this.breakpointObserver.observe(Breakpoints.Handset) .pipe( map(result =\u0026gt; result.matches), shareReplay() ); constructor(private breakpointObserver: BreakpointObserver) {} }   完成後的 share-material.module.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { NavigationComponent } from \u0026#39;../navigation/navigation.component\u0026#39;; import { LayoutModule } from \u0026#39;@angular/cdk/layout\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatSidenavModule } from \u0026#39;@angular/material/sidenav\u0026#39;; import { MatIconModule } from \u0026#39;@angular/material/icon\u0026#39;; import { MatListModule } from \u0026#39;@angular/material/list\u0026#39;; import { MatSlideToggleModule } from \u0026#39;@angular/material/slide-toggle\u0026#39;; import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; @NgModule({ declarations: [ NavigationComponent ], imports: [ CommonModule, FormsModule, LayoutModule, MatToolbarModule, MatButtonModule, MatSidenavModule, MatIconModule, MatListModule, MatSlideToggleModule ], exports: [ NavigationComponent ] }) export class ShareMaterialModule { }   測試結果 執行 $ npm start 來看一下結果\n程式已經可以透過開關來切換不同的主題。\n優化 UI 接著，將 UI 再優化一下，把開關移至畫面右側，並於開關前面顯示一個圖示，分別表示套用了不同的主題。\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;span class=\u0026#34;ext-space\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div *ngIf=\u0026#34;this.isDarkTheme; else LightTheme\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt;bedtime\u0026lt;/mat-icon\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ng-template #LightTheme\u0026gt; \u0026lt;div *ngIf=\u0026#34;!this.isDarkTheme\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt;wb_sunny\u0026lt;/mat-icon\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;mat-slide-toggle [(ngModel)]=\u0026#34;isDarkTheme\u0026#34;\u0026gt; \u0026lt;/mat-slide-toggle\u0026gt;   在 navigation.component.scss 加入下列的設定，為的是將 slide-toggle 元件顯示在畫面右側\n/* ... */ .ext-space { flex: 1 0 auto; } 看結果發現畫面已符合預期：\n將開關切換的狀態記錄下來 當在瀏覽器上按下 F5 時會發現套用 Dark Theme 不會被程式記著，開關又回復到原有的狀態。繼續調整程式把切換結果記錄到 localstorage 中。\n\u0026lt;mat-slide-toggle [(ngModel)]=\u0026#34;isDarkTheme\u0026#34; (change)=\u0026#34;storeThemeSelection()\u0026#34;\u0026gt; 在 navigation.component.ts 加入相關程式碼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import { Component } from \u0026#39;@angular/core\u0026#39;; import { BreakpointObserver, Breakpoints } from \u0026#39;@angular/cdk/layout\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { map, shareReplay } from \u0026#39;rxjs/operators\u0026#39;; @Component({ selector: \u0026#39;app-navigation\u0026#39;, templateUrl: \u0026#39;./navigation.component.html\u0026#39;, styleUrls: [\u0026#39;./navigation.component.scss\u0026#39;] }) export class NavigationComponent { isDarkTheme = false; isHandset$: Observable\u0026lt;boolean\u0026gt; = this.breakpointObserver.observe(Breakpoints.Handset) .pipe( map(result =\u0026gt; result.matches), shareReplay() ); constructor(private breakpointObserver: BreakpointObserver) {} ngOnInit() { this.isDarkTheme = localStorage.getItem(\u0026#39;theme\u0026#39;) === \u0026#34;Dark\u0026#34; ? true : false; } storeThemeSelection() { localStorage.setItem(\u0026#39;theme\u0026#39;, this.isDarkTheme ? \u0026#34;Dark\u0026#34; : \u0026#34;Light\u0026#34;); } }   再次測試發現開關切換的結果會被記錄下來了。admin template 至此已算完成。下面來看看如何使用這個樣本範例。\n使用 admin template 建立新組件 Components 使用 angular cli 來産生一個新元件：$ npx ng g c components/flexbox\n設置 routes 在 app-routing.module.ts 中加入 routes 相關設定\nconst routes: Routes = [{ path: \u0026#39;flexbox\u0026#39;, component: FlexboxComponent }]; 在 html 中加入 router-outlet 在 navigation.component.html 中加入 router-outlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  \u0026lt;mat-sidenav-container class=\u0026#34;sidenav-container mat-app-background\u0026#34; [ngClass]=\u0026#34;{\u0026#39;dark-theme-mode\u0026#39;:isDarkTheme}\u0026#34;\u0026gt; \u0026lt;mat-sidenav #drawer class=\u0026#34;sidenav\u0026#34; fixedInViewport [attr.role]=\u0026#34;(isHandset$ | async) ? \u0026#39;dialog\u0026#39; : \u0026#39;navigation\u0026#39;\u0026#34; [mode]=\u0026#34;(isHandset$ | async) ? \u0026#39;over\u0026#39; : \u0026#39;side\u0026#39;\u0026#34; [opened]=\u0026#34;(isHandset$ | async) === false\u0026#34;\u0026gt; \u0026lt;mat-toolbar\u0026gt;Menu\u0026lt;/mat-toolbar\u0026gt; \u0026lt;mat-nav-list\u0026gt; \u0026lt;a mat-list-item href=\u0026#34;#\u0026#34;\u0026gt;Link 1\u0026lt;/a\u0026gt; \u0026lt;a mat-list-item href=\u0026#34;#\u0026#34;\u0026gt;Link 2\u0026lt;/a\u0026gt; \u0026lt;a mat-list-item href=\u0026#34;#\u0026#34;\u0026gt;Link 3\u0026lt;/a\u0026gt; \u0026lt;/mat-nav-list\u0026gt; \u0026lt;/mat-sidenav\u0026gt; \u0026lt;mat-sidenav-content\u0026gt; \u0026lt;mat-toolbar color=\u0026#34;primary\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; aria-label=\u0026#34;Toggle sidenav\u0026#34; mat-icon-button (click)=\u0026#34;drawer.toggle()\u0026#34; *ngIf=\u0026#34;isHandset$ | async\u0026#34;\u0026gt; \u0026lt;mat-icon aria-label=\u0026#34;Side nav toggle icon\u0026#34;\u0026gt;menu\u0026lt;/mat-icon\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;adminTest\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;ext-space\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div *ngIf=\u0026#34;this.isDarkTheme; else LightTheme\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt;bedtime\u0026lt;/mat-icon\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ng-template #LightTheme\u0026gt; \u0026lt;div *ngIf=\u0026#34;!this.isDarkTheme\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt;wb_sunny\u0026lt;/mat-icon\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;mat-slide-toggle [(ngModel)]=\u0026#34;isDarkTheme\u0026#34; labelPosition=\u0026#34;before\u0026#34; \u0026gt; \u0026lt;/mat-slide-toggle\u0026gt; \u0026lt;/mat-toolbar\u0026gt; \u0026lt;!-- Add Content Here --\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; \u0026lt;/mat-sidenav-content\u0026gt; \u0026lt;/mat-sidenav-container\u0026gt;   匯入 RouterModule Module 由於在 html 中加入 router-outlet，所以必須在 share-material.module.ts 中匯入 RouterModule Module\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { NavigationComponent } from \u0026#39;../navigation/navigation.component\u0026#39;; import { LayoutModule } from \u0026#39;@angular/cdk/layout\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatSidenavModule } from \u0026#39;@angular/material/sidenav\u0026#39;; import { MatIconModule } from \u0026#39;@angular/material/icon\u0026#39;; import { MatListModule } from \u0026#39;@angular/material/list\u0026#39;; import { MatSlideToggleModule } from \u0026#39;@angular/material/slide-toggle\u0026#39;; import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; import { RouterModule } from \u0026#39;@angular/router\u0026#39;; @NgModule({ declarations: [ NavigationComponent ], imports: [ CommonModule, FormsModule, LayoutModule, MatToolbarModule, MatButtonModule, MatSidenavModule, MatIconModule, MatListModule, MatSlideToggleModule, RouterModule ], exports: [ NavigationComponent ] }) export class ShareMaterialModule { }   測試 routes 是否設定正確, 直接在瀏覽器輸入 localhost:4200/flexbox\n結果顯示 routes 設置無誤，接下去來完成 route-link 的設置。\nroute-link 設置 在 navigation.component.html file 中加入 route-link 到 list 上: \u0026lt;a mat-list-item routerLink=\u0026quot;/flexbox\u0026quot;\u0026gt;flex box\u0026lt;/a\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  \u0026lt;mat-sidenav-container class=\u0026#34;sidenav-container mat-app-background\u0026#34; [ngClass]=\u0026#34;{\u0026#39;dark-theme-mode\u0026#39;:isDarkTheme}\u0026#34;\u0026gt; \u0026lt;mat-sidenav #drawer class=\u0026#34;sidenav\u0026#34; fixedInViewport [attr.role]=\u0026#34;(isHandset$ | async) ? \u0026#39;dialog\u0026#39; : \u0026#39;navigation\u0026#39;\u0026#34; [mode]=\u0026#34;(isHandset$ | async) ? \u0026#39;over\u0026#39; : \u0026#39;side\u0026#39;\u0026#34; [opened]=\u0026#34;(isHandset$ | async) === false\u0026#34;\u0026gt; \u0026lt;mat-toolbar\u0026gt;功能列\u0026lt;/mat-toolbar\u0026gt; \u0026lt;mat-nav-list\u0026gt; \u0026lt;a mat-list-item routerLink=\u0026#34;/flexbox\u0026#34;\u0026gt;flex box\u0026lt;/a\u0026gt; \u0026lt;a mat-list-item href=\u0026#34;#\u0026#34;\u0026gt;Link 2\u0026lt;/a\u0026gt; \u0026lt;a mat-list-item href=\u0026#34;#\u0026#34;\u0026gt;Link 3\u0026lt;/a\u0026gt; \u0026lt;/mat-nav-list\u0026gt; \u0026lt;/mat-sidenav\u0026gt; \u0026lt;mat-sidenav-content\u0026gt; \u0026lt;mat-toolbar color=\u0026#34;primary\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; aria-label=\u0026#34;Toggle sidenav\u0026#34; mat-icon-button (click)=\u0026#34;drawer.toggle()\u0026#34; *ngIf=\u0026#34;isHandset$ | async\u0026#34;\u0026gt; \u0026lt;mat-icon aria-label=\u0026#34;Side nav toggle icon\u0026#34;\u0026gt;menu\u0026lt;/mat-icon\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;簡易的 admin template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;ext-space\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div *ngIf=\u0026#34;this.isDarkTheme; else LightTheme\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt;bedtime\u0026lt;/mat-icon\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ng-template #LightTheme\u0026gt; \u0026lt;div *ngIf=\u0026#34;!this.isDarkTheme\u0026#34;\u0026gt; \u0026lt;mat-icon\u0026gt;wb_sunny\u0026lt;/mat-icon\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;mat-slide-toggle [(ngModel)]=\u0026#34;isDarkTheme\u0026#34; (change)=\u0026#34;storeThemeSelection()\u0026#34;\u0026gt; \u0026lt;/mat-slide-toggle\u0026gt; \u0026lt;/mat-toolbar\u0026gt; \u0026lt;!-- Add Content Here --\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; \u0026lt;/mat-sidenav-content\u0026gt; \u0026lt;/mat-sidenav-container\u0026gt;   ","permalink":"https://calvinegs.github.io/posts/angular-material-adminui/","summary":"github Source code\n使用 Angular Material 建立一個簡易的 Admin Template Angular 是一個標準的 SPA App framework，今天要記錄的是使用 angular material 來建立一個 SPA App 的範本，除了介紹 Material 相關的功能外，完成的這個簡易型 admin template 剛好可以用來引申後續 angular 筆記範例中的㮒準介面(UI).\n想要得到的結果：\n檢視環境 在開發環境中必須有 NodeJs\n$ node -v v18.12.1 angular cli 則只需安裝在 Local 目錄中即可 ng version\n$ ng version Command \u0026#39;ng\u0026#39; not found, but can be installed with: sudo apt install ng-common 建立 Angular 專案 透過 npm init @angular 語法即可在不必安裝 angular cli 前題下來建立一個 angular project。","title":"使用 Angular Material 建立一個簡易的 Admin Template"},{"content":"使用 Docker 執行 MongoDb 在之前的筆記中　使用 Node.js + express 建立一個電子商務後端服務的 REST API　已有紀錄了使用 https://cloud.mongodb.com/ 線上的免費服務版本的 MonogoDb，本篇再把 Docker 版的 MongoDb 也一併紀錄下來。把如何使用 docker (docker compose) 來快速設置 MongoDb 及其管理工具 MongoDb Compass 的相關設定過程寫下來。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.23 API version: 1.41 Go version: go1.18.10 Git commit: 7155243 Built: Thu Jan 19 17:36:25 2023 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.23 API version: 1.41 (minimum version 1.12) Go version: go1.18.10 Git commit: 6051f14 Built: Thu Jan 19 17:34:14 2023 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.16 GitCommit: 31aa4358a36870b21a992d3ad2bef29e1d693bec runc: Version: 1.1.4 GitCommit: v1.1.4-0-g5fd4c4d docker-init: Version: 0.19.0 GitCommit: de40ad0 檢查是否已安裝了 docker compose $ docker compose version Docker Compose version v2.15.1 建置專案 目錄結構 $ mkdir mkdir mongodb \u0026amp;\u0026amp; cd mongodb $ touch init-mongo.js docker-compose.yml ./mongodb ├── docker-compose.yml └── init-mongo.js 建立 docker-compose.yml 在這個 compse command file 中指令與說明如下：\nversion: \u0026#39;3.8\u0026#39; services: db: container_name: mongo_db image: mongo restart: always environment: - MONGO_INITDB_DATABASE=mongo-db - MONGO_INITDB_ROOT_USERNAME=admin - MONGO_INITDB_ROOT_PASSWORD=\u0026lt;password\u0026gt; ports: - \u0026#39;27017-27019:27017-27019\u0026#39; volumes: - ./init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro # 設置環境的設定檔 - ./mongo-volume:/data/db　# 保存資料的目錄 建立 init-mongo.js 這用檔案的用途是給 docker compose 啟動時設置環境用。\ndb.createUser( { user : \u0026#34;admin\u0026#34;, pwd : \u0026#34;admin1911\u0026#34;, roles : [ { role : \u0026#34;readWrite\u0026#34;, db : \u0026#34;mongo-db\u0026#34; } ] } ) 執行 docker compose 上述的目錄與檔案內容準備完成後，在與 docker-compose.yml 的相同目錄中執行 docker compose up　-d來啟動 MongoDb Container Services，啟動成功後使用 ｀$ docker ps｀ 指令查看容器啟動狀況\n$ docker compose up -d # ... [+] Running 2/0 ⠿ Network mongodb_default Created 0.0s ⠿ Container mongo_db Created 0.0s Attaching to mongo_db ... 查看 docker 執行的情況\n$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9d3924dcd94e mongo \u0026#34;docker-entrypoint.s…\u0026#34; About a minute ago Up 12 seconds 0.0.0.0:27017-27019-\u0026gt;27017-27019/tcp, :::27017-27019-\u0026gt;27017-27019/tcp mongo_db 使用 MongoDb Compass 連結到 Mongo DB 打開 MongoDb Compass 應用程式\n第一次開啟時要設定 Connections String 後按下 Connect 按鈕。Connection String 格式如：mongodb://:@localhost:27017/?authMechanism=DEFAULT\n連結成功後，點選畫面下方的 \u0026lsquo;CREATE DATABASE\u0026rsquo;\n再輸入 Database Name　及 Collection Name(即 Document 或稱 Table Name)，按下\u0026quot;Create Database\u0026quot;\n資料庫及表單 建立完成，如下圖。\n新增資料 要新增資料到 Collection 中，按下\u0026quot;ADD DATA\u0026quot;按鈕，可選擇二種方式來進行\n Import File Insert Document  方法一　Import File 匯入檔案的格式可以是 Json 或 CSV\n方法二　Insert Document 可直接在此功能中輸入 JSON 格式資料來新增資料到 collection 中。\n[ { \u0026#34;imageName\u0026#34;: \u0026#34;offer1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;10% off on personal cares\u0026#34;, \u0026#34;handsetCols\u0026#34;: 2, \u0026#34;handsetRows\u0026#34;: 1, \u0026#34;webCols\u0026#34;: 2, \u0026#34;webRows\u0026#34;: 1 }, { \u0026#34;imageName\u0026#34;: \u0026#34;offer2\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Flash sales in Footwears\u0026#34;, \u0026#34;handsetCols\u0026#34;: 2, \u0026#34;handsetRows\u0026#34;: 1, \u0026#34;webCols\u0026#34;: 1, \u0026#34;webRows\u0026#34;: 1 }, { \u0026#34;imageName\u0026#34;: \u0026#34;offer3\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Extended warranty for Apple products\u0026#34;, \u0026#34;handsetCols\u0026#34;: 2, \u0026#34;handsetRows\u0026#34;: 1, \u0026#34;webCols\u0026#34;: 1, \u0026#34;webRows\u0026#34;: 2 }, { \u0026#34;imageName\u0026#34;: \u0026#34;offer4\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;5% discount for grocery\u0026#34;, \u0026#34;handsetCols\u0026#34;: 2, \u0026#34;handsetRows\u0026#34;: 1, \u0026#34;webCols\u0026#34;: 1, \u0026#34;webRows\u0026#34;: 1 } ] 新增成功畫面：\n資料庫的實際檔案存放在 Local 的 ./pgdbdata 目錄中 使用作業系統管理者權限來查看此目錄\n$ ls -al ./mongo-volume/ [總用量 528 drwxr-xr-x 5 systemd-coredump root 4096 2月 8 20:46 . drwxrwxr-x 3 egs egs 4096 2月 8 12:37 .. -rw------- 1 systemd-coredump root 86 2月 8 12:54 .bash_history -rw------- 1 systemd-coredump systemd-coredump 20480 2月 8 20:14 collection-0-3111193408736420755.wt -rw------- 1 systemd-coredump systemd-coredump 20480 2月 8 20:45 collection-0-5598796086185130121.wt -rw------- 1 systemd-coredump systemd-coredump 36864 2月 8 20:15 collection-2-3111193408736420755.wt -rw------- 1 systemd-coredump systemd-coredump 36864 2月 8 20:34 collection-4-3111193408736420755.wt -rw------- 1 systemd-coredump systemd-coredump 20480 2月 8 20:24 collection-7-3111193408736420755.wt drwx------ 2 systemd-coredump systemd-coredump 4096 2月 8 20:47 diagnostic.data -rw------- 1 systemd-coredump systemd-coredump 20480 2月 8 20:14 index-1-3111193408736420755.wt -rw------- 1 systemd-coredump systemd-coredump 20480 2月 8 20:45 index-1-5598796086185130121.wt -rw------- 1 systemd-coredump systemd-coredump 36864 2月 8 20:15 index-3-3111193408736420755.wt -rw------- 1 systemd-coredump systemd-coredump 36864 2月 8 20:34 index-5-3111193408736420755.wt -rw------- 1 systemd-coredump systemd-coredump 36864 2月 8 20:34 index-6-3111193408736420755.wt -rw------- 1 systemd-coredump systemd-coredump 20480 2月 8 12:37 index-8-3111193408736420755.wt -rw------- 1 systemd-coredump systemd-coredump 20480 2月 8 20:24 index-9-3111193408736420755.wt drwx------ 2 systemd-coredump systemd-coredump 4096 2月 8 20:14 journal -rw------- 1 systemd-coredump systemd-coredump 36864 2月 8 20:30 _mdb_catalog.wt drwx------ 3 systemd-coredump systemd-coredump 4096 2月 8 12:37 .mongodb -rw------- 1 systemd-coredump systemd-coredump 2 2月 8 20:14 mongod.lock -rw------- 1 systemd-coredump systemd-coredump 36864 2月 8 20:46 sizeStorer.wt -rw------- 1 systemd-coredump systemd-coredump 114 2月 8 12:37 storage.bson -rw------- 1 systemd-coredump systemd-coredump 50 2月 8 12:37 WiredTiger -rw------- 1 systemd-coredump systemd-coredump 4096 2月 8 20:14 WiredTigerHS.wt -rw------- 1 systemd-coredump systemd-coredump 21 2月 8 12:37 WiredTiger.lock -rw------- 1 systemd-coredump systemd-coredump 1475 2月 8 20:46 WiredTiger.turtle -rw------- 1 systemd-coredump systemd-coredump 86016 2月 8 20:46 WiredTiger.wt ","permalink":"https://calvinegs.github.io/posts/docker-mongodb/","summary":"使用 Docker 執行 MongoDb 在之前的筆記中　使用 Node.js + express 建立一個電子商務後端服務的 REST API　已有紀錄了使用 https://cloud.mongodb.com/ 線上的免費服務版本的 MonogoDb，本篇再把 Docker 版的 MongoDb 也一併紀錄下來。把如何使用 docker (docker compose) 來快速設置 MongoDb 及其管理工具 MongoDb Compass 的相關設定過程寫下來。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.23 API version: 1.41 Go version: go1.18.10 Git commit: 7155243 Built: Thu Jan 19 17:36:25 2023 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.","title":"使用 Docker 執行 MongoDb"},{"content":"github Source code\n除非你和我一樣是個‘老傢伙’，使用過 Angular ver 4.3 以前的版本，否則你一定會遇到它 - interceptor(攔截器)。接下來將用幾篇筆記把各種使用 interceptor 情境的範例給記錄下來。\nAngular Interceptor 可以用來作什麼用途呢\n 修改 HTTP Headers 修改 HTTP request body 設定 authentication/authorization token　（身份認證） 模擬 backend api 修改 HTTP response 處理 HTTP 錯誤 (HTTP Error Handlin) 顯示 Loading Spinner 格式化 JSON Responses 日誌記錄  首先先來看看如何使用 Interceptor 來完成一個當你在讀取後端資料時可在畫面上顯示一個“正在讀取中\u0026hellip;“的動畫效果，這可以讓使用者有良好的使用體驗。\n筆記最後要達的效果是，在按下“取得資料”按鈕時，由程式向後端 API 讀取資料，而在讀取完成前，畫面中的所有 UI (如：按鈕）都是呈現無作用的狀況，直到資料回傳完畢。同時如果“向後端 API 讀取資料”的作業時間小於一秒鐘，則不顯示 “讀取中\u0026hellip;\u0026quot; 這個動畫效果。\n建立 Angular 專案架構 使用 npm init @angular 語法來建立 Angular project\n1 2 3  $ npm init @angular loadingSpin -- --routing --style=scss $ cd loadingSpin $ code .   安裝 material component\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  $ npx ng add @angular/material  ℹ Using package manager: npm ✔ Found compatible package version: @angular/material@15.1.2. ✔ Package information loaded. The package @angular/material@15.1.2 will be installed and executed. Would you like to proceed? Yes ✔ Packages successfully installed. ? Choose a prebuilt theme name, or \u0026#34;custom\u0026#34; for a custom theme: Indigo/Pink [ Preview: https://material.angular.io?theme=indigo-pink ] ? Set up global Angular Material typography styles? No ? Include the Angular animations module? Include and enable animations UPDATE package.json (1108 bytes) ✔ Packages installed successfully. UPDATE src/app/app.module.ts (502 bytes) UPDATE angular.json (3077 bytes) UPDATE src/index.html (556 bytes) UPDATE src/styles.scss (181 bytes)   使用 @angular/material component 來建立 UI 在使用 material component 之前，先在 app.module 中 import 要使用的 UI component，如: Toolbar、Button、Progress Spinner等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  # app.module.ts {linenos=table} import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { BrowserAnimationsModule } from \u0026#39;@angular/platform-browser/animations\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatProgressSpinnerModule } from \u0026#39;@angular/material/progress-spinner\u0026#39;; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, BrowserAnimationsModule, MatToolbarModule, MatButtonModule, MatProgressSpinnerModule  ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }   在 app.component.html 中，建立一個表頭、二個按鈕、及放入 material spinner（用來顯示正在處理中的動畫圖示） 組件。\n1 2 3 4 5 6 7 8 9 10  \u0026lt;!-- app.component.html --\u0026gt; \u0026lt;mat-toolbar color=\u0026#34;primary\u0026#34;\u0026gt; 使用 RxJS and HttpInterceptor 來實現 \u0026#34;資料讀取中...\u0026#34; 動畫效果的功能 \u0026lt;/mat-toolbar\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;button mat-raised-button (click)=\u0026#34;showSpinner()\u0026#34;\u0026gt;顯示\u0026lt;/button\u0026gt; \u0026lt;button mat-raised-button color=\u0026#34;warn\u0026#34; (click)=\u0026#34;hideSpinner()\u0026#34;\u0026gt;隐蔵\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;mat-spinner *ngIf=\u0026#34;loading\u0026#34;\u0026gt;\u0026lt;/mat-spinner\u0026gt;   在 app.component.scss 中設定了畫面上按鈕排版位置。\n1 2 3 4 5 6 7 8  /* app.component.scss */ .content { padding: 16px; } button { margin: 8px; }   在 app.component.ts component class 中宣告了一個 property: loading，用來控制畫面上 Spinner 的顯示與否。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // app.component.ts import { Component } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent { loading = false; showSpinner() { this.loading = true; } hideSpinner() { this.loading = false; } }   測試 mat-spinner 顯示效果 測試後，微調了一下 spinner 在畫面中的位置。\napp.component.scss 調整如下：\n/* ... */ /* 加入以下設定：調整顯示的位置 */ mat-spinner { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 5; } 調整後效果如下：\n使用 HTTPClient 讀取後端資料 建立一個呼叫後端 Api 的 service\n$ npx ng g s services/getData 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // services/get-data.service.ts import { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; import { Injectable } from \u0026#39;@angular/core\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class GetDataService { constructor(private http: HttpClient) { }  getData() { return this.http.get(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;);  } }   使用到了 HttpClient，所以要記得在 AppModule 中匯入 HttpClientModule\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // app.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { BrowserAnimationsModule } from \u0026#39;@angular/platform-browser/animations\u0026#39;; import { MatToolbarModule } from \u0026#39;@angular/material/toolbar\u0026#39;; import { MatButtonModule } from \u0026#39;@angular/material/button\u0026#39;; import { MatProgressSpinnerModule } from \u0026#39;@angular/material/progress-spinner\u0026#39;; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, BrowserAnimationsModule, MatToolbarModule, MatButtonModule, MatProgressSpinnerModule, HttpClientModule  ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }   在 Template (app.component.html) 中加入一個“取得資料”的按鈕。\n1 2 3 4 5 6 7 8 9 10  \u0026lt;mat-toolbar color=\u0026#34;primary\u0026#34;\u0026gt; 使用 RxJS and HttpInterceptor 來實現 \u0026#34;資料讀取中...\u0026#34; 動畫效果的功能 \u0026lt;/mat-toolbar\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;button mat-raised-button (click)=\u0026#34;showSpinner()\u0026#34;\u0026gt;顯示\u0026lt;/button\u0026gt; \u0026lt;button mat-raised-button color=\u0026#34;warn\u0026#34; (click)=\u0026#34;hideSpinner()\u0026#34;\u0026gt;隐蔵\u0026lt;/button\u0026gt; \u0026lt;button mat-raised-button color=\u0026#34;primary\u0026#34; (click)=\u0026#34;getData()\u0026#34;\u0026gt;取得資料\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;mat-spinner *ngIf=\u0026#34;loading\u0026#34;\u0026gt;\u0026lt;/mat-spinner\u0026gt;   在 component class 中呼叫 Service 來向後端 API 讀取資料。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import { Component } from \u0026#39;@angular/core\u0026#39;; import { GetDataService } from \u0026#39;./services/get-data.service\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent { loading = false; data: unknown;  constructor(private _getData: GetDataService){ }  showSpinner() { this.loading = true; } hideSpinner() { this.loading = false; } getData() { this.loading = true; this._getData.getData().subscribe(data =\u0026gt; { this.loading = false; this.data = data; }); } }   完成以上程式後，在按下“取得資料“按鈕執行讀取後端 API 時畫面已可以正確的顯示資料讀取中的動畫圖示了。\n使用 Interceptor 來優化程式 接下來要透過 Angular Interceptor 來優化程式。上述程式碼在每支與後端API有互動的程式中都會重複出現，可以透過將相同邏輯統一放置在 Interceptor 中來優化整個系統。\n建立一個 Interceptor\n1 2 3 4  $ npx ng g interceptor interceptors/httpLoadingSpin  CREATE src/app/interceptors/http-loading-spin.interceptor.spec.ts (472 bytes) CREATE src/app/interceptors/http-loading-spin.interceptor.ts (420 bytes)   將 \u0026lsquo;狀態\u0026rsquo; 資訊放在另一支 Service 程式中\n1 2 3 4  $ npx ng g s services/loading  CREATE src/app/services/loading.service.spec.ts (362 bytes) CREATE src/app/services/loading.service.ts (136 bytes)   loading.service.ts 程式內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { BehaviorSubject } from \u0026#39;rxjs\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class LoadingService { private _loading$ = new BehaviorSubject\u0026lt;boolean\u0026gt;(false); loading$ = this._loading$.asObservable(); constructor() { } show() { this._loading$.next(true); } hide() { this._loading$.next(false); } }   在前面新建立的 Interceptor 程式修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor } from \u0026#39;@angular/common/http\u0026#39;; import { finalize, Observable } from \u0026#39;rxjs\u0026#39;; import { LoadingService } from \u0026#39;../services/loading.service\u0026#39;;  @Injectable() export class HttpLoadingSpinInterceptor implements HttpInterceptor { constructor(private loadingService: LoadingService) {}  intercept(request: HttpRequest\u0026lt;unknown\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;unknown\u0026gt;\u0026gt; { this.loadingService.show();  return next.handle(request).pipe( finalize(() =\u0026gt; { this.loadingService.hide();  }) ); } }   並且記得要在 app.moudle.ts 註冊這個新建立的 interceptor\n1 2 3 4 5 6 7  // ... providers: [{ provide: HTTP_INTERCEPTORS, useClass: HttpLoadingSpinInterceptor, multi: true }], // ...   app.component.ts 這個 component class 程式改成使用新建立的 LoadingService\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import { Component } from \u0026#39;@angular/core\u0026#39;; import { GetDataService } from \u0026#39;./services/get-data.service\u0026#39;; import { LoadingService } from \u0026#39;./services/loading.service\u0026#39;;  @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent { // loading = false;  loading$ = this.loadingService.loading$;  data: unknown; constructor(private _getData: GetDataService , private loadingService: LoadingService){ }  showSpinner() { // this.loading = true;  this.loadingService.show();  } hideSpinner() { // this.loading = false;  this.loadingService.hide();  } getData() { // this.loading = true;  this._getData.getData().subscribe(data =\u0026gt; { // this.loading = false;  this.data = data; }); } }   template（app.component.html）中的 ngIf 判斷條件改使用 loading$，並搭配使用 async pipe\n1 2 3 4 5 6 7 8 9 10  \u0026lt;mat-toolbar color=\u0026#34;primary\u0026#34;\u0026gt; 使用 RxJS and HttpInterceptor 來實現 \u0026#34;資料讀取中...\u0026#34; 動畫效果的功能 \u0026lt;/mat-toolbar\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;button mat-raised-button (click)=\u0026#34;showSpinner()\u0026#34;\u0026gt;顯示\u0026lt;/button\u0026gt; \u0026lt;button mat-raised-button color=\u0026#34;warn\u0026#34; (click)=\u0026#34;hideSpinner()\u0026#34;\u0026gt;隐蔵\u0026lt;/button\u0026gt; \u0026lt;button mat-raised-button color=\u0026#34;primary\u0026#34; (click)=\u0026#34;getData()\u0026#34;\u0026gt;取得資料\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;mat-spinner *ngIf=\u0026#34;loading$ | async\u0026#34;\u0026gt;\u0026lt;/mat-spinner\u0026gt;   以上是透過 interceptor 方式來優化程式。\n透過使用 RXJS Operator 再對程式進行優化 最後，將再進行更新一步的優化：\n 在按下“取得資料”按鈕後與取得資料前（即資料回傳完畢前）畫面上的所有按鈕（UI）都保持 disable 狀況，直到資料回傳完畢 如果“取得資料”的作業時間很短（如：小於等於1秒鐘），將不顯示“讀取中\u0026hellip;\u0026ldquo;這個動畫效果  需求一 上述需求一可透過 CSS 來達成，首先將 app.component.html mat-spinner 程式碼調整如下\n\u0026lt;!-- \u0026lt;mat-spinner *ngIf=\u0026#34;loading$ | async\u0026#34;\u0026gt;\u0026lt;/mat-spinner\u0026gt; --\u0026gt; \u0026lt;ng-container *ngIf=\u0026#34;loading$ | async\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;overlay\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;mat-spinner\u0026gt;\u0026lt;/mat-spinner\u0026gt; \u0026lt;/ng-container\u0026gt; 其中的 overlay div 是用來遮敝在整個晝面上，來達到讀取完成前畫面是無回應的要求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  .content { padding: 16px; } button { margin: 8px; } mat-spinner { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 5; } .overlay { top: 0; bottom: 0; left: 0; right: 0; position: absolute; z-index: 2; backdrop-filter: blur(2px); }   使用後的效果如下圖：\n需求二 第二個需求可以在 LoadingService 使用相關的 RXJS Operator 來達成：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // ...  // loading$ = this._loading$.asObservable();  loading$: Observable\u0026lt;boolean\u0026gt; = this._loading$.pipe( switchMap(isLoading =\u0026gt; { if (!isLoading) { return of(false); } return of(true).pipe(delay(1000)); }) ) // ...   ","permalink":"https://calvinegs.github.io/posts/angular-intercoptor-loadingspinner/","summary":"github Source code\n除非你和我一樣是個‘老傢伙’，使用過 Angular ver 4.3 以前的版本，否則你一定會遇到它 - interceptor(攔截器)。接下來將用幾篇筆記把各種使用 interceptor 情境的範例給記錄下來。\nAngular Interceptor 可以用來作什麼用途呢\n 修改 HTTP Headers 修改 HTTP request body 設定 authentication/authorization token　（身份認證） 模擬 backend api 修改 HTTP response 處理 HTTP 錯誤 (HTTP Error Handlin) 顯示 Loading Spinner 格式化 JSON Responses 日誌記錄  首先先來看看如何使用 Interceptor 來完成一個當你在讀取後端資料時可在畫面上顯示一個“正在讀取中\u0026hellip;“的動畫效果，這可以讓使用者有良好的使用體驗。\n筆記最後要達的效果是，在按下“取得資料”按鈕時，由程式向後端 API 讀取資料，而在讀取完成前，畫面中的所有 UI (如：按鈕）都是呈現無作用的狀況，直到資料回傳完畢。同時如果“向後端 API 讀取資料”的作業時間小於一秒鐘，則不顯示 “讀取中\u0026hellip;\u0026quot; 這個動畫效果。\n建立 Angular 專案架構 使用 npm init @angular 語法來建立 Angular project\n1 2 3  $ npm init @angular loadingSpin -- --routing --style=scss $ cd loadingSpin $ code .","title":"Angular Intercoptor 使用案例一：Loading Spinner"},{"content":"以最簡潔的方式在 ubuntu 22.04 中建立一支 Angular 15 Web App 先講結論：使用 \u0026ldquo;npm init @angular \u0026quot; 就可以在不先安裝 Angular Cli 的前題下，來建立一支 Web App 範本程式。\n一般要新增一支 Angular Web App 都會使用 Angular Cli，而使用 Angular Cli 必須搭配上 Node.js \u0026amp; npm\n一般的方式 在 ubuntu 22.04 上安裝 Node.js $ node -v # 先檢視是否有安裝 Node.js，若沒有則需安裝 $ $ sudo apt update $ sudo apt install nodejs $ $ node -v v12.22.9 在 ubuntu 22.04 上安裝 npm $ npm -v\t# 先檢視是否有安裝 npm，若沒有則需安裝 $ $ sudo apt update $ sudo apt install npm $ $ npm -v 8.5.1 安裝 Angular Cli $ mkdir ./test \u0026amp;\u0026amp; cd ./test $ npm install @angular/cli # 在 local test 目錄下安裝最新版 Angular Cli npm WARN deprecated @npmcli/move-file@2.0.1: This functionality has been moved to @npmcli/fs npm WARN saveError ENOENT: no such file or directory, open \u0026#39;/home/egs/temp/v12/package.json\u0026#39; npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN notsup Unsupported engine for @angular/cli@15.0.4: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.20.0 || ^16.13.0 || \u0026gt;=18.10.0\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;^6.11.0 || ^7.5.6 || \u0026gt;=8.0.0\u0026#34;,\u0026#34;yarn\u0026#34;:\u0026#34;\u0026gt;= 1.13.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @angular/cli@15.0.4 npm WARN notsup Unsupported engine for npm-pick-manifest@8.0.1: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: npm-pick-manifest@8.0.1 npm WARN notsup Unsupported engine for pacote@15.0.6: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: pacote@15.0.6 npm WARN notsup Unsupported engine for @angular-devkit/architect@0.1500.4: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.20.0 || ^16.13.0 || \u0026gt;=18.10.0\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;^6.11.0 || ^7.5.6 || \u0026gt;=8.0.0\u0026#34;,\u0026#34;yarn\u0026#34;:\u0026#34;\u0026gt;= 1.13.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @angular-devkit/architect@0.1500.4 npm WARN notsup Unsupported engine for @angular-devkit/schematics@15.0.4: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.20.0 || ^16.13.0 || \u0026gt;=18.10.0\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;^6.11.0 || ^7.5.6 || \u0026gt;=8.0.0\u0026#34;,\u0026#34;yarn\u0026#34;:\u0026#34;\u0026gt;= 1.13.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @angular-devkit/schematics@15.0.4 npm WARN notsup Unsupported engine for @schematics/angular@15.0.4: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.20.0 || ^16.13.0 || \u0026gt;=18.10.0\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;^6.11.0 || ^7.5.6 || \u0026gt;=8.0.0\u0026#34;,\u0026#34;yarn\u0026#34;:\u0026#34;\u0026gt;= 1.13.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @schematics/angular@15.0.4 npm WARN notsup Unsupported engine for @angular-devkit/core@15.0.4: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.20.0 || ^16.13.0 || \u0026gt;=18.10.0\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;^6.11.0 || ^7.5.6 || \u0026gt;=8.0.0\u0026#34;,\u0026#34;yarn\u0026#34;:\u0026#34;\u0026gt;= 1.13.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @angular-devkit/core@15.0.4 npm WARN notsup Unsupported engine for npm-package-arg@10.1.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: npm-package-arg@10.1.0 npm WARN notsup Unsupported engine for npm-install-checks@6.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: npm-install-checks@6.0.0 npm WARN notsup Unsupported engine for npm-normalize-package-bin@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: npm-normalize-package-bin@3.0.0 npm WARN notsup Unsupported engine for proc-log@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: proc-log@3.0.0 npm WARN notsup Unsupported engine for hosted-git-info@6.1.1: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: hosted-git-info@6.1.1 npm WARN notsup Unsupported engine for validate-npm-package-name@5.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: validate-npm-package-name@5.0.0 npm WARN notsup Unsupported engine for npm-package-arg@10.1.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: npm-package-arg@10.1.0 npm WARN notsup Unsupported engine for proc-log@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: proc-log@3.0.0 npm WARN notsup Unsupported engine for npm-registry-fetch@14.0.3: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: npm-registry-fetch@14.0.3 npm WARN notsup Unsupported engine for cacache@17.0.4: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: cacache@17.0.4 npm WARN notsup Unsupported engine for npm-packlist@7.0.4: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: npm-packlist@7.0.4 npm WARN notsup Unsupported engine for read-package-json-fast@3.0.2: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: read-package-json-fast@3.0.2 npm WARN notsup Unsupported engine for ssri@10.0.1: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: ssri@10.0.1 npm WARN notsup Unsupported engine for read-package-json@6.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: read-package-json@6.0.0 npm WARN notsup Unsupported engine for @npmcli/installed-package-contents@2.0.1: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @npmcli/installed-package-contents@2.0.1 npm WARN notsup Unsupported engine for @npmcli/promise-spawn@6.0.2: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @npmcli/promise-spawn@6.0.2 npm WARN notsup Unsupported engine for @npmcli/git@4.0.3: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @npmcli/git@4.0.3 npm WARN notsup Unsupported engine for @npmcli/run-script@6.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @npmcli/run-script@6.0.0 npm WARN notsup Unsupported engine for proc-log@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: proc-log@3.0.0 npm WARN notsup Unsupported engine for which@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: which@3.0.0 npm WARN notsup Unsupported engine for npm-bundled@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: npm-bundled@3.0.0 npm WARN notsup Unsupported engine for @npmcli/node-gyp@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @npmcli/node-gyp@3.0.0 npm WARN notsup Unsupported engine for json-parse-even-better-errors@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: json-parse-even-better-errors@3.0.0 npm WARN notsup Unsupported engine for @npmcli/fs@3.1.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: @npmcli/fs@3.1.0 npm WARN notsup Unsupported engine for fs-minipass@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: fs-minipass@3.0.0 npm WARN notsup Unsupported engine for unique-filename@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: unique-filename@3.0.0 npm WARN notsup Unsupported engine for unique-slug@4.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: unique-slug@4.0.0 npm WARN notsup Unsupported engine for hosted-git-info@6.1.1: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: hosted-git-info@6.1.1 npm WARN notsup Unsupported engine for validate-npm-package-name@5.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: validate-npm-package-name@5.0.0 npm WARN notsup Unsupported engine for ignore-walk@6.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: ignore-walk@6.0.0 npm WARN notsup Unsupported engine for npm-package-arg@10.1.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: npm-package-arg@10.1.0 npm WARN notsup Unsupported engine for minipass-fetch@3.0.1: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: minipass-fetch@3.0.1 npm WARN notsup Unsupported engine for proc-log@3.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: proc-log@3.0.0 npm WARN notsup Unsupported engine for make-fetch-happen@11.0.2: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: make-fetch-happen@11.0.2 npm WARN notsup Unsupported engine for hosted-git-info@6.1.1: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: hosted-git-info@6.1.1 npm WARN notsup Unsupported engine for validate-npm-package-name@5.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: validate-npm-package-name@5.0.0 npm WARN notsup Unsupported engine for normalize-package-data@5.0.0: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: normalize-package-data@5.0.0 npm WARN notsup Unsupported engine for hosted-git-info@6.1.1: wanted: {\u0026#34;node\u0026#34;:\u0026#34;^14.17.0 || ^16.13.0 || \u0026gt;=18.0.0\u0026#34;} (current: {\u0026#34;node\u0026#34;:\u0026#34;12.22.10\u0026#34;,\u0026#34;npm\u0026#34;:\u0026#34;6.14.16\u0026#34;}) npm WARN notsup Not compatible with your version of node/npm: hosted-git-info@6.1.1 npm WARN enoent ENOENT: no such file or directory, open \u0026#39;/home/egs/temp/v12/package.json\u0026#39; npm WARN v12 No description npm WARN v12 No repository field. npm WARN v12 No README data npm WARN v12 No license field. + @angular/cli@15.0.4 added 237 packages from 164 contributors and audited 237 packages in 9.17s 26 packages are looking for funding run `npm fund` for details found 0 vulnerabilities 安裝 angualr/cli 産生錯誤的原因是因為安裝指令中未指定版本時，預設是要安裝最新版（現在這個時候最新版是 v15）。 Angular Cli 的版本與 Node.js 的版本必須要搭配合宜，譬如說 Angular Cli v15 就必須搭配 Node.js v14.20.0以上或 v16.13.0以上或 v18.10.0。\n註：詳細的資料可參考 Angular 與 Node.js 對照表\n前述的問題，解決方法有二：\n 方法一：不要使用最新版本的 Angular Cli，而採用可以搭配 Node.js 12 版本的 Cli(也就是 Angular Cli v13) 方法二：更新 Node.js 的版本  安裝 Angular Cli v13 在 local 目錄中 $ npm install @angular/cli@13\t# 安裝 cli 時指定特定版本 $ $ npx ng version _ _ ____ _ ___ / \\  _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 13.3.10 Node: 12.22.12 Package Manager: npm 6.14.16 OS: linux x64 Angular: ... Package Version ------------------------------------------------------ @angular-devkit/architect 0.1303.10 @angular-devkit/core 13.3.10 @angular-devkit/schematics 13.3.10 @schematics/angular 13.3.10 使用 Angular Cli v13 建立 Angular App $ ng new testApp --routing --style=scss \u0026amp;\u0026amp; cd testApp $ npm start 接下來要詳述方法二，也就是本篇筆記的重點。\n將 Node.js 安裝在 global 環境可能是一種最簡潔的方式，但對開發人員而言，卻可能不是最佳解。\n原因很簡單，因為開發人員可能要面對是不同專案、不同的開發工具、及各種不同版本環境\u0026hellip;，將單一版本安裝在 global 中，衍生出來的版本切換問題可能造成更多不便。\n使用 nvm 來管理系統中的 Node.js \u0026amp; npm (在 windows 環境中可以使用 nvs，請參考這篇　https://calvinegs.github.io/categories/nvs/)\n在 ubuntu 中我們要用 wget 來進行 nvm 的安裝，所以首先先確認系統中已是否已安裝了 wget\n$ wget --version GNU Wget 1.21.2 built on linux-gnu. -cares +digest -gpgme +https +ipv6 +iri +large-file -metalink +nls +ntlm +opie +psl +ssl/openssl Wgetrc: /etc/wgetrc (system) Locale: /usr/share/locale Compile: gcc -DHAVE_CONFIG_H -DSYSTEM_WGETRC=\u0026#34;/etc/wgetrc\u0026#34; -DLOCALEDIR=\u0026#34;/usr/share/locale\u0026#34; -I. -I../../src -I../lib -I../../lib -Wdate-time -D_FORTIFY_SOURCE=2 -DHAVE_LIBSSL -DNDEBUG -g -O2 -ffile-prefix-map=/build/wget-8g5eYO/wget-1.21.2=. -flto=auto -ffat-lto-objects -flto=auto -ffat-lto-objects -fstack-protector-strong -Wformat -Werror=format-security -DNO_SSLv2 -D_FILE_OFFSET_BITS=64 -g -Wall Link: gcc -DHAVE_LIBSSL -DNDEBUG -g -O2 -ffile-prefix-map=/build/wget-8g5eYO/wget-1.21.2=. -flto=auto -ffat-lto-objects -flto=auto -ffat-lto-objects -fstack-protector-strong -Wformat -Werror=format-security -DNO_SSLv2 -D_FILE_OFFSET_BITS=64 -g -Wall -Wl,-Bsymbolic-functions -flto=auto -ffat-lto-objects -flto=auto -Wl,-z,relro -Wl,-z,now -lpcre2-8 -luuid -lidn2 -lssl -lcrypto -lz -lpsl ftp-opie.o openssl.o http-ntlm.o ../lib/libgnu.a Copyright (C) 2015 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://www.gnu.org/licenses/gpl.html\u0026gt;. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Originally written by Hrvoje Niksic \u0026lt;hniksic@xemacs.org\u0026gt;. Please send bug reports and questions to \u0026lt;bug-wget@gnu.org\u0026gt;. 在 ubuntu 22.04 上安裝 nvm 使用 wget 下載最新稳定版本 nvm\n$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 上述指令將 nvm repository 下載至 ~/.nvm 目錄中\n$ srouce ~/.bashrc\t# 在當前環境中執行 .bashrc script $ command -v nvm\t# 確認已安裝好 NVM $ nvm -v\t# 顯示目前安裝的 nvm 版本 0.39.1 使用 nvm 查詢 local 端 Node.js 目前安裝的情況 $ nvm ls system iojs -\u0026gt; N/A (default) node -\u0026gt; stable (-\u0026gt; N/A) (default) unstable -\u0026gt; N/A (default) 使用 nvm 查詢 Node.js 目前所有版本清單 $ nvm ls-remote ... v17.6.0 v17.7.0 v17.7.1 v17.7.2 v17.8.0 v17.9.0 v17.9.1 v18.0.0 v18.1.0 v18.2.0 v18.3.0 v18.4.0 v18.5.0 v18.6.0 v18.7.0 v18.8.0 v18.9.0 v18.9.1 v18.10.0 v18.11.0 v18.12.0 (LTS: Hydrogen) -\u0026gt; v18.12.1 (Latest LTS: Hydrogen) v19.0.0 v19.0.1 v19.1.0 v19.2.0 v19.3.0 安裝最新版本 Node.js $ nvm install node\t# 未指定版本，即表示要安裝最新版本 Downloading and installing node v19.3.0... Downloading https://nodejs.org/dist/v19.3.0/node-v19.3.0-linux-x64.tar.xz... --2023-01-04 10:38:43-- https://nodejs.org/dist/v19.3.0/node-v19.3.0-linux-x64.tar.xz Resolving nodejs.org (nodejs.org)... 104.20.22.46, 104.20.23.46, 2606:4700:10::6814:162e, ... Connecting to nodejs.org (nodejs.org)|104.20.22.46|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 23840516 (23M) [application/x-xz] Saving to: ‘/home/calvin-egs/.nvm/.cache/bin/node-v19.3.0-linux-x64/node-v19.3.0-linux-x64.tar.xz’ /home/calvin-egs/.nvm/.cache/ 100%[===============================================\u0026gt;] 22.74M 5.32MB/s in 4.6s 2023-01-04 10:38:48 (4.96 MB/s) - ‘/home/calvin-egs/.nvm/.cache/bin/node-v19.3.0-linux-x64/node-v19.3.0-linux-x64.tar.xz’ saved [23840516/23840516] Computing checksum with sha256sum Checksums matched! Now using node v19.3.0 (npm v9.2.0) Creating default alias: default -\u0026gt; node (-\u0026gt; v19.3.0) 查看安裝情況\n$ nvm ls\t# 列出目前所有已安裝的 Node.js 版本 -\u0026gt; v19.3.0\t# 目前只安裝了一個版本 v19.3.0 default -\u0026gt; node (-\u0026gt; v19.3.0) iojs -\u0026gt; N/A (default) unstable -\u0026gt; N/A (default) node -\u0026gt; stable (-\u0026gt; v19.3.0) (default) stable -\u0026gt; 19.3 (-\u0026gt; v19.3.0) (default) lts/* -\u0026gt; lts/hydrogen (-\u0026gt; N/A) lts/argon -\u0026gt; v4.9.1 (-\u0026gt; N/A) lts/boron -\u0026gt; v6.17.1 (-\u0026gt; N/A) lts/carbon -\u0026gt; v8.17.0 (-\u0026gt; N/A) lts/dubnium -\u0026gt; v10.24.1 (-\u0026gt; N/A) lts/erbium -\u0026gt; v12.22.12 (-\u0026gt; N/A) lts/fermium -\u0026gt; v14.21.2 (-\u0026gt; N/A) lts/gallium -\u0026gt; v16.19.0 (-\u0026gt; N/A) lts/hydrogen -\u0026gt; v18.12.1 (-\u0026gt; N/A) 安裝特定版本的最更新版 Node.js $ nvm install 18 # 安裝 version 18 版中的最更新版(如：v18.12.1) Downloading and installing node v18.12.1... Downloading https://nodejs.org/dist/v18.12.1/node-v18.12.1-linux-x64.tar.xz... --2023-01-04 10:42:41-- https://nodejs.org/dist/v18.12.1/node-v18.12.1-linux-x64.tar.xz Resolving nodejs.org (nodejs.org)... 104.20.23.46, 104.20.22.46, 2606:4700:10::6814:172e, ... Connecting to nodejs.org (nodejs.org)|104.20.23.46|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 23726988 (23M) [application/x-xz] Saving to: ‘/home/calvin-egs/.nvm/.cache/bin/node-v18.12.1-linux-x64/node-v18.12.1-linux-x64.tar.xz’ /home/calvin-egs/.nvm/.cache/ 100%[===============================================\u0026gt;] 22.63M 5.10MB/s in 4.8s 2023-01-04 10:42:46 (4.68 MB/s) - ‘/home/calvin-egs/.nvm/.cache/bin/node-v18.12.1-linux-x64/node-v18.12.1-linux-x64.tar.xz’ saved [23726988/23726988] Computing checksum with sha256sum Checksums matched! Now using node v18.12.1 (npm v8.19.2) 安裝成功後，再次查看目前安裝有那些版本，可以看到有 v18.12.1 與 v19.3.0，且目前使用的是 v18.12.1（ \u0026ldquo;-\u0026gt;\u0026rdquo; 指示的即表示目前環境下所採用 Node.js 版本）\n$ nvm ls -\u0026gt; v18.12.1 v19.3.0 default -\u0026gt; node (-\u0026gt; v19.3.0) iojs -\u0026gt; N/A (default) unstable -\u0026gt; N/A (default) node -\u0026gt; stable (-\u0026gt; v19.3.0) (default) stable -\u0026gt; 19.3 (-\u0026gt; v19.3.0) (default) lts/* -\u0026gt; lts/hydrogen (-\u0026gt; v18.12.1) lts/argon -\u0026gt; v4.9.1 (-\u0026gt; N/A) lts/boron -\u0026gt; v6.17.1 (-\u0026gt; N/A) lts/carbon -\u0026gt; v8.17.0 (-\u0026gt; N/A) lts/dubnium -\u0026gt; v10.24.1 (-\u0026gt; N/A) lts/erbium -\u0026gt; v12.22.12 (-\u0026gt; N/A) lts/fermium -\u0026gt; v14.21.2 (-\u0026gt; N/A) lts/gallium -\u0026gt; v16.19.0 (-\u0026gt; N/A) lts/hydrogen -\u0026gt; v18.12.1``` 如何不使用 Angular Cli 來新建一支 Angular Web App 程式範本 透過　npm init @angular　指令就可以不必先安裝 Angular Cli 的前題下來建立最新版本的 Angular Web App 程式範本\n$ mkdir angular15 \u0026amp;\u0026amp; cd angular15 $ node -v # 先確認現行 Node.js 版本 v19.3.0 # 使用 npm init 指令 $ npm init @angular firstExample -- --routing --style=scss Need to install the following packages: @angular/create@15.0.4 Ok to proceed? (y) npm WARN deprecated @npmcli/move-file@2.0.1: This functionality has been moved to @npmcli/fs npm WARN deprecated sourcemap-codec@1.4.8: Please use @jridgewell/sourcemap-codec instead Node.js version v19.3.0 detected. Odd numbered Node.js versions will not enter LTS status and should not be used for production. For more information, please see https://nodejs.org/en/about/releases/. ? Would you like to share pseudonymous usage data about this project with the Angular Team at Google under Google\u0026#39;s Privacy Policy at https://policies.google.com/privacy. For more details and how to change this setting, see https://angular.io/analytics. No Global setting: disabled Local setting: No local workspace configuration file. Effective status: disabled CREATE firstExample/README.md (1066 bytes) CREATE firstExample/.editorconfig (274 bytes) CREATE firstExample/.gitignore (548 bytes) CREATE firstExample/angular.json (2949 bytes) CREATE firstExample/package.json (1044 bytes) CREATE firstExample/tsconfig.json (901 bytes) CREATE firstExample/tsconfig.app.json (263 bytes) CREATE firstExample/tsconfig.spec.json (273 bytes) CREATE firstExample/.vscode/extensions.json (130 bytes) CREATE firstExample/.vscode/launch.json (474 bytes) CREATE firstExample/.vscode/tasks.json (938 bytes) CREATE firstExample/src/favicon.ico (948 bytes) CREATE firstExample/src/index.html (298 bytes) CREATE firstExample/src/main.ts (214 bytes) CREATE firstExample/src/styles.scss (80 bytes) CREATE firstExample/src/assets/.gitkeep (0 bytes) CREATE firstExample/src/app/app-routing.module.ts (245 bytes) CREATE firstExample/src/app/app.module.ts (393 bytes) CREATE firstExample/src/app/app.component.scss (0 bytes) CREATE firstExample/src/app/app.component.html (23115 bytes) CREATE firstExample/src/app/app.component.spec.ts (1091 bytes) CREATE firstExample/src/app/app.component.ts (217 bytes) ✔ Packages installed successfully. 註：“npm init @angular projectName \u0026ndash; \u0026ndash;routing \u0026ndash;style=scss”　指令等同 “npx @angular/create projectName \u0026ndash;routing \u0026ndash;style=scss”\n範本建立成功後，可查看 package.json 中採用的那個版本的 Angular 程式架構\n$ cd firstExample $ cat package.json { \u0026#34;name\u0026#34;: \u0026#34;first-example\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;ng build --watch --configuration development\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34; }, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;rxjs\u0026#34;: \u0026#34;~7.5.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^2.3.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.12.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;^15.0.4\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~15.0.4\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~4.3.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~4.5.0\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~6.4.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~3.1.0\u0026#34;, \u0026#34;karma-coverage\u0026#34;: \u0026#34;~2.2.0\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~5.1.0\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;~2.0.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~4.8.2\u0026#34; } } 執行産生的預設程式範本\n$ npm start \u0026gt; first-example@0.0.0 start \u0026gt; ng serve Node.js version v19.3.0 detected. Odd numbered Node.js versions will not enter LTS status and should not be used for production. For more information, please see https://nodejs.org/en/about/releases/. ✔ Browser application bundle generation complete. Initial Chunk Files | Names | Raw Size vendor.js | vendor | 2.09 MB | polyfills.js | polyfills | 314.28 kB | styles.css, styles.js | styles | 209.87 kB | main.js | main | 48.10 kB | runtime.js | runtime | 6.52 kB | | Initial Total | 2.66 MB Build at: 2023-01-04T02:54:06.004Z - Hash: ef1d647f832bd9c0 - Time: 11301ms ** Angular Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ ** ✔ Compiled successfully. 讓特定目錄自動使用特定版本的 Node.js 最後來說說如何在切換目錄時由系統自動切換不同的 Node.js 版本。\n修改 ~/.bashrc 檔案 首先，在 ~/.bashrc 檔案最後處加入以下 script。\n### for nvm auto switch version on change directory cdnvm() { command cd \u0026#34;$@\u0026#34;; nvm_path=$(nvm_find_up .nvmrc | tr -d \u0026#39;\\n\u0026#39;) # If there are no .nvmrc file, use the default nvm version if [[ ! $nvm_path = *[^[:space:]]* ]]; then declare default_version; default_version=$(nvm version default); # If there is no default version, set it to `node` # This will use the latest version on your machine if [[ $default_version == \u0026#34;N/A\u0026#34; ]]; then nvm alias default node; default_version=$(nvm version default); fi # If the current version is not the default version, set it to use the default version if [[ $(nvm current) != \u0026#34;$default_version\u0026#34; ]]; then nvm use default; fi elif [[ -s $nvm_path/.nvmrc \u0026amp;\u0026amp; -r $nvm_path/.nvmrc ]]; then declare nvm_version nvm_version=$(\u0026lt;\u0026#34;$nvm_path\u0026#34;/.nvmrc) declare locally_resolved_nvm_version # `nvm ls` will check all locally-available versions # If there are multiple matching versions, take the latest one # Remove the `-\u0026gt;` and `*` characters and spaces # `locally_resolved_nvm_version` will be `N/A` if no local versions are found locally_resolved_nvm_version=$(nvm ls --no-colors \u0026#34;$nvm_version\u0026#34; | tail -1 | tr -d \u0026#39;\\-\u0026gt;*\u0026#39; | tr -d \u0026#39;[:space:]\u0026#39;) # If it is not already installed, install it # `nvm install` will implicitly use the newly-installed version if [[ \u0026#34;$locally_resolved_nvm_version\u0026#34; == \u0026#34;N/A\u0026#34; ]]; then nvm install \u0026#34;$nvm_version\u0026#34;; elif [[ $(nvm current) != \u0026#34;$locally_resolved_nvm_version\u0026#34; ]]; then nvm use \u0026#34;$nvm_version\u0026#34;; fi fi } alias cd=\u0026#39;cdnvm\u0026#39; cd \u0026#34;$PWD\u0026#34; 讓修改的 ~/.bashrc Script file 即刻生效 修改完 ~/.bashrc Script file　後，使用 source 指令讓上述的 script 立即生效\n$ source ~/.bashrc 搭配 .nvmrc 檔案實現在切換工作目錄時自動切換不同的 Node.js 版本 在　angular15 目錄下再建一個名為 angular 子目錄，在這個子目錄我們要使用的 node 環境是 v18。\n$ mkdir angular \u0026amp;\u0026amp; cd angular\t# 建立 angular 子目錄，並將工作目錄切換到這個子目錄中 $ $ nvm use 18\t# 使用 nvm use 指令將 Node.js 環境切換成 第18版，因為我們之前安裝的是 v18.12.1，nvm 自動採得這個最新版的第18版 $ node -v\t# 查看目前使用的工作版本 v18.12.1 $ node -v \u0026gt; .nvmrc\t# 將 v.18.12.1 這個版本寫入到 .nvmrc 這個檔案中。 nvm 搭配上各目錄中 .nvmrc 檔案的設定就能實現｀自動｀切換 Node.js 版本的功能。\n$ cd ~ ~$ node -v v19.3.0 ~$ cd angular15 ~/angular15$ node -v v19.3.0 ~/angular15$ cd angualr Now using node v18.12.1 (npm v8.19.2) ~/angular15/angular$ node -v v18.12.1 使用 node v18.12.1 環境來建立 angualr 15 的 app\n$ npm init @angular secondExample -- --routing --style=css CREATE secondExample/README.md (1067 bytes) CREATE secondExample/.editorconfig (274 bytes) CREATE secondExample/.gitignore (548 bytes) CREATE secondExample/angular.json (2780 bytes) CREATE secondExample/package.json (1045 bytes) CREATE secondExample/tsconfig.json (901 bytes) CREATE secondExample/tsconfig.app.json (263 bytes) CREATE secondExample/tsconfig.spec.json (273 bytes) CREATE secondExample/.vscode/extensions.json (130 bytes) CREATE secondExample/.vscode/launch.json (474 bytes) CREATE secondExample/.vscode/tasks.json (938 bytes) CREATE secondExample/src/favicon.ico (948 bytes) CREATE secondExample/src/index.html (299 bytes) CREATE secondExample/src/main.ts (214 bytes) CREATE secondExample/src/styles.css (80 bytes) CREATE secondExample/src/assets/.gitkeep (0 bytes) CREATE secondExample/src/app/app-routing.module.ts (245 bytes) CREATE secondExample/src/app/app.module.ts (393 bytes) CREATE secondExample/src/app/app.component.css (0 bytes) CREATE secondExample/src/app/app.component.html (23115 bytes) CREATE secondExample/src/app/app.component.spec.ts (1094 bytes) CREATE secondExample/src/app/app.component.ts (217 bytes) ✔ Packages installed successfully. 執行時也不會有任可版本不相搭配的警告訊息出現了。\n$ npm start \u0026gt; second-example@0.0.0 start \u0026gt; ng serve ✔ Browser application bundle generation complete. Initial Chunk Files | Names | Raw Size vendor.js | vendor | 2.09 MB | polyfills.js | polyfills | 314.28 kB | styles.css, styles.js | styles | 209.41 kB | main.js | main | 48.11 kB | runtime.js | runtime | 6.52 kB | | Initial Total | 2.66 MB Build at: 2023-01-04T03:09:19.398Z - Hash: 64669f1b8675c995 - Time: 13758ms ** Angular Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ ** ✔ Compiled successfully. 結論：\n nvm 是管理你電腦中各式 Node.js 版本的好工具。 在新版本 Angular 中你可以不必先安裝 Cli 來建立程式範本，直接使用　npm init @angular 指令即可。  ","permalink":"https://calvinegs.github.io/posts/nvm-angular15/","summary":"以最簡潔的方式在 ubuntu 22.04 中建立一支 Angular 15 Web App 先講結論：使用 \u0026ldquo;npm init @angular \u0026quot; 就可以在不先安裝 Angular Cli 的前題下，來建立一支 Web App 範本程式。\n一般要新增一支 Angular Web App 都會使用 Angular Cli，而使用 Angular Cli 必須搭配上 Node.js \u0026amp; npm\n一般的方式 在 ubuntu 22.04 上安裝 Node.js $ node -v # 先檢視是否有安裝 Node.js，若沒有則需安裝 $ $ sudo apt update $ sudo apt install nodejs $ $ node -v v12.22.9 在 ubuntu 22.04 上安裝 npm $ npm -v\t# 先檢視是否有安裝 npm，若沒有則需安裝 $ $ sudo apt update $ sudo apt install npm $ $ npm -v 8.","title":"在 ubuntu 22.04 中建立一支 Angular 15 Web App"},{"content":"Angular中的 constructor 與 ngOnInit 在本篇筆記中來紀錄一下 Angular中的 constructor 與 ngOnInit 有何不同的使用情境，也探討一下 ngOnInit() 的非必要性。\nngOnInit 與 constructor ngOnInit() 與 Class 中的其他 Method 無異，僅因為它剛好被命名為 ngOnInit，常會被與 constructor 搞混用途。其實它並非是必要的，完全取決於你。當 Angular 編譯器進行程式編譯時會將是否 Class 中有實現 ngOnInit() 的方法記錄在特定的 Flag 中，這個 Flag 會在 \u0026ldquo;變更檢測\u0026quot;時決定是不是要呼叫 ngOnInit() 這個方法。\n而 constructor 則完全是另外的一件事，不管你有沒有在類別中實現它，在建立類別實例時它都會被呼叫到。\nAngular啟動時的二個主要階段：\n 建構元件樹(component tree) 執行變更檢測(change detection)  constructor 是在第一個階段被呼叫的，這就是為什麼我們不能將任何依賴於 DOM、元素、輸入數據、綁定等的初始化邏輯放在constructor— 因為它們尚不可使用。 而 ngOnInit 則在第二階段，實際上所有的生命週期鉤子都是“變更檢測”階段的一部份。\n當 Angular 開始變更檢測時，組件樹已被構建，樹中所有組件的構造函數都被調用。它已經完成了組件 DOM 的創建，通過構造函數注入了所有必需的依賴項並處理了輸入綁定。每個組件的模板節點都被添加到 DOM 中。 也可以取得初始化組件可能需要的所有資料，如：DI Provider、DOM 和輸入綁定(input bindings)。\n在實際的使用案例上 constructor 最常被使用的是用來“注入依賴項目”(當然不僅限於此)\nngOnInit 是否為必須 在之前使用 angular cli(如：14.0.6) 産生 component 會發現 component class 程式碼中是預設會使用到 ngOnInit 的。但在新版的 angular cli 中(如：15.0.4) 産生的程式架構中已預設不用使用 ngOnInit (與constructor) 了。\nangular cli 14.0.6\nangular cli 15.0.4\n其實：\n 在處理 Observables 時你不需要 ngOnInit 大多數時候，ngOnChanges 是 ngOnInit 的更好選擇  以下就要來說說如何不使用 ngOnInit 的一些寫法。\n常見的例子是 Angular 使用 Fetch 來讀取後端 API 資料顯示在畫面，寫法如下：\ndata: MyData; constructor(private readonly dataService: DataService) { } ngOnInit() { this.dataService.getData().subscribe( data =\u0026gt; this.data = data,\t//透過訂閱取得 data 後利用資料綁定的功能將資料顯示在模版中  ); } 更完善的寫法是還要包含有取消訂閱的程式碼，如下：\ndata: MyData; private readonly onDestroy = new Subject(); ngOnInit() { this.dataService.getData() .pipe( takeUntil(this.onDestroy) ).subscribe( data =\u0026gt; this.data = data, ); } ngOnDestroy() { this.onDestroy.next(); this.onDestroy.complete(); } Observable 與 async pipe 但其實在 Angular 中，模板裡不僅限於使用靜態值。我們可以直接在模板中使用 Observables。換句話說，很少需要在元件類別(component class)中訂閱的 Observable。實際上需要值的是模板(template)，所以我們應該在那裡訂閱。\n更好的作法是在模版中使用 AysncPipe，它用來訂閱 Observable 並監聽取得回傳值，並且它還負責在元件銷毀時取消訂閱。\n@Component({...}) export class Component { readonly data$ = this.dataService.getData(); constructor(private readonly dataService: DataService) { } } 在模版中使用 async pipe 來訂閱 data$ 這個 Observable 並取得回傳值來顯示在畫面中。使用這樣的寫法可以清楚的看出來取得資料的邏輯其實不須要存在元件類別中的。\n\u0026lt;p\u0026gt; {{ (data$ | async).name }} \u0026lt;/p\u0026gt; 另一個範例：\ndata?: { name: string, time: Date }; constructor(private readonly dataService: DataService) { } ngOnInit() { this.dataService.getData().subscribe( response =\u0026gt; { const first = response.data[0]; this.data = { name: first.name, time: new Date(first.time) } } ); } 可重構成：\nreadonly data$ = this.dataService.getData().pipe( map((response) =\u0026gt; { const first = response.data[0]; return { name: response.name, time: new Date(response.time) } }), ); constructor(private readonly dataService: DataService) { } 由上述二個例子了解，只須多利用 RxJs 的各種 Operator 與 async pipe，即可減少使用 ngOnInit hook 的使用了。\n嵌套 Observables 的較佳寫法 在使用後端資料時，常會有一種使用情境是呼收 API 時需要由 routing 中取得資料（如：ID）例如\nhero?: { name: string }; constructor( private readonly route: ActivatedRoute, private readonly heroService: HeroService, ) { } ngOnInit() { this.route.params.subscribe( (params) = \u0026gt; { const id = params.id; this.heroService.getHero(id).subscribe( response =\u0026gt; this.hero = response ); } )\t} 在這個範例中看到二個問題：\n 嵌套 Observables 的寫法 使用 ngOnInit 的必要性  程式碼重構如下：\nreadonly hero$ = this.route.params.pipe( switchMap(params =\u0026gt; this.heroService.getHero(params.id)) ); constructor( private readonly route: ActivatedRoute, private readonly heroService: HeroService, ) { } \u0026lt;p\u0026gt; {{ (hero$ | async).name }} \u0026lt;/p\u0026gt; 可使用 Observables 寫法免除在 ngOnInit hook 中多餘的程式碼 與 使用 switchMap operator 來消除嵌套 Observables 呼叫方式。\n如何解決模板中過多的 async 使用 問題來了，當在模板中使用了過多的 async，除了混淆模板外甚至會産生一些性能的問題。\n在許多 element 中使用了單一個 Observable，如：\n\u0026lt;p\u0026gt; {{ (hero$ | async).name }} \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; {{ (hero$ | async).lastname }} \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; {{ (hero$ | async).city }} \u0026lt;/p\u0026gt; 解決這個問題可善用 NgIf 這個“指令“，代碼如下：\n\u0026lt;ng-container *ngIf=\u0026#34;hero$ | async as hero\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{ hero.name }} \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; {{ hero.surname }} \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; {{ hero.city }} \u0026lt;/p\u0026gt; \u0026lt;/ng-container\u0026gt; 其中透過 *ngIf 指令中的 as 用法，使得我們在 p 元素中去綁定 hero 這個變數而不是 (hero$ | async)，使用這種技術來保存從 AsyncPIpe 解析出來的值，並在僅訂閱一次的情況下在許多元素中去使用它。 另外這段另一個 Angular 指令： ng-container，ng-container這個指令在實際産出時不會有任何額外的元素在 DOM 中。\n善用 RxJs Operator 來解決 component 中使用到許多的 Observable 的問題 如下範例：\nreadonly hero$ = this.route.params.pipe( switchMap(params =\u0026gt; this.heroService.getHero(params.id)) ); readonly pet$ = this.route.params.pipe( switchMap(params =\u0026gt; this.heroService.getPet(params.id)) ); readonly cities$ = this.heroService.getCities(); constructor( private readonly route: ActivatedRoute, private readonly heroService: HeroService, ) { } 可重構成：\nreadonly vm$ = combineLatest([ this.route.params.pipe( switchMap(params =\u0026gt; this.heroService.getHero(params.id)) ), this.route.params.pipe( switchMap(params =\u0026gt; this.heroService.getPet(params.id)) ), this.heroService.getCities(), ]).pipe( map(([hero, pet, cities]) =\u0026gt; { return { hero, pet, cities } }) ); constructor( private readonly route: ActivatedRoute, private readonly heroService: HeroService, ) { } 首先，只有當 route 參數産生變化時才分別發出 getHero、getPet與 getCities 的 fetch request，同時透過 combineLatest operator 在所有的 request 都取回資料後來産生一個 Observable。 第二是將陣列資料 mapping 到具有屬性名稱的物件中。 這使得我們的模版變得簡潔了許多\n\u0026lt;ng-container *ngIf=\u0026#34;vm$ | async as vm\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{ vm.hero.name }} \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; {{ vm.hero.surname }} \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; {{ vm.hero.city }} \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; {{ vm.pet.name }} \u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let city of vm.cities\u0026#34;\u0026gt; {{ city }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/ng-container\u0026gt; ngOnInit 與 ngOnChanges 有時我們可能會因為誤用 ngOnInit 而産生一些 bug，特別是在一些包含有子元件的父元件中，讓我們來看看範例：\n@Component({ template: `\u0026lt;p\u0026gt; {{ fullName }} \u0026lt;/p\u0026gt;`, }) export class NameComponent implements OnInit { @Input() name: string; @Input() lastname: string; fullName: string; ngOnInit() { this.fullName = `${this.name}${this.lastname}`; } } 這樣的程式碼在開始時是可正常工作的，但一旦 input 值有更動時就不會更新資料。\n那麼如何在每次輸入值有更動時要能正確的顯示最新資料呢？有兩種方法：\n 使用適合的 Hook，所以要改用 ngOnChanges 使用 setters 技術  每次輸入更改時 ngOnChanges 會被運行，因此我們可以使用這個 hook 根據輸入資料更新我們的內部狀態。\n@Component({ template: `\u0026lt;p\u0026gt; {{ fullName }} \u0026lt;/p\u0026gt;`, }) export class NameComponent implements OnChanges { @Input() name: string; @Input() surname: string; fullName: string; ngOnChanges() { this.fullName = `${this.name}${this.surname}`; } } 在第一次 ngOnChanges 被呼叫(由 input 資料更新而觸發)後，會緊隨著呼叫 ngOnInit，但僅限一次，ngOnChanges 資料的再更新而被再次的觸發，但 ngOnInit 則不會了。 除此不同外，ngOnChanges 傳入的資料是一個相對完整的　SimpleChanges 參數，它提供了當前和先前的狀態值。\n如果你要處理的資料邏輯是如此簡單，其實可以採用相對簡易的 getters 方式來完成，如：\n@Component({ template: `\u0026lt;p\u0026gt; {{ fullName }} \u0026lt;/p\u0026gt;`, changeDetection: ChangeDetectionStrategy.OnPush, }) export class NameComponent { @Input() name: string; @Input() surname: string; get fullName(): string { return `${this.name}${this.surname}` } } 當然也可採用 Setters 的方式，如：\nCopy interface MyDTO { data: { name: string; time: string; }[] } @Component({ template: `\u0026lt;p\u0026gt; {{ time }} \u0026lt;/p\u0026gt;`, }) export class TimeComponent { @Input() set vm(value: MyDTO) { const first = value.data[0]; this.time = new Date(first.time); } time: Date; } 採用 Getters 或 Setters 的方式就可以不用管到生命週期鉤子的相關技術。如果你要的結果不會依賴一個以上的 input value，那麼這種技術是很好用的。\n","permalink":"https://calvinegs.github.io/posts/angular-ngoninit/","summary":"Angular中的 constructor 與 ngOnInit 在本篇筆記中來紀錄一下 Angular中的 constructor 與 ngOnInit 有何不同的使用情境，也探討一下 ngOnInit() 的非必要性。\nngOnInit 與 constructor ngOnInit() 與 Class 中的其他 Method 無異，僅因為它剛好被命名為 ngOnInit，常會被與 constructor 搞混用途。其實它並非是必要的，完全取決於你。當 Angular 編譯器進行程式編譯時會將是否 Class 中有實現 ngOnInit() 的方法記錄在特定的 Flag 中，這個 Flag 會在 \u0026ldquo;變更檢測\u0026quot;時決定是不是要呼叫 ngOnInit() 這個方法。\n而 constructor 則完全是另外的一件事，不管你有沒有在類別中實現它，在建立類別實例時它都會被呼叫到。\nAngular啟動時的二個主要階段：\n 建構元件樹(component tree) 執行變更檢測(change detection)  constructor 是在第一個階段被呼叫的，這就是為什麼我們不能將任何依賴於 DOM、元素、輸入數據、綁定等的初始化邏輯放在constructor— 因為它們尚不可使用。 而 ngOnInit 則在第二階段，實際上所有的生命週期鉤子都是“變更檢測”階段的一部份。\n當 Angular 開始變更檢測時，組件樹已被構建，樹中所有組件的構造函數都被調用。它已經完成了組件 DOM 的創建，通過構造函數注入了所有必需的依賴項並處理了輸入綁定。每個組件的模板節點都被添加到 DOM 中。 也可以取得初始化組件可能需要的所有資料，如：DI Provider、DOM 和輸入綁定(input bindings)。\n在實際的使用案例上 constructor 最常被使用的是用來“注入依賴項目”(當然不僅限於此)\nngOnInit 是否為必須 在之前使用 angular cli(如：14.","title":"關於 Angular中的 constructor 與 ngOnInit"},{"content":"本篇筆記是除了以下常用的 npm 指令外，要介紹幾個好用的其他 npm 指令\n npm \u0026ndash;version (檢查在本端主機上安裝的 npm 版本) npm init (在現行目錄中初始化專案) npm list (顯示所有已安裝在專案中的所有套件) npm install (在專案中安裝套件) npm uninstall (移除已安裝在專案中的套件)  1.開啟套件的說明文件 - npm docs $ npm docs [package-name] #例如以下指令將會自動開啟 lodash 套件的說明網頁 $ npm docs lodash 2.開啟套件的原始碼儲存庫網頁 - npm repo $ npm repo [package-name] #例如以下指令將會自動開啟 lodash 套件的原始碼儲存庫網頁 $ npm repo lodash 3.查看套件的版本資訊 $ npm v [package-name] versions #以下指令將直接在 終端機 上顯示所有 lodash 套件的版本資訊 $ npm v lodash versions [ \u0026#39;0.1.0\u0026#39;, \u0026#39;0.2.0\u0026#39;, \u0026#39;0.2.1\u0026#39;, \u0026#39;0.2.2\u0026#39;, \u0026#39;0.3.0\u0026#39;, \u0026#39;0.3.1\u0026#39;, \u0026#39;0.3.2\u0026#39;, \u0026#39;0.4.0\u0026#39;, \u0026#39;0.4.1\u0026#39;, \u0026#39;0.4.2\u0026#39;, \u0026#39;0.5.0-rc.1\u0026#39;, \u0026#39;0.5.0\u0026#39;, \u0026#39;0.5.1\u0026#39;, \u0026#39;0.5.2\u0026#39;, \u0026#39;0.6.0\u0026#39;, \u0026#39;0.6.1\u0026#39;, \u0026#39;0.7.0\u0026#39;, \u0026#39;0.8.0\u0026#39;, \u0026#39;0.8.1\u0026#39;, \u0026#39;0.8.2\u0026#39;, \u0026#39;0.9.0\u0026#39;, \u0026#39;0.9.1\u0026#39;, \u0026#39;0.9.2\u0026#39;, \u0026#39;0.10.0\u0026#39;, \u0026#39;1.0.0-rc.1\u0026#39;, \u0026#39;1.0.0-rc.2\u0026#39;, \u0026#39;1.0.0-rc.3\u0026#39;, \u0026#39;1.0.0\u0026#39;, \u0026#39;1.0.1\u0026#39;, \u0026#39;1.0.2\u0026#39;, \u0026#39;1.1.0\u0026#39;, \u0026#39;1.1.1\u0026#39;, \u0026#39;1.2.0\u0026#39;, \u0026#39;1.2.1\u0026#39;, \u0026#39;1.3.0\u0026#39;, \u0026#39;1.3.1\u0026#39;, \u0026#39;2.0.0\u0026#39;, \u0026#39;2.1.0\u0026#39;, \u0026#39;2.2.0\u0026#39;, \u0026#39;2.2.1\u0026#39;, \u0026#39;2.3.0\u0026#39;, \u0026#39;2.4.0\u0026#39;, \u0026#39;2.4.1\u0026#39;, \u0026#39;2.4.2\u0026#39;, \u0026#39;3.0.0\u0026#39;, \u0026#39;3.0.1\u0026#39;, \u0026#39;3.1.0\u0026#39;, \u0026#39;3.2.0\u0026#39;, \u0026#39;3.3.0\u0026#39;, \u0026#39;3.3.1\u0026#39;, \u0026#39;3.4.0\u0026#39;, \u0026#39;3.5.0\u0026#39;, \u0026#39;3.6.0\u0026#39;, \u0026#39;3.7.0\u0026#39;, \u0026#39;3.8.0\u0026#39;, \u0026#39;3.9.0\u0026#39;, \u0026#39;3.9.1\u0026#39;, \u0026#39;3.9.2\u0026#39;, \u0026#39;3.9.3\u0026#39;, \u0026#39;3.10.0\u0026#39;, \u0026#39;3.10.1\u0026#39;, \u0026#39;4.0.0\u0026#39;, \u0026#39;4.0.1\u0026#39;, \u0026#39;4.1.0\u0026#39;, \u0026#39;4.2.0\u0026#39;, \u0026#39;4.2.1\u0026#39;, \u0026#39;4.3.0\u0026#39;, \u0026#39;4.4.0\u0026#39;, \u0026#39;4.5.0\u0026#39;, \u0026#39;4.5.1\u0026#39;, \u0026#39;4.6.0\u0026#39;, \u0026#39;4.6.1\u0026#39;, \u0026#39;4.7.0\u0026#39;, \u0026#39;4.8.0\u0026#39;, \u0026#39;4.8.1\u0026#39;, \u0026#39;4.8.2\u0026#39;, \u0026#39;4.9.0\u0026#39;, \u0026#39;4.10.0\u0026#39;, \u0026#39;4.11.0\u0026#39;, \u0026#39;4.11.1\u0026#39;, \u0026#39;4.11.2\u0026#39;, \u0026#39;4.12.0\u0026#39;, \u0026#39;4.13.0\u0026#39;, \u0026#39;4.13.1\u0026#39;, \u0026#39;4.14.0\u0026#39;, \u0026#39;4.14.1\u0026#39;, \u0026#39;4.14.2\u0026#39;, \u0026#39;4.15.0\u0026#39;, \u0026#39;4.16.0\u0026#39;, \u0026#39;4.16.1\u0026#39;, \u0026#39;4.16.2\u0026#39;, \u0026#39;4.16.3\u0026#39;, \u0026#39;4.16.4\u0026#39;, \u0026#39;4.16.5\u0026#39;, \u0026#39;4.16.6\u0026#39;, \u0026#39;4.17.0\u0026#39;, \u0026#39;4.17.1\u0026#39;, \u0026#39;4.17.2\u0026#39;, \u0026#39;4.17.3\u0026#39;, \u0026#39;4.17.4\u0026#39;, \u0026#39;4.17.5\u0026#39;, \u0026#39;4.17.9\u0026#39;, \u0026#39;4.17.10\u0026#39;, \u0026#39;4.17.11\u0026#39;, \u0026#39;4.17.12\u0026#39;, \u0026#39;4.17.13\u0026#39;, \u0026#39;4.17.14\u0026#39;, \u0026#39;4.17.15\u0026#39;, \u0026#39;4.17.16\u0026#39;, \u0026#39;4.17.17\u0026#39;, \u0026#39;4.17.18\u0026#39;, \u0026#39;4.17.19\u0026#39;, \u0026#39;4.17.20\u0026#39;, \u0026#39;4.17.21\u0026#39; ] 若不使用這個方便的指令，那你就比須要原始碼儲存庫網站上去查看： 4.查看套件的相關資訊 - npm v $ npm v [package-name] #以下指令將直接在 終端機 上顯示所有 lodash 套件的相關資訊 $ npm v lodash Lodash modular utilities. https://lodash.com/ keywords: modules, stdlib, util dist .tarball: https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz .shasum: 679591c564c3bffaae8454cf0b3df370c3d6911c .integrity: sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg== .unpackedSize: 1.4 MB maintainers: - mathias \u0026lt;mathias@qiwi.be\u0026gt; - jdalton \u0026lt;john.david.dalton@gmail.com\u0026gt; - bnjmnt4n \u0026lt;benjamin@dev.ofcr.se\u0026gt; dist-tags: latest: 4.17.21 published a year ago by bnjmnt4n \u0026lt;benjamin@dev.ofcr.se\u0026gt; 5.查看專案中是否有已過時的依賴套件 - npm outdated # 在終端機中先切換到專案的目錄中 - $ cd project-name # 以下指令是在 \u0026#34;form-validation\u0026#34; 專案目錄中執行的結果 $ npm outdated 6.查看是否 node_modules 有相關資安漏洞 - npm audit # 以下指令是在 \u0026#34;form-validation\u0026#34; 專案目錄中執行的結果, 可發現此專案中有6個相依套件有資案漏洞 $ npm audit # npm audit report decode-uri-component \u0026lt;0.2.1 decode-uri-component vulnerable to Denial of Service (DoS) - https://github.com/advisories/GHSA-w573-4hg7-7wgq fix available via `npm audit fix` node_modules/decode-uri-component engine.io 4.0.0 - 6.2.0 Severity: moderate Uncaught exception in engine.io - https://github.com/advisories/GHSA-r7qp-cfhv-p84w fix available via `npm audit fix` node_modules/engine.io loader-utils 2.0.0 - 2.0.3 || 3.0.0 - 3.2.0 Severity: critical Prototype pollution in webpack loader-utils - https://github.com/advisories/GHSA-76p3-8jx3-jpfq loader-utils is vulnerable to Regular Expression Denial of Service (ReDoS) via url variable - https://github.com/advisories/GHSA-3rfm-jhwj-7488 loader-utils is vulnerable to Regular Expression Denial of Service (ReDoS) via url variable - https://github.com/advisories/GHSA-3rfm-jhwj-7488 fix available via `npm audit fix` node_modules/adjust-sourcemap-loader/node_modules/loader-utils node_modules/babel-loader/node_modules/loader-utils node_modules/loader-utils node_modules/resolve-url-loader/node_modules/loader-utils @angular-devkit/build-angular 0.1001.0-next.0 - 12.2.17 || 13.0.0-next.0 - 13.3.9 || 14.0.0-next.0 - 14.2.9 || 15.0.0-next.0 - 15.0.0-rc.5 Depends on vulnerable versions of loader-utils Depends on vulnerable versions of terser node_modules/@angular-devkit/build-angular socket.io-parser 4.0.0 - 4.0.4 Severity: critical Insufficient validation when decoding a Socket.IO packet - https://github.com/advisories/GHSA-qm95-pgcg-qqfq fix available via `npm audit fix` node_modules/socket.io-parser terser 5.0.0 - 5.14.1 Severity: high Terser insecure use of regular expressions before v4.8.1 and v5.14.2 leads to ReDoS - https://github.com/advisories/GHSA-4wf5-vphf-c2xc fix available via `npm audit fix` node_modules/terser @angular-devkit/build-angular 0.1001.0-next.0 - 12.2.17 || 13.0.0-next.0 - 13.3.9 || 14.0.0-next.0 - 14.2.9 || 15.0.0-next.0 - 15.0.0-rc.5 Depends on vulnerable versions of loader-utils Depends on vulnerable versions of terser node_modules/@angular-devkit/build-angular 6 vulnerabilities (1 low, 1 moderate, 2 high, 2 critical) To address all issues, run: npm audit fix 自動修正相關相依套件的漏洞 $ npm audit fix ","permalink":"https://calvinegs.github.io/posts/npm-commands/","summary":"本篇筆記是除了以下常用的 npm 指令外，要介紹幾個好用的其他 npm 指令\n npm \u0026ndash;version (檢查在本端主機上安裝的 npm 版本) npm init (在現行目錄中初始化專案) npm list (顯示所有已安裝在專案中的所有套件) npm install (在專案中安裝套件) npm uninstall (移除已安裝在專案中的套件)  1.開啟套件的說明文件 - npm docs $ npm docs [package-name] #例如以下指令將會自動開啟 lodash 套件的說明網頁 $ npm docs lodash 2.開啟套件的原始碼儲存庫網頁 - npm repo $ npm repo [package-name] #例如以下指令將會自動開啟 lodash 套件的原始碼儲存庫網頁 $ npm repo lodash 3.查看套件的版本資訊 $ npm v [package-name] versions #以下指令將直接在 終端機 上顯示所有 lodash 套件的版本資訊 $ npm v lodash versions [ \u0026#39;0.","title":"好用的 npm 指令"},{"content":"TypeScript 的許多功能是透過 TypeScript 編譯器 (tsc) 來實現的。tsc 有許多選項可以用來調整編譯過程的行為。\n設置專案 建立一個目錄\n$ mkdir tsc-options $ cd tsc-options 透過 npm 產生 package.json 檔案 $ npm init -y 在 Local 端安裝 TypeScript $ npm install --save-dev typescript@4.8.3 #or -D TypeScript 選項值設定 透過 tsc 建立 TypeScript 的設定檔 (tsconfig.json) $ npx tsc --init P.S. 由於 typescript 是安裝在 local，執行時要透過 npx 指令(由 npm 所提供)\nTypeScript 選項值影響 先在專案目錄下建立 src 子目錄，並在此目錄下撰寫程式\n$ mkdir src $ touch src/index.ts 程式如下:\nfunction add(a, b) { return a + b; } add(25, null); 上述的程式可否通過 tsc 型態檢核呢？ 答案很難回答，因為取決於“tsc 選項”的設定。\n若直接以預設的情況執行編譯，則會有以下的錯誤訊息。\n$ npx tsc src/index.ts:1:14 - error TS7006: Parameter \u0026#39;a\u0026#39; implicitly has an \u0026#39;any\u0026#39; type. 1 function add(a, b) { ~ src/index.ts:1:17 - error TS7006: Parameter \u0026#39;b\u0026#39; implicitly has an \u0026#39;any\u0026#39; type. 1 function add(a, b) { ~ Found 2 errors in the same file, starting at: src/index.ts:1 等你調整了 tsconfig.json 中的 \u0026ldquo;noImplicitAny\u0026rdquo; 選項（= false）設定後，再執行一次編譯處理，竟然就成功了！\n1 2 3 4 5 6 7 8 9 10 11  //tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { //...  /* Type Checking */ \u0026#34;strict\u0026#34;: true, /* Enable all strict type-checking options. */ \u0026#34;noImplicitAny\u0026#34;: false, /* Enable error reporting for expressions and declarations with an implied \u0026#39;any\u0026#39; type. */  // \u0026#34;strictNullChecks\u0026#34;: true, /* When type checking, take into account \u0026#39;null\u0026#39; and \u0026#39;undefined\u0026#39;. */  //...  } }   我們來看看到底是怎麼一回事 首先，先打開 tsconfig.json 選項設定檔中的 \u0026ldquo;declaration\u0026rdquo; 選項 （\u0026ldquo;declaration\u0026rdquo;: true,）\n1 2 3 4 5 6 7 8 9  //tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { //...  /* Emit */ \u0026#34;declaration\u0026#34;: true,  //...  } }   再執行一次編譯處理，隨著已開啟 \u0026ldquo;declaration\u0026rdquo;: true 選項值，tsc 編譯器會在 index.ts 原始碼的相同目錄中産生了 index.js \u0026amp; index.d.ts 二個編譯結果檔案。\nindex.js 是 index.ts 編譯完成的 js 程式結果檔。 index.d.ts 則是編譯過程式預設會産生的 TypeScript 型態定義檔。開啟 index.d.ts，內容如下：\ndeclare function add(a: any, b: any): any; 原來 tsc 把你在 index.ts 所撰寫沒有型態註記的程式碼，自行推論為型態都是使用 any。搭配著前述 “noImplicitAny\u0026quot;選項值是 true 或 false (預設值為 true) 才會産生編譯成功或失敗的結果呀。（“noImplicitAny”選項的用途是：若資料沒有型別註記，禁止 TypeScript 隱性推論其型別為 any 型別）\n解決了一個疑問，心中是否又産生另一個疑問呢： 不是編譯失敗(型態有誤）嗎？怎麼還會産生 js 檔案呢？原來輸出程式碼與型態檢查的結果完全無關，所以型能有誤的程式是可以産生輸出的。你可以把 TypeScript 的錯誤視為是警告訊息，雖然可能是一個人值得追查的問題，但不會中斷組建的程序。那可否要求若有錯誤發生時不要産生結果檔案呢？可以的，透過“noEmitOnError”選項來控制，它的預設值是false，若你開啟 tsconfig.json “noEmitOnError”選項，並把它的值設成 true，則當編譯過程有錯誤時就不會還産生 js 檔案了。\ntsc 編譯選項    編譯設定選項 說明     allowJs 是否允許原始碼中包括 JavaScript 檔案 (.js)   alwaysStrict 在 JavaScript 啟用嚴格模式，並在每個文件中加入‘use strict’   allowSyntheticDefaultImports 模組沒有宣告預設匯出的功能，或遵循 commonJs 規範時，允許使用 import \u0026hellip; from \u0026hellip; 語法 (用來提高對舊版模組的相容性)   baseUrl 設定根目錄位置，以便用相對路徑尋找模組   checkJs 需搭配 allowJs 選項，在編譯 JavaScript 原始檔案時檢查其中的錯誤   declaration 對專案中的所有 TypeScript 或 JavaScript 原始檔産生 .d.ts 型別宣告檔   downlevelIteration 程式中若使用到　Symbol 完訪器，啟用此選項可更精確地對 ES5 環境模擬出適當的 ES2015 完訪器   emitDecoratorMetadata 需搭配 experimentalDecorators 選項，在輸出的 JavaScript 中包含裝飾器元數據 (decorator metadata)   esModuleInterop 需搭配 allowSyntheticDefaultImports 選項，若 CommonJS/AMD/UMD 模組沒有宣告預設匯出的功能,就加入額外的輔助程式碼來使之符合 ES2015 模組。若使用 commonjs 為此專案的 module system，則此設定值必須設定為 true   experimentalDecorators 允許使用函式裝飾器 (decorator)   forceConsitentCasingInFileNames 要求匯入的模組名稱必須和實際檔案名稱有一致的大小寫   importHelpers 在針對舊版 JavaScript 編譯時，TypeScript 會插入輔助程式好模擬 ES2015 的功能。啟用此選項可減少輔助程式碼的重複量   isolatedModules 將每個檔案視為單獨模組，以利 Babel 工具一次編譯一個檔案時不會發生問題   jsx 決定 JSX/TSX 檔案中對 HTML 元素的轉譯方式   jsxFactory 指定工廠函式(factory function)，用它來轉譯 JSX/TSX 檔案中的 HTML 元素   lib 指定編譯器要選使用的定義檔   module 指定用那種模組規範來進行編譯   moduleResoultion 指定模組的解析方式(可設為相容於 TypeScript 舊版的 \u0026ldquo;classic\u0026rdquo; 或新版的 \u0026ldquo;node\u0026rdquo;)   noEmit 要求編輯器不要輸出 JavaScript 程式碼，等同於只檢查程式碼正確與否   noImplicitany 若資料沒有型別註記，禁止 TypeScript 隱性推論其型別為 any 型別   noImplicitReturns 要求函式中的任何執行途徑都必須用 return 傳回結果   noImplicitThis this 表逹式的值不能為 any 型態   noUnusedParameters 要求函式中所有參數都必須有用到   outDir 指定編譯生成的 JavaScript 檔案的輸出目錄   paths 若模組位於 baseUrl 以外的位置，可用 path 定義其路徑   outFile 將輸出文件合併成一個檔案　   resolveJsonModule 若專案會使用 JSON，則此設定值必須設定為 true   rootDir tsc 編譯器找尋程式的目錄。若要編譯 TypeScript 檔案位於多個目錄內，可用 rootDir 將它們組織成單一一個虛擬目錄   skipLibCheck 跳過宣告定義檔的檢查，以加快編譯速度   sourceMap 決定編譯器是否要生成除錯用的 source map 檔案   strict 啟用 TypeScript 的所有相關嚴格模式   strictNullChecks 把 null 和 undefined 視為獨立型別， 並禁止你將它們賦值給其他型別的變數   suppressExcessPropertyErrors 在試圖使用不存在的物件屬性時不回報錯誤。用來與舊版 TypeScript 相容   target 指定要以那個 JavaScript 版本為編譯目標   traceResolution 印出編譯器解析模組的詳細過程   typeRoots 限制編譯器尋找宣告檔案的位置   types 指定編譯時要加入的宣告檔   removeComments 編譯後刪除所有註解    module 參數可指定的值    名稱 說明     none 關閉模組功能   commonjs 指定使用 CommonJS 模組格式，在設為 es3 或 es5 時會預設啟用。 也是 Node.js 環境預設害援的規範   amd 指定使用 AMD (Asynchronous Module Definition, 非同步模組)，是 RequireJS模組載入工具支援的規範   system 指定使用 SystemJS 模組載入工具支援的模組規範   umd 指定使用 UMD (Universal Module Definition, 通用模組定義) 規範   es2015/es6 指定使用 ES2015 的 ECMAScript 模組規範   es2020 指定使用 ES2020 的 ECMAScript 模組規範   esnext 指定使用下一版 JavaScript 的模組規範    compilerOption中 lib 屬性選項（設定編譯時要加入的函式庫）    名稱 說明     es5, es2015, es2016, 2017\u0026hellip; 引入這幾個值所對應之版本的定義。舊的命名法同樣可用，所以 es6 亦可寫成 es2015   esnext 引入 JavaScript 預定新增、但尚未正式採用的新功能，其實際內容將隨時間而改變   dom 引入 DOM 文件物件模型的相關定義， console 物件也是定義在這裡。網頁應用程式需要依賴它們來操偏瀏覧器內的 HTML 元素內容。   dom.iterable 引入 DOM API 的額外相關定義，讓應用程式能走訪 HTML 元素   scriptHost 引入 Windowss Script Host 的相關定義，以便在 Windows 系統自動執行程式   webworker 引入 web worker 的相關定義，讓網頁應用程式得以執行背景工作    檢查編譯器能存取的檔案 $ npx tsc --listFiles\nNPM 版本格式    名稱 說明     3.8.1 只接受這個特定版本   * 星號表示接受任何版本   \u0026gt;3.8.1 \u0026gt;=3.8.1 任何大於、或大於等於此版本的套件均可使用   \u0026lt;3.8.1 \u0026lt;=3.8.1 任何小於、或小於等於此版本的套件均可使用   ~3.8.1 加入 ~ 表示修訂版本號以外的版本編號相同即可   ^3.8.1 加入 ^ 表示主版本號相同即可，次版本號或修訂版本號不同也可以接受    版本編號 3.8.1\n major version number: 主版本編號 3 minor version number: 次版本編號 8 revision version number: 修訂版本編號 1  ","permalink":"https://calvinegs.github.io/posts/typescript-compiler-options/","summary":"TypeScript 的許多功能是透過 TypeScript 編譯器 (tsc) 來實現的。tsc 有許多選項可以用來調整編譯過程的行為。\n設置專案 建立一個目錄\n$ mkdir tsc-options $ cd tsc-options 透過 npm 產生 package.json 檔案 $ npm init -y 在 Local 端安裝 TypeScript $ npm install --save-dev typescript@4.8.3 #or -D TypeScript 選項值設定 透過 tsc 建立 TypeScript 的設定檔 (tsconfig.json) $ npx tsc --init P.S. 由於 typescript 是安裝在 local，執行時要透過 npx 指令(由 npm 所提供)\nTypeScript 選項值影響 先在專案目錄下建立 src 子目錄，並在此目錄下撰寫程式\n$ mkdir src $ touch src/index.ts 程式如下:\nfunction add(a, b) { return a + b; } add(25, null); 上述的程式可否通過 tsc 型態檢核呢？ 答案很難回答，因為取決於“tsc 選項”的設定。","title":"TypeScript 編譯器的選項"},{"content":"github Source code\nAngular、React、Vue 是三個最受歡迎的前端框架，這是三篇筆記分別使用這三個不同的框架來建立功能一模一樣的網路應用程式中的第三篇 - 使用 Vue 來建立網路應用程式。\n這個網路應用程式的需求\n 産品訂購功能  表頭：訂購商品總數、總額及送出訂單功能 商品過濾功能：依産品類別來顯示商品 商品清單：顯示商品明細、商品售價、訂購數量下拉選單及加入購物車等功能   訂單確認功能：顯示訂購商品明細及總金額 訂購成功功能：顯示訂購完成資訊  使用技術:\n Vue 3 Bootstrap 5 (UI Framework) Vue Router 4 Vuex 4 axios 0.27 NodeJS 18.5 \u0026amp; Express 4.18 json-server 0.17.0 npm-run-all 4.1.5 (npm 套件) @vue/cli  建立新專案 使用下列的 npx 語法即可建立最新版 Vue 預設的應用程式結構\n$ npx @vue/cli create vueapp Vue CLI v5.0.8 ? Please pick a preset: Manually select features ? Check the features needed for your project: (Press \u0026lt;space\u0026gt; to select, \u0026lt;a\u0026gt; to toggle all, \u0026lt;i\u0026gt; to invert selection, and \u0026lt;enter\u0026gt; to proceed) ◉ Babel ◉ TypeScript ◯ Progressive Web App (PWA) Support ◉ Router ❯◉ Vuex ◯ CSS Pre-processors ◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing ? Choose a version of Vue.js that you want to start the project with 3.x ? Use class-style component syntax? No ? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes ? Use history mode for router? (Requires proper server setup for index fallback in production) Yes ? Pick a linter / formatter config: Basic ? Pick additional lint features: Lint on save ? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files ? Save this as a preset for future projects? No Vue CLI v5.0.8 ✨ Creating project in /home/egs/tmp/vueapp. 🗃 Initializing git repository... ⚙️ Installing CLI plugins. This might take a while... yarn install v1.22.19 info No lockfile found. [1/4] Resolving packages... [2/4] Fetching packages... [3/4] Linking dependencies... success Saved lockfile. Done in 19.80s. 🚀 Invoking generators... 📦 Installing additional dependencies... yarn install v1.22.19 [1/4] Resolving packages... [2/4] Fetching packages... [3/4] Linking dependencies... [4/4] Building fresh packages... success Saved lockfile. Done in 23.14s. ⚓ Running completion hooks... 📄 Generating README.md... 🎉 Successfully created project vueapp. 👉 Get started with the following commands: $ cd vueapp $ yarn serve 查看 package.json 中相依套件及版本 $ cd vueapp $ cat package.json { \u0026#34;name\u0026#34;: \u0026#34;vueapp\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.1.0\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;scripts\u0026#34;: { \u0026#34;serve\u0026#34;: \u0026#34;vue-cli-service serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-cli-service build\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;vue-cli-service lint\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;core-js\u0026#34;: \u0026#34;^3.8.3\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;^3.2.13\u0026#34;, \u0026#34;vue-router\u0026#34;: \u0026#34;^4.0.3\u0026#34;, \u0026#34;vuex\u0026#34;: \u0026#34;^4.0.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@typescript-eslint/eslint-plugin\u0026#34;: \u0026#34;^5.4.0\u0026#34;, \u0026#34;@typescript-eslint/parser\u0026#34;: \u0026#34;^5.4.0\u0026#34;, \u0026#34;@vue/cli-plugin-babel\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;@vue/cli-plugin-eslint\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;@vue/cli-plugin-router\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;@vue/cli-plugin-typescript\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;@vue/cli-plugin-vuex\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;@vue/cli-service\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;@vue/eslint-config-typescript\u0026#34;: \u0026#34;^9.1.0\u0026#34;, \u0026#34;eslint\u0026#34;: \u0026#34;^7.32.0\u0026#34;, \u0026#34;eslint-plugin-vue\u0026#34;: \u0026#34;^8.0.3\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~4.5.5\u0026#34; } } 産生的預設程式結構 執行由 CLI 産生的預設程式架構 $ yarn serve yarn run v1.22.19 $ vue-cli-service serve INFO Starting development server... DONE Compiled successfully in 1436ms 下午4:10:07 App running at: - Local: http://localhost:8080/ - Network: http://192.168.0.125:8080/ Note that the development build is not optimized. To create a production build, run yarn build. 開啟瀏覽器，輸入 http://localhost:8080\n$ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial Commit\u0026#34; # 加入 git 新版本 $ code . # 打開 vscode 使用 json-server 當作後端 Web Api 在我們的前端應用程式中會使用到後端伺服器的資料，方便起見直接使用 json-server　來當作後端 Web Api\n安裝 json-server $ npm install --save-dev json-server@0.17.0 npm-run-all@4.1.5\n建立給 json-server 使用的資料 $ touch data.json # data.json 內容如下 { \u0026#34;products\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;kayak\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Watersports\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A boat form on person\u0026#34;, \u0026#34;price\u0026#34;: 275 }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;Lifejacket\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Watersports\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Protective and fashionable boat form on person\u0026#34;, \u0026#34;price\u0026#34;: 48.95 }, { \u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;Soccer Ball\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Soccer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;FIFA-approved size and weight\u0026#34;, \u0026#34;price\u0026#34;: 19.5 }, { \u0026#34;id\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;Corner Flags\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Soccer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Give your playing field a professional touch\u0026#34;, \u0026#34;price\u0026#34;: 34.95 }, { \u0026#34;id\u0026#34;: 5, \u0026#34;name\u0026#34;: \u0026#34;Stadium\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Soccer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Flat-packed 35,000-seat stadium\u0026#34;, \u0026#34;price\u0026#34;: 79500 }, { \u0026#34;id\u0026#34;: 6, \u0026#34;name\u0026#34;: \u0026#34;Thinking Cap\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Imporove brain efficiency by 75%\u0026#34;, \u0026#34;price\u0026#34;: 16 }, { \u0026#34;id\u0026#34;: 7, \u0026#34;name\u0026#34;: \u0026#34;Unsteady Chair\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Secretly give your opponent a disadvantage\u0026#34;, \u0026#34;price\u0026#34;: 29.95 }, { \u0026#34;id\u0026#34;: 8, \u0026#34;name\u0026#34;: \u0026#34;Human Chess Board\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A fun game for the family\u0026#34;, \u0026#34;price\u0026#34;: 75 }, { \u0026#34;id\u0026#34;: 9, \u0026#34;name\u0026#34;: \u0026#34;Bling Bling King\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Gold-plated, diamond-studded King\u0026#34;, \u0026#34;price\u0026#34;: 1200 } ], \u0026#34;orders\u0026#34;: [ ] } 測試 json-server $ npx json-server data.json -p 4600 # 使用 4600 port \\{^_^}/ hi! Loading data.json Done Resources http://localhost:4600/products http://localhost:4600/orders Home http://localhost:4600 Type s + enter at any time to create a snapshot of the database GET /db 304 1.630 ms - - GET /__rules 404 4.536 ms - 2 設定 npm script in package.sjon // ...  \u0026#34;scripts\u0026#34;: { \u0026#34;serve\u0026#34;: \u0026#34;vue-cli-service serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-cli-service build\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;vue-cli-service lint\u0026#34;, \u0026#34;json\u0026#34;: \u0026#34;json-server data.json -p 4600\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;npm-run-all -p serve json\u0026#34; }, // ... 在專案中使用 Bootstrap CSS 套件 安裝 bootstrap 5 $ npm install bootstrap@5.2.0\n引入 bootstrap in main.ts // ./src/main.ts import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import \u0026#34;bootstrap/dist/css/bootstrap.css\u0026#34;; createApp(App).use(store).use(router).mount(\u0026#39;#app\u0026#39;) 為網站加入資料 建立資料模型 $ mkdir ./src/data \u0026amp;\u0026amp; touch ./src/data/entities.ts\nentities.ts 檔案內容如下：\n// ./src/data/entities.ts export class Product { constructor( public id: number, public name: string, public description: string, public category: string, public price: number) {} } export class OrderLine { constructor(public product: Product, public quantity: number) { } get total(): number { return this.product.price * this.quantity; } } export class Order { private lines: OrderLine[] = []; constructor(initialLines?: OrderLine[]) { if (initialLines) { this.lines.push(...initialLines); } } public addProduct(prod: Product, quantity: number) { const index = this.lines.findIndex(ol =\u0026gt; ol.product.id === prod.id); if (index \u0026gt; -1) { if (quantity === 0) { this.removeProduct(prod.id); } else { this.lines[index].quantity += quantity; } } else { this.lines.push(new OrderLine(prod, quantity)); } } public removeProduct(id: number) { this.lines = this.lines.filter(ol =\u0026gt; ol.product.id !== id); } get orderLines(): OrderLine[] { return this.lines; } get productCount(): number { return this.lines.reduce((total, ol) =\u0026gt; total += ol.quantity, 0); } get total(): number { return this.lines.reduce((total, ol) =\u0026gt; total += ol.total, 0); } } 建立商品訂購相關元件 $ touch ./src/components/ProductItem.vue $ touch ./src/components/CategoryList.vue $ touch ./src/components/Header.vue $ touch ./src/views/ProductList.vue 商品明細元件 (ProductItem) // ProductItem.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;card m-1 p-1 bg-light\u0026#34;\u0026gt; \u0026lt;h4\u0026gt; {{ product?.name }} \u0026lt;span class=\u0026#34;badge rounded-pill bg-primary float-end\u0026#34;\u0026gt; ${{ product?.price.toFixed(2) }} \u0026lt;/span\u0026gt; \u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;card-text bg-white p-1\u0026#34;\u0026gt; {{ product?.description }} \u0026lt;button class=\u0026#34;btn btn-success btn-sm float-end\u0026#34; @click=\u0026#34;handleAddToCart\u0026#34;\u0026gt; Add To Cart \u0026lt;/button\u0026gt; \u0026lt;select class=\u0026#34;from-control-inline float-end m-1\u0026#34; v-model.number=\u0026#34;quantity\u0026#34;\u0026gt; \u0026lt;option\u0026gt;1\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;2\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent, PropType } from \u0026#34;vue\u0026#34;; import { Product } from \u0026#34;../data/entities\u0026#34;; export default defineComponent({ name: \u0026#34;ProductItem\u0026#34;, props: { product: { type: Object as PropType\u0026lt;Product\u0026gt;, }, }, data() { return { quantity: 1, }; }, methods: { handleAddToCart() { this.$emit(\u0026#34;addToCart\u0026#34;, { product: this.product, quantity: this.quantity, }); }, }, }); \u0026lt;/script\u0026gt; 商品分類按鈕元件 (CategoryList.vue) // CategoryList.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;d-grid gap-2\u0026#34;\u0026gt; \u0026lt;button v-for=\u0026#34;c in categories\u0026#34; v-bind:key=\u0026#34;c\u0026#34; v-bind:class=\u0026#34;getButtonClasses(c)\u0026#34; @click=\u0026#34;selectCategory(c)\u0026#34;\u0026gt; {{ c }} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent, PropType } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#34;CategoryList\u0026#34;, props: { categories: { type: Object as PropType\u0026lt;string[]\u0026gt;, require: true }, selected: { type: String as PropType\u0026lt;string\u0026gt;, }, }, methods: { selectCategory(category: string) { this.$emit(\u0026#34;selectCategory\u0026#34;, category); }, getButtonClasses(category: string): string { const btnClass = this.selected === category ? \u0026#34;btn-primary\u0026#34; : \u0026#34;btn-secondary\u0026#34;; return `btn ${btnClass}`; }, }, }); \u0026lt;/script\u0026gt; 表頭元件 (Header) // Header.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;p-1 bg-secondary text-white text-end\u0026#34;\u0026gt; {{ displayText }} \u0026lt;!-- \u0026lt;button class=\u0026#34;btn btn-sm btn-primary m-1\u0026gt;\u0026#34;\u0026gt;Submit Order\u0026lt;/button\u0026gt; --\u0026gt; \u0026lt;router-link to = \u0026#34;/order\u0026#34; class=\u0026#34;btn btn-sm btn-primary m-1\u0026#34;\u0026gt; Submit Order \u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { Order } from \u0026#39;@/data/entities\u0026#39;; import { defineComponent, PropType } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#34;Header\u0026#34;, props: { order: { type: Object as PropType\u0026lt;Order\u0026gt;, required: true }, }, computed: { displayText(): string { const count = this.order.productCount; return count === 0 ? \u0026#34;(No Selection)\u0026#34; : `${count}Product(s), $${this.order.total.toFixed(2)}`; }, }, }); \u0026lt;/script\u0026gt;``` ### 商品清單元件 (ProductList) ```tsx // ./views/ProductList.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Header v-bind:order=\u0026#34;order\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-3 p-2\u0026#34;\u0026gt; \u0026lt;CategoryList v-bind:categories=\u0026#34;categories\u0026#34; v-bind:selected=\u0026#34;selectedCategory\u0026#34; @selectCategory=\u0026#34;handleSelectCategory\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-9 p-2\u0026#34;\u0026gt; \u0026lt;ProductItem v-for=\u0026#34;p in filteredProducts\u0026#34; v-bind:key=\u0026#34;p.id\u0026#34; v-bind:product=\u0026#34;p\u0026#34; @addToCart=\u0026#34;handleAddToCart\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; import { Order, Product } from \u0026#39;@/data/entities\u0026#39;; import ProductItem from \u0026#34;../components/ProductItem.vue\u0026#34; import CategoryList from \u0026#34;../components/CategoryList.vue\u0026#34; import Header from \u0026#34;../components/Header.vue\u0026#34; export default defineComponent({ name: \u0026#34;ProductList\u0026#34;, components: { ProductItem, CategoryList, Header }, data() { const products: Product[] = []; [1, 2, 3, 4, 5].map((num) =\u0026gt; products.push( new Product(num, `Prod${num}`, `Product ${num}`, `Cat${num % 2}`, 100))); return { products, selectedCategory: \u0026#34;All\u0026#34;, order: new Order() }; }, computed: { categories(): string[] { return [\u0026#34;All\u0026#34;, ...new Set\u0026lt;string\u0026gt;(this.products.map((p) =\u0026gt; p.category))]; }, filteredProducts(): Product[] { return this.products.filter((p) =\u0026gt; this.selectedCategory == \u0026#34;All\u0026#34; || this.selectedCategory === p.category); } }, methods: { handleSelectCategory(category: string) { this.selectedCategory = category; }, handleAddToCart(data: { product: Product; quantity: number; }) { this.order.addProduct(data.product, data.quantity); }, }, }); \u0026lt;/script\u0026gt; 修改 App.vue 內容如下：\n// ./src/App.vue \u0026lt;template\u0026gt; \u0026lt;ProductList /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; import ProductList from \u0026#34;./views/ProductList.vue\u0026#34; export default defineComponent({ name: \u0026#34;App\u0026#34;, components: { ProductList }, }); \u0026lt;/script\u0026gt; 檔案結構 執行程式 $ npm start ERROR Failed to compile with 1 error 下午6:39:49 [eslint] /home/egs/cal-data/tech-test/typescript/book/vueapp/src/components/Header.vue 17:11 error Component name \u0026#34;Header\u0026#34; should always be multi-word vue/multi-word-component-names ✖ 1 problem (1 error, 0 warnings) You may use special comments to disable some warnings. Use // eslint-disable-next-line to ignore the next line. Use /* eslint-disable */ to ignore all warnings in a file. ERROR in [eslint] /home/egs/cal-data/tech-test/typescript/book/vueapp/src/components/Header.vue 17:11 error Component name \u0026#34;Header\u0026#34; should always be multi-word vue/multi-word-component-names ✖ 1 problem (1 error, 0 warnings) webpack compiled with 1 error 執行時發生錯誤，由訊息中可看出是因為 Header.vue 這個元件的命名所導致。esline 預設的命名檢核規則必須是要超過一個英文字(Word)。解決方法有二：一是將 Header.vue 改名為二個字，如FunHeader.vue。第二個方法是修改 esline 中的檢核規則，避掉 multi word naming 的檢核。\n加入第十七行的設定\nmodule.exports = { root: true, env: { node: true }, 'extends': [ 'plugin:vue/vue3-essential', 'eslint:recommended', '@vue/typescript/recommended' ], parserOptions: { ecmaVersion: 2020 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', 'vue/multi-word-component-names': 0 // 避掉 compoenent 必須是要 Multi word Name } } 使用 Data Store 來管理 Vue 應用程式的資料 在大多數的 Vue 專案中，應用程式的資料是交由 Vuex 套件來管理。它提供　\u0026ldquo;data store\u0026rdquo; 功能已經整合到 Vue.js　的 API 內。\n安裝 Vuex 在本筆記開頭，使用 vue/cli 建立專案時，我們已選擇使用 vuex 選項，所以在 package.json 中已 有 vuex 套件的安裝資訊。若在建立專案時未選擇使用 vuex，則須自行手動安裝 vuex 套件。\n$ npm install vuex@4.0.0 建立 data store // ./src/data/index.ts import { Order, Product } from \u0026#39;@/data/entities\u0026#39; import { createStore } from \u0026#39;vuex\u0026#39; export interface StoreState { products: Product[], order: Order, selectedCategory: string, } type ProductSelection = { product: Product, quantity: number } export default createStore\u0026lt;StoreState\u0026gt;({ state: { products: [1, 2, 3, 4, 5].map(num =\u0026gt; new Product( num, `StoreProd${num}`, `Product${num}`, `Cat${num % 2}` , 450) ), order: new Order(), selectedCategory: \u0026#34;All\u0026#34;, }, mutations: { selectCategory(currentState: StoreState, category: string) { currentState.selectedCategory = category; }, addToOrder(currentState: StoreState, selection: ProductSelection) { currentState.order.addProduct(selection.product, selection.quantity); } }, getters: { categories(state): string[] { return [\u0026#34;All\u0026#34;, ...new Set(state.products.map(p =\u0026gt; p.category))]; }, filteredProducts(state): Product[] { return state.products.filter(p =\u0026gt; state.selectedCategory === \u0026#34;All\u0026#34; || state.selectedCategory === p.category); } }, actions: { }, modules: { } }) 將元件連結至 data store 修改 Header.vue 內容如下：\n// ./src/components/Header.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;p-1 bg-secondary text-white text-end\u0026#34;\u0026gt; {{ displayText }} \u0026lt;button class=\u0026#34;btn btn-sm btn-primary m-1\u0026gt;\u0026#34;\u0026gt;Submit Order\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent, PropType } from \u0026#39;vue\u0026#39;; import { useStore } from \u0026#34;vuex\u0026#34;; export default defineComponent({ name: \u0026#34;Header\u0026#34;, setup() { return {store: useStore()}; }, computed: { displayText(): string { // const count = this.order.productCount;  // return count === 0 ? \u0026#34;(No Selection)\u0026#34; : `${count} Product(s), $${this.order.total.toFixed(2)}`;  const count = this.store.state.order.productCount; return count === 0 ? \u0026#34;(No Selection)\u0026#34; : `${count}Product(s) ` + `$${this.store.state.order.total.toFixed(2)}`; }, }, }); \u0026lt;/script\u0026gt; 修改　ProductList.vue　如下：\n// ./src/views/ProductList.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Header v-bind:order=\u0026#34;order\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-3 p-2\u0026#34;\u0026gt; \u0026lt;CategoryList v-bind:categories=\u0026#34;categories\u0026#34; v-bind:selected=\u0026#34;selectedCategory\u0026#34; @selectCategory=\u0026#34;handleSelectCategory\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-9 p-2\u0026#34;\u0026gt; \u0026lt;ProductItem v-for=\u0026#34;p in filteredProducts\u0026#34; v-bind:key=\u0026#34;p.id\u0026#34; v-bind:product=\u0026#34;p\u0026#34; @addToCart=\u0026#34;handleAddToCart\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { Order, Product } from \u0026#39;@/data/entities\u0026#39;; import { defineComponent } from \u0026#39;vue\u0026#39;; import ProductItem from \u0026#34;../components/ProductItem.vue\u0026#34; import CategoryList from \u0026#34;../components/CategoryList.vue\u0026#34; import Header from \u0026#34;../components/Header.vue\u0026#34; import { mapMutations, mapState, mapGetters } from \u0026#39;vuex\u0026#39;; import { StoreState } from \u0026#34;../store\u0026#34;; export default defineComponent({ name: \u0026#34;ProductList\u0026#34;, components: { ProductItem, CategoryList, Header }, data() { const products: Product[] = []; [1, 2, 3, 4, 5].map((num) =\u0026gt; products.push( new Product(num, `Prod${num}`, `Product ${num}`, `Cat${num % 2}`, 100))); return { products, selectedCategory: \u0026#34;All\u0026#34;, order: new Order() }; }, computed: { ... mapState\u0026lt;StoreState\u0026gt;({ selectedCategory: (state: StoreState) =\u0026gt; state.selectedCategory, products: (state: StoreState) =\u0026gt; state.products, order: (state: StoreState) =\u0026gt; state.order, }), ...mapGetters([\u0026#34;filteredProducts\u0026#34;, \u0026#34;categories\u0026#34;]), }, methods: { ...mapMutations({ handleSelectCategory: \u0026#34;selectCategory\u0026#34;, handleAddToCart: \u0026#34;addToOrder\u0026#34;, }), }, }); \u0026lt;/script\u0026gt; 使用 data store 的測試結果 修改程式改由網路服務取得資料 修改 data store 程式內容 import { Order, Product } from \u0026#39;@/data/entities\u0026#39; import { createStore } from \u0026#39;vuex\u0026#39; export interface StoreState { products: Product[], order: Order, selectedCategory: string, storedId: number } type ProductSelection = { product: Product, quantity: number } export default createStore\u0026lt;StoreState\u0026gt;({ state: { products: [1, 2, 3, 4, 5].map(num =\u0026gt; new Product( num, `StoreProd${num}`, `Product${num}`, `Cat${num % 2}` , 450) ), order: new Order(), selectedCategory: \u0026#34;All\u0026#34;, storedId: -1 }, mutations: { selectCategory(currentState: StoreState, category: string) { currentState.selectedCategory = category; }, addToOrder(currentState: StoreState, selection: ProductSelection) { currentState.order.addProduct(selection.product, selection.quantity); }, addProducts(currentState: StoreState, products: Product[]) { currentState.products = products; }, setOrderId(currentState: StoreState, id: number) { currentState.storedId = id; }, resetOrder(currentState: StoreState) { currentState.order = new Order(); } }, getters: { categories(state): string[] { return [\u0026#34;All\u0026#34;, ...new Set(state.products.map(p =\u0026gt; p.category))]; }, filteredProducts(state): Product[] { return state.products.filter(p =\u0026gt; state.selectedCategory === \u0026#34;All\u0026#34; || state.selectedCategory === p.category); } }, actions: { async loadProducts(context, task: () =\u0026gt; Promise\u0026lt;Product[]\u0026gt;) { const data = await task(); context.commit(\u0026#34;addProducts\u0026#34;, data); }, async storeOrder(context, task: (order: Order) =\u0026gt; Promise\u0026lt;number\u0026gt;) { context.commit(\u0026#34;setOrderId\u0026#34;, await task(context.state.order)); context.commit(\u0026#34;resetOrder\u0026#34;); }, }, modules: { } }) 建立 httpHandler.ts 在撰寫 httpHandler.ts 前要安裝 axios\n$ npm install axios@0.27.2 $ touch ./src/data/httpHandler.ts httpHandler.ts 內容如下：\nimport Axios from \u0026#34;axios\u0026#34;; import { Order, Product } from \u0026#34;./entities\u0026#34;; const protocol = \u0026#34;http\u0026#34;; const hostname = \u0026#34;localhost\u0026#34;; const port = 4600; const urls ={ products: `${protocol}://${hostname}:${port}/products`, orders: `${protocol}://${hostname}:${port}/orders` }; export class HttpHandler { loadProducts(): Promise\u0026lt;Product[]\u0026gt; { return Axios.get\u0026lt;Product[]\u0026gt;(urls.products).then(response =\u0026gt; response.data); } storeOrder(order: Order): Promise\u0026lt;number\u0026gt; { const orderData = { lines: [...order.orderLines.values()].map(ol =\u0026gt; ({ productId: ol.product.id, productName: ol.product.name, quantity: ol.quantity })) } return Axios.post\u0026lt;{id: number }\u0026gt;(urls.orders, orderData).then(response =\u0026gt; response.data.id); } } 修改 App.vue 從網路載入商品資料 \u0026lt;template\u0026gt; \u0026lt;ProductList /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent, onMounted } from \u0026#39;vue\u0026#39;; import { useStore } from \u0026#39;vuex\u0026#39;; import { HttpHandler } from \u0026#39;./data/httpHandler\u0026#39;; import ProductList from \u0026#34;./views/ProductList.vue\u0026#34; export default defineComponent({ name: \u0026#34;App\u0026#34;, components: { ProductList }, setup() { const store = useStore(); const handler = new HttpHandler(); onMounted(() =\u0026gt; store.dispatch(\u0026#34;loadProducts\u0026#34;, handler.loadProducts)); }, }); \u0026lt;/script\u0026gt; onMounted() 是 Vue.js 提供的一個元件生命週期函式。通常都會被選定在這個時機來載入外部資料。\n執行測試 程式至此已將資料連結由 local 改到 Json-Server，並將取得的資料放入 data store 中，且元件資料綁定至 data store。\n$ npm start 設定 URL 路由 雖然在筆記最前面使用 @vue/cli 來産生應用程式預設架構時，我們已選擇使用 Router 功能，但程式至此我們還沒有使用到 Router 相關功能。我們先將 App.vue template 中｀寫死｀使用 ProductList 元件的語法改成透過 router 功能來呼叫 ProductList 元件。\n修改 Router 設定資料 修改 ./src/router/index.ts 檔案，將預設産生的內容修改如下\nimport ProductList from \u0026#39;@/views/ProductList.vue\u0026#39; import { createRouter, createWebHistory, RouteRecordRaw } from \u0026#39;vue-router\u0026#39; const routes: Array\u0026lt;RouteRecordRaw\u0026gt; = [ { path: \u0026#39;/products\u0026#39;, component: ProductList }, { path: \u0026#39;/\u0026#39;, redirect: \u0026#39;/products\u0026#39; } ] const router = createRouter({ history: createWebHistory(process.env.BASE_URL), routes }) export default router 修改 App.vue 將 App.vue 中 template 寫死的程式碼（使用元件）改成  tag\n// ./src/App.vue \u0026lt;template\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent, onMounted } from \u0026#39;vue\u0026#39;; import { useStore } from \u0026#39;vuex\u0026#39;; import { HttpHandler } from \u0026#39;./data/httpHandler\u0026#39;; // import ProductList from \u0026#34;./views/ProductList.vue\u0026#34;  export default defineComponent({ name: \u0026#34;App\u0026#34;, // components: { ProductList },  setup() { const store = useStore(); const handler = new HttpHandler(); onMounted(() =\u0026gt; store.dispatch(\u0026#34;loadProducts\u0026#34;, handler.loadProducts)); }, }); \u0026lt;/script\u0026gt; 執行程式 修改後執行結果：\n完成其他功能 接下來我們要完成其餘的二個功能：訂單確認功能及訂購成功等功能，並將此二功能也加入 URL路由 設定檔中。\n加入訂單確認元件 $ touch ./src/views/OrderDetails.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3 class=\u0026#34;text-center bg-primary text-white p-2\u0026#34;\u0026gt; Order Summary \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;p-3\u0026#34;\u0026gt; \u0026lt;table class=\u0026#34;table table-sm table-striped\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt; Quantity\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; Product\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;text-end\u0026#34;\u0026gt; Price\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;text-end\u0026#34;\u0026gt; Subtotal\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;line in order.lines\u0026#34; v-bind:key=\u0026#34;line.product.id\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{ line.quantity }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ line.product.name }}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;text-end\u0026#34;\u0026gt;{{ line.product.price.toFixed(2) }}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;text-end\u0026#34;\u0026gt;{{ line.total.toFixed(2) }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th class=\u0026#34;text-end\u0026#34; colspan=\u0026#34;3\u0026#34;\u0026gt;Total:\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;text-end\u0026#34;\u0026gt;${{ order.total.toFixed(2) }}\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/products\u0026#34; class=\u0026#34;btn btn-secondary m-1\u0026#34;\u0026gt; Back \u0026lt;/router-link\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary m-1\u0026#34; @click=\u0026#34;submit\u0026#34;\u0026gt;Submit Order\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { Order } from \u0026#39;@/data/entities\u0026#39;; import { HttpHandler } from \u0026#39;../data/httpHandler\u0026#39;; import { StoreState } from \u0026#39;@/store\u0026#39;; import { defineComponent } from \u0026#39;vue\u0026#39;; import { mapActions, mapState } from \u0026#39;vuex\u0026#39;; export default defineComponent({ name: \u0026#34;OrderDetails\u0026#34;, computed: { ...mapState\u0026lt;StoreState\u0026gt;({ order: (state: StoreState) =\u0026gt; state.order, }), }, methods: { ...mapActions([\u0026#34;storeOrder\u0026#34;]), submit() { this.storeOrder((order: Order) =\u0026gt; { return new HttpHandler().storeOrder(order).then((id) =\u0026gt; { this.$router.push(\u0026#34;/summary\u0026#34;); return id; }); }); }, }, }); \u0026lt;/script\u0026gt; 加入訂購成功元件 $ touch ./src/views/Summary.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;m-2 text-center\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Thanks!\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Thanks for placing your order.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Your order is #{{ id }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;We\u0026#39;ll ship your goods as soon as possible.\u0026lt;/p\u0026gt; \u0026lt;router-link to=\u0026#34;/products\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;OK\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { StoreState } from \u0026#39;@/store\u0026#39;; import { defineComponent } from \u0026#39;vue\u0026#39;; import { mapState } from \u0026#39;vuex\u0026#39;; export default defineComponent({ name: \u0026#34;Summary\u0026#34;, computed: { ...mapState\u0026lt;StoreState\u0026gt;({ id: (state: StoreState) =\u0026gt; state.storedId, }) } }) \u0026lt;/script\u0026gt; 修改 Header.vue URL 轉址功能 // Header.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;p-1 bg-secondary text-white text-end\u0026#34;\u0026gt; {{ displayText }} \u0026lt;!-- \u0026lt;button class=\u0026#34;btn btn-sm btn-primary m-1\u0026gt;\u0026#34;\u0026gt;Submit Order\u0026lt;/button\u0026gt; --\u0026gt; \u0026lt;router-link to = \u0026#34;/order\u0026#34; class=\u0026#34;btn btn-sm btn-primary m-1\u0026#34;\u0026gt; Submit Order \u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; // import { Order } from \u0026#39;@/data/entities\u0026#39;; import { defineComponent, PropType } from \u0026#39;vue\u0026#39;; import { useStore } from \u0026#34;vuex\u0026#34;; export default defineComponent({ name: \u0026#34;Header\u0026#34;, // props: {  // order: {  // type: Object as PropType\u0026lt;Order\u0026gt;,  // required: true  // },  // },  setup() { return {store: useStore()}; }, computed: { displayText(): string { // const count = this.order.productCount;  // return count === 0 ? \u0026#34;(No Selection)\u0026#34; : `${count} Product(s), $${this.order.total.toFixed(2)}`;  const count = this.store.state.order.productCount; return count === 0 ? \u0026#34;(No Selection)\u0026#34; : `${count}Product(s) ` + `$${this.store.state.order.total.toFixed(2)}`; }, }, }); \u0026lt;/script\u0026gt; 完成路由設定 // ./src/router/index.ts import ProductList from \u0026#39;@/views/ProductList.vue\u0026#39; import OrderDetails from \u0026#39;@/views/OrderDetails.vue\u0026#39; import Summary from \u0026#39;@/views/Summary.vue\u0026#39; import { createRouter, createWebHistory, RouteRecordRaw } from \u0026#39;vue-router\u0026#39; const routes: Array\u0026lt;RouteRecordRaw\u0026gt; = [ { path: \u0026#39;/products\u0026#39;, component: ProductList }, { path: \u0026#39;/order\u0026#39;, component: OrderDetails }, { path: \u0026#39;/summary\u0026#39;, component: Summary }, { path: \u0026#39;/\u0026#39;, redirect: \u0026#39;/products\u0026#39; } ] const router = createRouter({ history: createWebHistory(process.env.BASE_URL), routes }) export default router 執行測試 佈署應用程式 使用 NodeJS \u0026amp; Express 來當作 Http Server \u0026amp; Web Api Server\n安裝 express 套件 \u0026amp; -connect-history-api-fallback 套件 $ npm install --save-dev express@4.18.1 connect-history-api-fallback@2.0.0\n建立 node 伺服器 $ touch server.js\nconst express = require(\u0026#34;express\u0026#34;); const jsonServer = require(\u0026#34;json-server\u0026#34;); const history = require(\u0026#34;connect-history-api-fallback\u0026#34;); const app = express(); app.use(history()); app.use(\u0026#34;/\u0026#34;, express.static(\u0026#34;dist\u0026#34;)); const router = jsonServer.router(\u0026#34;data.json\u0026#34;); app.use(jsonServer.bodyParser); app.use(\u0026#34;/api\u0026#34;, (req, res, next) =\u0026gt; router(req, res, next)); const port = process.argv[3] || 4003; app.listen(port, ()=\u0026gt; console.log(`Running on port ${port}`)); 修改 url 路徑 修改 httpHandler.ts\nimport Axios from \u0026#34;axios\u0026#34;; import { Order, Product } from \u0026#34;./entities\u0026#34;; // const protocol = \u0026#34;http\u0026#34;; // const hostname = \u0026#34;localhost\u0026#34;; // const port = 4600; // const urls = { // products: `${protocol}://${hostname}:${port}/products`, // orders: `${protocol}://${hostname}:${port}/orders`, // }; const urls = { products: \u0026#34;/api/products\u0026#34;, orders: \u0026#34;/api/orders\u0026#34; } export class HttpHandler { loadProducts(callback: (producs: Product[]) =\u0026gt; void): void { Axios.get(urls.products).then(response =\u0026gt; callback(response.data)) } storeOrder(order: Order, callback: (id: number) =\u0026gt; void): void { let orderData = { lines: [...order.orderLines.values()].map(ol =\u0026gt; ({ productId: ol.product.id, productName: ol.product.name, quantity: ol.quantity })) } Axios.post(urls.orders, orderData).then(response =\u0026gt; callback(response.data.id)); } } 建置 Vue App $ npm run build npm run build \u0026gt; vueapp@0.1.0 build \u0026gt; vue-cli-service build All browser targets in the browserslist configuration have supported ES module. Therefore we do not build two separate bundles for differential loading. ⠧ Building for production... WARNING Compiled with 3 warnings 下午12:03:12 [eslint] /home/egs/cal-data/tech-test/typescript/book/vueapp/src/components/Header.vue 13:27 warning \u0026#39;PropType\u0026#39; is defined but never used @typescript-eslint/no-unused-vars ✖ 1 problem (0 errors, 1 warning) You may use special comments to disable some warnings. Use // eslint-disable-next-line to ignore the next line. Use /* eslint-disable */ to ignore all warnings in a file. warning entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. Entrypoints: app (336 KiB) css/chunk-vendors.2186f2e7.css js/chunk-vendors.c958b33a.js js/app.e01e1595.js warning webpack performance recommendations: You can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application. For more info visit https://webpack.js.org/guides/code-splitting/ File Size Gzipped dist/js/chunk-vendors.c958b33a.js 139.69 KiB 49.73 KiB dist/js/app.e01e1595.js 9.58 KiB 3.57 KiB dist/css/chunk-vendors.2186f2e7.css 187.06 KiB 26.69 KiB Images and other types of assets omitted. Build at: 2022-08-28T04:03:12.312Z - Hash: b0905e88b215d52d - Time: 9430ms DONE Build complete. The dist directory is ready to be deployed. INFO Check out deployment instructions at https://cli.vuejs.org/guide/deployment.html 執行 $ node server.js Running on port 4003 功能完成後的程式檔案結構：\n","permalink":"https://calvinegs.github.io/posts/webapp-vue/","summary":"github Source code\nAngular、React、Vue 是三個最受歡迎的前端框架，這是三篇筆記分別使用這三個不同的框架來建立功能一模一樣的網路應用程式中的第三篇 - 使用 Vue 來建立網路應用程式。\n這個網路應用程式的需求\n 産品訂購功能  表頭：訂購商品總數、總額及送出訂單功能 商品過濾功能：依産品類別來顯示商品 商品清單：顯示商品明細、商品售價、訂購數量下拉選單及加入購物車等功能   訂單確認功能：顯示訂購商品明細及總金額 訂購成功功能：顯示訂購完成資訊  使用技術:\n Vue 3 Bootstrap 5 (UI Framework) Vue Router 4 Vuex 4 axios 0.27 NodeJS 18.5 \u0026amp; Express 4.18 json-server 0.17.0 npm-run-all 4.1.5 (npm 套件) @vue/cli  建立新專案 使用下列的 npx 語法即可建立最新版 Vue 預設的應用程式結構\n$ npx @vue/cli create vueapp Vue CLI v5.0.8 ? Please pick a preset: Manually select features ?","title":"使用 Vue 來建立網路應用程式"},{"content":"github Source code\nAngular、React、Vue 是三個最受歡迎的前端框架，這是三篇筆記分別使用這三個不同的框架來建立功能一模一樣的網路應用程式中的第二篇。\n這個網路應用程式的需求\n 産品訂購功能  表頭：訂購商品總數、總額及送出訂單功能 商品過濾功能：依産品類別來顯示商品 商品清單：顯示商品明細、商品售價、訂購數量下拉選單及加入購物車等功能   訂單確認功能：顯示訂購商品明細及總金額 訂購成功功能：顯示訂購完成資訊  使用技術:\n React 18 Bootstrap 5 (UI Framework) React Router 6 React Redux 8 NodeJS \u0026amp; Express json-server npm-run-all (npm 套件)  建立新專案 使用下列的 create-react-app 語法即可建立最新版 React 預設的應用程式結構\n$ npx create-react-app reactapp --template typescript Creating a new React app in /home/egs/cal-data/tech-test/typescript/book/reactapp. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts with cra-template-typescript... added 1393 packages in 45s 207 packages are looking for funding run `npm fund` for details Initialized a git repository. Installing template dependencies using npm... added 35 packages, and changed 1 package in 5s 207 packages are looking for funding run `npm fund` for details We detected TypeScript in your project (src/App.test.tsx) and created a tsconfig.json file for you. Your tsconfig.json has been populated with default values. Removing template package using npm... removed 1 package, and audited 1428 packages in 2s 207 packages are looking for funding run `npm fund` for details 6 high severity vulnerabilities To address all issues (including breaking changes), run: npm audit fix --force Run `npm audit` for details. Created git commit. Success! Created reactapp at /home/egs/cal-data/tech-test/typescript/book/reactapp Inside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm test Starts the test runner. npm run eject Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back! We suggest that you begin by typing: cd reactapp npm start Happy hacking! 查看 package.json 中相依套件及版本 $ cd reactapp $ cat package.json { \u0026#34;name\u0026#34;: \u0026#34;reactapp\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.1.0\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;@testing-library/jest-dom\u0026#34;: \u0026#34;^5.16.5\u0026#34;, \u0026#34;@testing-library/react\u0026#34;: \u0026#34;^13.3.0\u0026#34;, \u0026#34;@testing-library/user-event\u0026#34;: \u0026#34;^13.5.0\u0026#34;, \u0026#34;@types/jest\u0026#34;: \u0026#34;^27.5.2\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^16.11.54\u0026#34;, \u0026#34;@types/react\u0026#34;: \u0026#34;^18.0.17\u0026#34;, \u0026#34;@types/react-dom\u0026#34;: \u0026#34;^18.0.6\u0026#34;, \u0026#34;react\u0026#34;: \u0026#34;^18.2.0\u0026#34;, \u0026#34;react-dom\u0026#34;: \u0026#34;^18.2.0\u0026#34;, \u0026#34;react-scripts\u0026#34;: \u0026#34;5.0.1\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.7.4\u0026#34;, \u0026#34;web-vitals\u0026#34;: \u0026#34;^2.1.4\u0026#34; }, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;react-scripts start\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;react-scripts build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;react-scripts test\u0026#34;, \u0026#34;eject\u0026#34;: \u0026#34;react-scripts eject\u0026#34; }, \u0026#34;eslintConfig\u0026#34;: { \u0026#34;extends\u0026#34;: [ \u0026#34;react-app\u0026#34;, \u0026#34;react-app/jest\u0026#34; ] }, \u0026#34;browserslist\u0026#34;: { \u0026#34;production\u0026#34;: [ \u0026#34;\u0026gt;0.2%\u0026#34;, \u0026#34;not dead\u0026#34;, \u0026#34;not op_mini all\u0026#34; ], \u0026#34;development\u0026#34;: [ \u0026#34;last 1 chrome version\u0026#34;, \u0026#34;last 1 firefox version\u0026#34;, \u0026#34;last 1 safari version\u0026#34; ] } } 産生的預設程式結構 執行由 CLI 産生的預設程式架構 $ npm i $ npm start Compiled successfully! You can now view reactapp in the browser. Local: http://localhost:3000 On Your Network: http://192.168.0.125:3000 Note that the development build is not optimized. To create a production build, use npm run build. webpack compiled successfully No issues found. 開啟瀏覽器，輸入 http://localhost:3000/ $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial Commit\u0026#34; # 加入 git 新版本 $ code . # 打開 vscode 使用 json-server 當作後端 Web Api 在我們的前端應用程式中會使用到後端伺服器的資料，方便起見直接使用 json-server　來當作後端 Web Api\n安裝 json-server $ npm install --save-dev json-server@0.17.0 npm-run-all@4.1.5\n建立給 json-server 使用的資料 $ touch data.json # data.json 內容如下 { \u0026#34;products\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;kayak\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Watersports\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A boat form on person\u0026#34;, \u0026#34;price\u0026#34;: 275 }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;Lifejacket\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Watersports\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Protective and fashionable boat form on person\u0026#34;, \u0026#34;price\u0026#34;: 48.95 }, { \u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;Soccer Ball\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Soccer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;FIFA-approved size and weight\u0026#34;, \u0026#34;price\u0026#34;: 19.5 }, { \u0026#34;id\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;Corner Flags\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Soccer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Give your playing field a professional touch\u0026#34;, \u0026#34;price\u0026#34;: 34.95 }, { \u0026#34;id\u0026#34;: 5, \u0026#34;name\u0026#34;: \u0026#34;Stadium\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Soccer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Flat-packed 35,000-seat stadium\u0026#34;, \u0026#34;price\u0026#34;: 79500 }, { \u0026#34;id\u0026#34;: 6, \u0026#34;name\u0026#34;: \u0026#34;Thinking Cap\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Imporove brain efficiency by 75%\u0026#34;, \u0026#34;price\u0026#34;: 16 }, { \u0026#34;id\u0026#34;: 7, \u0026#34;name\u0026#34;: \u0026#34;Unsteady Chair\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Secretly give your opponent a disadvantage\u0026#34;, \u0026#34;price\u0026#34;: 29.95 }, { \u0026#34;id\u0026#34;: 8, \u0026#34;name\u0026#34;: \u0026#34;Human Chess Board\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A fun game for the family\u0026#34;, \u0026#34;price\u0026#34;: 75 }, { \u0026#34;id\u0026#34;: 9, \u0026#34;name\u0026#34;: \u0026#34;Bling Bling King\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Gold-plated, diamond-studded King\u0026#34;, \u0026#34;price\u0026#34;: 1200 } ], \u0026#34;orders\u0026#34;: [ ] } 測試 json-server $ npx json-server data.json -p 4600 # 使用 4600 port \\{^_^}/ hi! Loading data.json Done Resources http://localhost:4600/products http://localhost:4600/orders Home http://localhost:4600 Type s + enter at any time to create a snapshot of the database GET /db 304 1.630 ms - - GET /__rules 404 4.536 ms - 2 設定 npm script in package.sjon // ... \t\u0026#34;scripts\u0026#34;: { \u0026#34;serve\u0026#34;: \u0026#34;react-scripts start\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;react-scripts build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;react-scripts test\u0026#34;, \u0026#34;eject\u0026#34;: \u0026#34;react-scripts eject\u0026#34;, \u0026#34;json\u0026#34;: \u0026#34;json-server data.json -p 4600\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;npm-run-all -p serve json\u0026#34; }, // ... 在專案中使用 Bootstrap CSS 套件 安裝 bootstrap 5 $ npm install bootstrap@5.2.0\n引入 bootstrap in index.tsx // ./src/index.tsx import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; import \u0026#39;./index.css\u0026#39;; import App from \u0026#39;./App\u0026#39;; import \u0026#39;bootstrap/dist/css/bootstrap.css\u0026#39;; const root = ReactDOM.createRoot( document.getElementById(\u0026#39;root\u0026#39;) as HTMLElement ); root.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/React.StrictMode\u0026gt; ); 修改 tsconfig.json 將 \u0026ldquo;target\u0026rdquo; 改成 \u0026ldquo;es2015\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12  { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2015\u0026#34;,  \u0026#34;lib\u0026#34;: [ \u0026#34;dom\u0026#34;, \u0026#34;dom.iterable\u0026#34;, \u0026#34;esnext\u0026#34; ], \u0026#34;allowJs\u0026#34;: true, // ...  } }   為網站加入資料 建立資料模型 $ mkdir ./src/data \u0026amp;\u0026amp; touch ./src/data/entities.ts\nentities.ts 檔案內容如下：\n// ./src/data/entities.ts export type Product = { id: number, name: string, description: string, category: string, price: number }; export class OrderLine { constructor(public product: Product, public quantity: number) { } get total(): number { return this.product.price * this.quantity; } } export class Order { private lines = new Map\u0026lt;number, OrderLine\u0026gt;(); constructor(initialLines?: OrderLine[]) { if (initialLines) { initialLines.forEach(ol =\u0026gt; this.lines.set(ol.product.id, ol)); } } public addProduct(prod: Product, quantity: number) { if (this.lines.has(prod.id)) { if (quantity === 0) { this.removeProduct(prod.id); } else { this.lines.get(prod.id)!.quantity += quantity; } } else { this.lines.set(prod.id, new OrderLine(prod, quantity)); } } public removeProduct(id: number) { this.lines.delete(id); } get orderLines(): OrderLine[] { return [...this.lines.values()]; } get productCount(): number { return [...this.lines.values()] .reduce((total, ol) =\u0026gt; total += ol.quantity, 0); } get total(): number { return [...this.lines.values()].reduce((total, ol) =\u0026gt; total += ol.total, 0); } } 建立商品訂購相關元件 $ mkdir ./src/pages $ touch ./src/pages/productItem.tsx $ touch ./src/pages/categoryList.tsx $ touch ./src/pages/header.tsx $ touch ./src/pages/productList.tsx 商品明細元件 (productItem) // productItem.tsx import { ChangeEvent, FunctionComponent, useState } from \u0026#34;react\u0026#34;; import { Product } from \u0026#34;../data/entities\u0026#34;; interface Props { product: Product, callback: (product: Product, quantity: number) =\u0026gt; void } export const ProductItem: FunctionComponent\u0026lt;Props\u0026gt; = (props) =\u0026gt; { const [quantity, setQuantity] = useState\u0026lt;number\u0026gt;(1); return \u0026lt;div className=\u0026#34;card m-1 p-1 bg-light\u0026#34;\u0026gt; \u0026lt;h4\u0026gt; {props.product.name} \u0026lt;span className=\u0026#34;badge rounded-pill bg-primary float-end\u0026#34;\u0026gt; ${props.product.price.toFixed(2)} \u0026lt;/span\u0026gt; \u0026lt;/h4\u0026gt; \u0026lt;div className=\u0026#34;card-text bg-white p-1\u0026#34;\u0026gt; {props.product.description} \u0026lt;button className=\u0026#34;btn btn-success btn-sm float-end\u0026#34; onClick={() =\u0026gt; props.callback(props.product, quantity)} \u0026gt; Add To Cart \u0026lt;/button\u0026gt; \u0026lt;select className=\u0026#34;form-control-inline float-end m-1\u0026#34; onChange={(ev: ChangeEvent\u0026lt;HTMLSelectElement\u0026gt;) =\u0026gt; setQuantity(Number(ev.target.value))}\u0026gt; \u0026lt;option\u0026gt;1\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;2\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; } 商品分類按鈕元件 (categoryList.tsx) // categoryList.tsx import React, { ChangeEvent, FunctionComponent, useState } from \u0026#39;react\u0026#39; interface Props { selected: string, categories: string[], selectCategory: (category: string) =\u0026gt; void } // export default function productItem() { export const CategoryList: FunctionComponent\u0026lt;Props\u0026gt; = (props) =\u0026gt; { return ( \u0026lt;div className=\u0026#39;d-grid gap-2\u0026#39;\u0026gt; {[\u0026#34;All\u0026#34;, ...props.categories].map(c =\u0026gt; { let btnClass = props.selected === c ? \u0026#34;btn-primary\u0026#34; : \u0026#34;btn-secondary\u0026#34;; return \u0026lt;button key={c} className={`btn ${btnClass}`} onClick={() =\u0026gt; props.selectCategory(c)}\u0026gt; {c} \u0026lt;/button\u0026gt; })} \u0026lt;/div\u0026gt; ) } 表頭元件 (header) // header.tsx import { FunctionComponent } from \u0026#39;react\u0026#39; import { Order } from \u0026#39;../data/entities\u0026#39; interface Props { order: Order } // export default function productItem() { export const Header: FunctionComponent\u0026lt;Props\u0026gt; = (props) =\u0026gt; { const count = props.order.productCount; return ( \u0026lt;div className=\u0026#39;p-1 bg-secondary text-white text-end\u0026#39;\u0026gt; {count === 0 ? \u0026#34;(No Selection)\u0026#34; : `${count}product(s), $${props.order.total.toFixed(2)}`} \u0026lt;button className=\u0026#39;btn btn-sm btn-primary m-1\u0026#39;\u0026gt; Submit Order \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 商品清單元件 (productList) // productList.tsx import { ChangeEvent, FunctionComponent, useState } from \u0026#39;react\u0026#39; import { Order, Product } from \u0026#39;../data/entities\u0026#39;; import { CategoryList } from \u0026#39;./categoryList\u0026#39;; import { Header } from \u0026#39;./header\u0026#39;; import { ProductItem } from \u0026#39;./productItem\u0026#39;; interface Props { products: Product[], categories: string[], order: Order, addToOrder: (product: Product, quantity: number) =\u0026gt; void } export const ProductList: FunctionComponent\u0026lt;Props\u0026gt; = (props) =\u0026gt; { const [selectedCategory, setSelectedCategory] = useState\u0026lt;string\u0026gt;(\u0026#34;All\u0026#34;); let products : Product[] = props.products.filter( p =\u0026gt; selectedCategory === \u0026#34;All\u0026#34; || p.category === selectedCategory); return ( \u0026lt;div\u0026gt; \u0026lt;Header order={props.order} /\u0026gt; {/* \u0026lt;Header order={Orders} /\u0026gt; */} \u0026lt;div className=\u0026#39;container-fluid\u0026#39;\u0026gt; \u0026lt;div className=\u0026#39;row\u0026#39;\u0026gt; \u0026lt;div className=\u0026#39;col-3 p-2\u0026#39;\u0026gt; \u0026lt;CategoryList categories={props.categories} selected={selectedCategory} selectCategory={(cat: string) =\u0026gt; { setSelectedCategory(cat); }} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#39;col-9 p-2\u0026#39;\u0026gt; { products.map(p =\u0026gt; \u0026lt;ProductItem key={p.id} product={p} callback={props.addToOrder} /\u0026gt;) } \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 檔案結構 ##　執行程式\n$ npm start 使用 Data Store 來管理 React 應用程式的資料 在大多數的 React 專案中，應用程式的資料是交由 \u0026ldquo;data store\u0026rdquo; 資料倉儲來管理，由最多人使用的管理資料套件就是 Redux。\n安裝 Redux $ npm install redux@4.2.0 react-redux@8.0.2 $ npm install --save-dev @types/react-redux@7.1.24 建立 Redux 的 action 類別 $ touch ./src/data/types.ts // ./src/data/types.ts import { Action } from \u0026#34;redux\u0026#34;; import { Order, Product } from \u0026#34;./entities\u0026#34;; export interface StoreData { products: Product[], order: Order } export enum ACTIONS { ADD_PRODUCTS, MODIFY_ORDER, RESET_ORDER } export interface AddProductsAction extends Action\u0026lt;ACTIONS.ADD_PRODUCTS\u0026gt; { payload: Product[] } export interface ModifyOrderAction extends Action\u0026lt;ACTIONS.MODIFY_ORDER\u0026gt; { payload: { product: Product, quantity: number } } export interface ResetOrderAction extends Action\u0026lt;ACTIONS.RESET_ORDER\u0026gt; {} export type StoreAction = AddProductsAction | ModifyOrderAction | ResetOrderAction; 建立 action creator $ touch ./src/data/actionCreators.ts // ./src/data/actionCreators.ts import { Product } from \u0026#34;./entities\u0026#34;; import { ACTIONS, AddProductsAction, ModifyOrderAction, ResetOrderAction } from \u0026#34;./types\u0026#34;; export const addProduct = (...products: Product[]): AddProductsAction =\u0026gt; ({ type: ACTIONS.ADD_PRODUCTS, payload: products }); export const modifyOrder = (product: Product, quantity: number): ModifyOrderAction =\u0026gt; ({ type: ACTIONS.MODIFY_ORDER, payload: { product, quantity} }); export const resetOrder = (product: Product, quantity: number): ResetOrderAction =\u0026gt; ({ type: ACTIONS.RESET_ORDER }); 建立 Redux reducer 來處理 action $ touch ./src/data/reducer.ts import { Reducer } from \u0026#34;redux\u0026#34;; import { Order } from \u0026#34;./entities\u0026#34;; import { ACTIONS, StoreAction, StoreData } from \u0026#34;./types\u0026#34;; export const StoreReducer: Reducer\u0026lt;StoreData, StoreAction\u0026gt; = (data: StoreData | undefined , action) =\u0026gt; { data = data || { products: [], order: new Order()} switch (action.type) { case ACTIONS.ADD_PRODUCTS: return { ...data, products: [...data.products, ...action.payload] }; case ACTIONS.MODIFY_ORDER: data.order.addProduct( action.payload.product, action.payload.quantity ) return {...data}; case ACTIONS.RESET_ORDER: return { ...data, order:new Order() }; default: return data; } } 建立 Data store $ touch ./src/data/dataStore.ts import { createStore, Store } from \u0026#34;redux\u0026#34;; import { StoreReducer } from \u0026#34;./reducer\u0026#34;; import { StoreAction, StoreData } from \u0026#34;./types\u0026#34;; export const dataStore: Store\u0026lt;StoreData, StoreAction\u0026gt; = createStore(StoreReducer); 新增 HTTP 請求類別 安裝 axios $ npm install axios@0.27.2 建立 httpHandler.ts $ touch ./src/data/httpHandler.ts import Axios from \u0026#34;axios\u0026#34;; import { Order, Product } from \u0026#34;./entities\u0026#34;; const protocol = \u0026#34;http\u0026#34;; const hostname = \u0026#34;localhost\u0026#34;; const port = 4600; const urls = { products: `${protocol}://${hostname}:${port}/products`, orders: `${protocol}://${hostname}:${port}/orders`, }; export class HttpHandler { loadProducts(callback: (producs: Product[]) =\u0026gt; void): void { Axios.get(urls.products).then(response =\u0026gt; callback(response.data)) } storeOrder(order: Order, callback: (id: number) =\u0026gt; void): void { let orderData = { lines: [...order.orderLines.values()].map(ol =\u0026gt; ({ productId: ol.product.id, productName: ol.product.name, quantity: ol.quantity })) } Axios.post(urls.orders, orderData).then(response =\u0026gt; callback(response.data.id)); } } 連結 Data Store 與各個元件 使用 React-Redux 套件來將應用程式元件連接到 Redux data store。\n$ touch .src/data/productLitConnector.ts import { connect } from \u0026#34;react-redux\u0026#34;; import { ProductList } from \u0026#34;../pages/productList\u0026#34;; import { modifyOrder } from \u0026#34;./actionCreators\u0026#34;; import { StoreData } from \u0026#34;./types\u0026#34;; const mapStateToProps = (data: StoreData) =\u0026gt; ({ products: data.products, categories: [...new Set(data.products.map(p =\u0026gt; p.category))], order: data.order }) const mapDispatchToProps = { addToOrder: modifyOrder } const connectFunction = connect(mapStateToProps, mapDispatchToProps); export const ConnectedProductList = connectFunction(ProductList); 修改 App.tsx import React, { FunctionComponent, useState } from \u0026#39;react\u0026#39;; import { Provider } from \u0026#39;react-redux\u0026#39;; import { addProduct } from \u0026#39;./data/actionCreators\u0026#39;; import { dataStore } from \u0026#39;./data/dataStore\u0026#39;; import { HttpHandler } from \u0026#39;./data/httpHandler\u0026#39;; import { ConnectedProductList } from \u0026#39;./data/productLitConnector\u0026#39;; interface Props { } let httpHandler = new HttpHandler(); httpHandler.loadProducts(data =\u0026gt; dataStore.dispatch(addProduct(...data))); export const App: FunctionComponent\u0026lt;Props\u0026gt; = (props) =\u0026gt; { let submitCallback = () =\u0026gt; { console.log(\u0026#34;Submit order\u0026#34;); }; return \u0026lt;div className=\u0026#39;App\u0026#39;\u0026gt; \u0026lt;Provider store={dataStore}\u0026gt; \u0026lt;ConnectedProductList /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/div\u0026gt; } export default App; 執行測試 程式至此已將資料連結由 local 改到 Json-Server，並將取得的資料放入 Redux data store 中了。\n$ npm start 完成其他功能 接下來我們要完成其餘的二個功能：訂單確認功能及訂購成功功能，在我們已完成的商品訂購元件與前述二個元件中做切換時，會需要使用到URL路由功能，在 React 核心中並未內建路由功能，所以我們必須安裝額外的套件 \u0026ndash; React Router 套件。\n安裝 React Router 套件 $ npm install react-router-dom@6.3.0 $ npm install --save-dev @types/react-router-dom5.3.3 URL 路由設定 修改 App.tsx\nimport { FunctionComponent } from \u0026#39;react\u0026#39;; import { Route, Routes, useNavigate } from \u0026#39;react-router-dom\u0026#39;; import { addProduct } from \u0026#39;./data/actionCreators\u0026#39;; import { dataStore } from \u0026#39;./data/dataStore\u0026#39;; import { Order } from \u0026#39;./data/entities\u0026#39;; import { HttpHandler } from \u0026#39;./data/httpHandler\u0026#39;; import { ConnectedProductList } from \u0026#39;./data/productLitConnector\u0026#39;; interface Props { } let httpHandler = new HttpHandler(); httpHandler.loadProducts(data =\u0026gt; dataStore.dispatch(addProduct(...data))); export const App: FunctionComponent\u0026lt;Props\u0026gt; = (props) =\u0026gt; { const navigate = useNavigate(); let submitCallback = () =\u0026gt; { httpHandler.storeOrder(dataStore.getState().order, id =\u0026gt; navigate(`/summary/${id}`, { replace: true})); dataStore.getState().order = new Order(); }; return \u0026lt;div className=\u0026#39;App\u0026#39;\u0026gt; \u0026lt;Routes\u0026gt; \u0026lt;Route index element={\u0026lt;ConnectedProductList/\u0026gt;}/\u0026gt; \u0026lt;Route path=\u0026#34;/products\u0026#34; element={\u0026lt;ConnectedProductList/\u0026gt;}/\u0026gt; {/* \u0026lt;Route path=\u0026#34;/order\u0026#34; element={\u0026lt;OrderDetails submitCallback={() =\u0026gt; submitCallback()}/\u0026gt;} /\u0026gt; \u0026lt;Route path=\u0026#34;/summary/:id\u0026#34; element={\u0026lt;Summary /\u0026gt;} /\u0026gt; */} \u0026lt;/Routes\u0026gt; \u0026lt;/div\u0026gt; } export default App; 修改 index.tsx\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; import \u0026#39;./index.css\u0026#39;; import App from \u0026#39;./App\u0026#39;; import \u0026#39;bootstrap/dist/css/bootstrap.css\u0026#39;; import { BrowserRouter } from \u0026#39;react-router-dom\u0026#39;; import { Provider } from \u0026#39;react-redux\u0026#39;; import { dataStore } from \u0026#39;./data/dataStore\u0026#39;; const root = ReactDOM.createRoot( document.getElementById(\u0026#39;root\u0026#39;) as HTMLElement ); root.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Provider store={dataStore}\u0026gt; \u0026lt;BrowserRouter\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/React.StrictMode\u0026gt; ); 加入訂單確認元件 $ touch ./src/pages/orderDetails.tsx\nimport { connect } from \u0026#34;react-redux\u0026#34; import { FunctionComponent } from \u0026#34;react\u0026#34; import { NavLink } from \u0026#34;react-router-dom\u0026#34; import { Order } from \u0026#34;../data/entities\u0026#34; import { StoreData } from \u0026#34;../data/types\u0026#34; const mapStateToProps = (data: StoreData) =\u0026gt; ({ order: data.order }) interface Props { order: Order, submitCallback: () =\u0026gt; void } const OrderDetailComponent: FunctionComponent\u0026lt;Props\u0026gt; = (props) =\u0026gt; { return \u0026lt;div\u0026gt; \u0026lt;h3 className=\u0026#34;text-center bg-primary text-white p-2\u0026#34;\u0026gt; Order Summary \u0026lt;/h3\u0026gt; \u0026lt;div className=\u0026#34;p-3\u0026#34;\u0026gt; \u0026lt;table className=\u0026#34;table table-sm table-striped\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Quantity\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Product\u0026lt;/th\u0026gt; \u0026lt;th className=\u0026#34;text-end\u0026#34;\u0026gt;Price\u0026lt;/th\u0026gt; \u0026lt;th className=\u0026#34;text-end\u0026#34;\u0026gt;Subtotal\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {props.order.orderLines.map(line =\u0026gt; \u0026lt;tr key={line.product.id}\u0026gt; \u0026lt;td\u0026gt;{line.quantity}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{line.product.name}\u0026lt;/td\u0026gt; \u0026lt;td className=\u0026#34;text-end\u0026#34;\u0026gt;{line.product.price.toFixed(2)}\u0026lt;/td\u0026gt; \u0026lt;td className=\u0026#34;text-end\u0026#34;\u0026gt;{line.total.toFixed(2)}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; )} \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th className=\u0026#34;text-end\u0026#34; colSpan={3}\u0026gt;Total:\u0026lt;/th\u0026gt; \u0026lt;th className=\u0026#34;text-end\u0026#34; colSpan={3}\u0026gt;${props.order.total.toFixed(2)}\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;NavLink to=\u0026#34;/products\u0026#34; className=\u0026#34;btn btn-secondary m-1\u0026#34;\u0026gt; Back \u0026lt;/NavLink\u0026gt; \u0026lt;button className=\u0026#34;btn btn-primary m-1\u0026#34; onClick={props.submitCallback}\u0026gt; Submit Order \u0026lt;/button\u0026gt; {/* \u0026lt;NavLink to=\u0026#34;/summary\u0026#34; className=\u0026#34;btn btn-primary m-1\u0026#34;\u0026gt; Submit Order \u0026lt;/NavLink\u0026gt; */} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; } const connectFunction = connect(mapStateToProps); export const OrderDetails = connectFunction(OrderDetailComponent); 加入訂購成功元件 $ touch ./src/pages/summary.tsx\nimport { FunctionComponent } from \u0026#34;react\u0026#34; import { NavLink } from \u0026#34;react-router-dom\u0026#34; import { useParams } from \u0026#34;react-router-dom\u0026#34; interface Params { id: string } export const Summary: FunctionComponent = () =\u0026gt; { let params = useParams(); const id = params.id; return \u0026lt;div className=\u0026#34;m-2 text-center\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Thanks!\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Thanks for placing your order.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Your order is #{id}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;We\u0026#39;ll ship your goods as soon as possible.\u0026lt;/p\u0026gt; \u0026lt;NavLink to=\u0026#34;/products\u0026#34; className=\u0026#34;btn btn-primary\u0026#34;\u0026gt;OK\u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; } 修改 Header.tsx URL 轉址功能 // header.tsx  完成路由設定 // App.tsx import { FunctionComponent } from \u0026#39;react\u0026#39;; import { Route, Routes, useNavigate } from \u0026#39;react-router-dom\u0026#39;; import { addProduct } from \u0026#39;./data/actionCreators\u0026#39;; import { dataStore } from \u0026#39;./data/dataStore\u0026#39;; import { Order } from \u0026#39;./data/entities\u0026#39;; import { HttpHandler } from \u0026#39;./data/httpHandler\u0026#39;; import { ConnectedProductList } from \u0026#39;./data/productLitConnector\u0026#39;; import { OrderDetails } from \u0026#39;./pages/orderDetails\u0026#39;; import { Summary } from \u0026#39;./pages/summary\u0026#39;; interface Props { } let httpHandler = new HttpHandler(); httpHandler.loadProducts(data =\u0026gt; dataStore.dispatch(addProduct(...data))); export const App: FunctionComponent\u0026lt;Props\u0026gt; = (props) =\u0026gt; { const navigate = useNavigate(); let submitCallback = () =\u0026gt; { httpHandler.storeOrder(dataStore.getState().order, id =\u0026gt; navigate(`/summary/${id}`, { replace: true})); dataStore.getState().order = new Order(); }; return \u0026lt;div className=\u0026#39;App\u0026#39;\u0026gt; \u0026lt;Routes\u0026gt; \u0026lt;Route index element={\u0026lt;ConnectedProductList/\u0026gt;}/\u0026gt; \u0026lt;Route path=\u0026#34;/products\u0026#34; element={\u0026lt;ConnectedProductList/\u0026gt;}/\u0026gt; \u0026lt;Route path=\u0026#34;/order\u0026#34; element={\u0026lt;OrderDetails submitCallback={() =\u0026gt; submitCallback()}/\u0026gt;} /\u0026gt; \u0026lt;Route path=\u0026#34;/summary/:id\u0026#34; element={\u0026lt;Summary /\u0026gt;} /\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/div\u0026gt; } export default App; 執行測試 佈署應用程式 使用 NodeJS \u0026amp; Express 來當作 Http Server \u0026amp; Web Api Server\n安裝 express 套件 \u0026amp; -connect-history-api-fallback 套件 $ npm install --save-dev express@4.18.1 connect-history-api-fallback@2.0.0\n建立 node 伺服器 $ touch server.js\nconst express = require(\u0026#34;express\u0026#34;); const jsonServer = require(\u0026#34;json-server\u0026#34;); const history = require(\u0026#34;connect-history-api-fallback\u0026#34;); const app = express(); app.use(history()); app.use(\u0026#34;/\u0026#34;, express.static(\u0026#34;build\u0026#34;)); const router = jsonServer.router(\u0026#34;data.json\u0026#34;); app.use(jsonServer.bodyParser); app.use(\u0026#34;/api\u0026#34;, (req, res, next) =\u0026gt; router(req, res, next)); const port = process.argv[3] || 4002; app.listen(port, ()=\u0026gt; console.log(`Running on port ${port}`)); 修改 url 路徑 修改 httpHandler.ts\nimport Axios from \u0026#34;axios\u0026#34;; import { Order, Product } from \u0026#34;./entities\u0026#34;; // const protocol = \u0026#34;http\u0026#34;; // const hostname = \u0026#34;localhost\u0026#34;; // const port = 4600; // const urls = { // products: `${protocol}://${hostname}:${port}/products`, // orders: `${protocol}://${hostname}:${port}/orders`, // }; const urls = { products: \u0026#34;/api/products\u0026#34;, orders: \u0026#34;/api/orders\u0026#34; } export class HttpHandler { loadProducts(callback: (producs: Product[]) =\u0026gt; void): void { Axios.get(urls.products).then(response =\u0026gt; callback(response.data)) } storeOrder(order: Order, callback: (id: number) =\u0026gt; void): void { let orderData = { lines: [...order.orderLines.values()].map(ol =\u0026gt; ({ productId: ol.product.id, productName: ol.product.name, quantity: ol.quantity })) } Axios.post(urls.orders, orderData).then(response =\u0026gt; callback(response.data.id)); } } 建置 React App $ npm run build \u0026gt; reactapp@0.1.0 build \u0026gt; react-scripts build Creating an optimized production build... Compiled with warnings. [eslint] src/pages/categoryList.tsx Line 1:17: \u0026#39;ChangeEvent\u0026#39; is defined but never used @typescript-eslint/no-unused-vars Line 1:49: \u0026#39;useState\u0026#39; is defined but never used @typescript-eslint/no-unused-vars src/pages/productList.tsx Line 1:10: \u0026#39;ChangeEvent\u0026#39; is defined but never used @typescript-eslint/no-unused-vars src/pages/summary.tsx Line 5:11: \u0026#39;Params\u0026#39; is defined but never used @typescript-eslint/no-unused-vars Search for the keywords to learn more about each warning. To ignore, add // eslint-disable-next-line to the line before. File sizes after gzip: 63.26 kB (-45 B) build/static/js/main.2ece24f2.js 27.93 kB build/static/css/main.24b68c36.css The project was built assuming it is hosted at /. You can control this with the homepage field in your package.json. The build folder is ready to be deployed. You may serve it with a static server: npm install -g serve serve -s build Find out more about deployment here: https://cra.link/deployment $ ls -al build 總用量 52 drwxrwxr-x 3 egs egs 4096 八 23 18:50 . drwxrwxr-x 7 egs egs 4096 八 23 18:46 .. -rw-rw-r-- 1 egs egs 369 八 23 18:50 asset-manifest.json -rw-rw-r-- 1 egs egs 3870 八 23 18:50 favicon.ico -rw-rw-r-- 1 egs egs 644 八 23 18:50 index.html -rw-rw-r-- 1 egs egs 5347 八 23 18:50 logo192.png -rw-rw-r-- 1 egs egs 9664 八 23 18:50 logo512.png -rw-rw-r-- 1 egs egs 492 八 23 18:50 manifest.json -rw-rw-r-- 1 egs egs 67 八 23 18:50 robots.txt drwxrwxr-x 4 egs egs 4096 八 23 18:50 static 執行 $ node server.js Running on port 4002 功能完成後的程式檔案結構：\n","permalink":"https://calvinegs.github.io/posts/webapp-react/","summary":"github Source code\nAngular、React、Vue 是三個最受歡迎的前端框架，這是三篇筆記分別使用這三個不同的框架來建立功能一模一樣的網路應用程式中的第二篇。\n這個網路應用程式的需求\n 産品訂購功能  表頭：訂購商品總數、總額及送出訂單功能 商品過濾功能：依産品類別來顯示商品 商品清單：顯示商品明細、商品售價、訂購數量下拉選單及加入購物車等功能   訂單確認功能：顯示訂購商品明細及總金額 訂購成功功能：顯示訂購完成資訊  使用技術:\n React 18 Bootstrap 5 (UI Framework) React Router 6 React Redux 8 NodeJS \u0026amp; Express json-server npm-run-all (npm 套件)  建立新專案 使用下列的 create-react-app 語法即可建立最新版 React 預設的應用程式結構\n$ npx create-react-app reactapp --template typescript Creating a new React app in /home/egs/cal-data/tech-test/typescript/book/reactapp. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts with cra-template-typescript.","title":"使用 React 來建立網路應用程式"},{"content":"github Source code\nAngular、React、Vue 是三個最受歡迎的前端框架，接下來的三篇筆記分別要紀錄使用這三個不同的框架來建立功能一模一樣的網路應用程式。\n這個網路應用程式的需求\n 産品訂購功能  表頭：訂購商品總數、總額及送出訂單功能 商品過濾功能：依産品類別來顯示商品 商品清單：顯示商品明細、商品售價、訂購數量下拉選單及加入購物車等功能   訂單確認功能：顯示訂購商品明細及總金額 訂購成功功能：顯示訂購完成資訊  使用技術:\n Angular 14 Bootstrap 5 (UI Framework) Angular  Router Services   NodeJS \u0026amp; Express json-server npm-run-all (npm 套件)  建立新專案 使用下列的 npm init 語法即可建立最新版 Angular 預設的應用程式結構\n$ npm init @angular angularapp -- --routing --style=scss Need to install the following packages: @angular/create@14.1.3 Ok to proceed? (y) CREATE angularapp/README.md (1064 bytes) CREATE angularapp/.editorconfig (274 bytes) CREATE angularapp/.gitignore (548 bytes) CREATE angularapp/angular.json (3160 bytes) CREATE angularapp/package.json (1041 bytes) CREATE angularapp/tsconfig.json (863 bytes) CREATE angularapp/.browserslistrc (600 bytes) CREATE angularapp/karma.conf.js (1427 bytes) CREATE angularapp/tsconfig.app.json (287 bytes) CREATE angularapp/tsconfig.spec.json (333 bytes) CREATE angularapp/.vscode/extensions.json (130 bytes) CREATE angularapp/.vscode/launch.json (474 bytes) CREATE angularapp/.vscode/tasks.json (938 bytes) CREATE angularapp/src/favicon.ico (948 bytes) CREATE angularapp/src/index.html (296 bytes) CREATE angularapp/src/main.ts (372 bytes) CREATE angularapp/src/polyfills.ts (2338 bytes) CREATE angularapp/src/styles.scss (80 bytes) CREATE angularapp/src/test.ts (749 bytes) CREATE angularapp/src/assets/.gitkeep (0 bytes) CREATE angularapp/src/environments/environment.prod.ts (51 bytes) CREATE angularapp/src/environments/environment.ts (658 bytes) CREATE angularapp/src/app/app-routing.module.ts (245 bytes) CREATE angularapp/src/app/app.module.ts (393 bytes) CREATE angularapp/src/app/app.component.scss (0 bytes) CREATE angularapp/src/app/app.component.html (23115 bytes) CREATE angularapp/src/app/app.component.spec.ts (1085 bytes) CREATE angularapp/src/app/app.component.ts (215 bytes) ✔ Packages installed successfully. Successfully initialized git. 查看 package.json 中相依套件及版本 $ cd angularapp $ cat package.json { \u0026#34;name\u0026#34;: \u0026#34;angularapp\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;ng build --watch --configuration development\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34; }, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;^14.1.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;^14.1.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;^14.1.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;^14.1.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;^14.1.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;^14.1.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;^14.1.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;^14.1.0\u0026#34;, \u0026#34;rxjs\u0026#34;: \u0026#34;~7.5.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^2.3.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.11.4\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;^14.1.3\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~14.1.3\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;^14.1.0\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~4.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~4.2.0\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~6.4.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~3.1.0\u0026#34;, \u0026#34;karma-coverage\u0026#34;: \u0026#34;~2.2.0\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~5.1.0\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;~2.0.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~4.7.2\u0026#34; } } 産生的預設程式結構 執行由 CLI 産生的預設程式架構 $ npm i $ npm start \u0026gt; angularapp@0.0.0 start \u0026gt; ng serve ✔ Browser application bundle generation complete. Initial Chunk Files | Names | Raw Size vendor.js | vendor | 2.04 MB | polyfills.js | polyfills | 315.29 kB | styles.css, styles.js | styles | 207.84 kB | main.js | main | 49.85 kB | runtime.js | runtime | 6.52 kB | | Initial Total | 2.61 MB Build at: 2022-08-22T03:50:11.996Z - Hash: fe04b1895edac604 - Time: 8579ms ** Angular Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ ** ✔ Compiled successfully. 開啟瀏覽器，輸入 http://localhost:4200/\n$ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial Commit\u0026#34; # 加入 git 新版本 $ code . # 打開 vscode 使用 json-server 當作後端 Web Api 在我們的前端應用程式中會使用到後端伺服器的資料，方便起見直接使用 json-server　來當作後端 Web Api\n安裝 json-server $ npm install --save-dev json-server@0.17.0 npm-run-all@4.1.5\n建立給 json-server 使用的資料 $ touch data.json # data.json 內容如下 { \u0026#34;products\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;kayak\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Watersports\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A boat form on person\u0026#34;, \u0026#34;price\u0026#34;: 275 }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;Lifejacket\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Watersports\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Protective and fashionable boat form on person\u0026#34;, \u0026#34;price\u0026#34;: 48.95 }, { \u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;Soccer Ball\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Soccer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;FIFA-approved size and weight\u0026#34;, \u0026#34;price\u0026#34;: 19.5 }, { \u0026#34;id\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;Corner Flags\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Soccer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Give your playing field a professional touch\u0026#34;, \u0026#34;price\u0026#34;: 34.95 }, { \u0026#34;id\u0026#34;: 5, \u0026#34;name\u0026#34;: \u0026#34;Stadium\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Soccer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Flat-packed 35,000-seat stadium\u0026#34;, \u0026#34;price\u0026#34;: 79500 }, { \u0026#34;id\u0026#34;: 6, \u0026#34;name\u0026#34;: \u0026#34;Thinking Cap\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Imporove brain efficiency by 75%\u0026#34;, \u0026#34;price\u0026#34;: 16 }, { \u0026#34;id\u0026#34;: 7, \u0026#34;name\u0026#34;: \u0026#34;Unsteady Chair\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Secretly give your opponent a disadvantage\u0026#34;, \u0026#34;price\u0026#34;: 29.95 }, { \u0026#34;id\u0026#34;: 8, \u0026#34;name\u0026#34;: \u0026#34;Human Chess Board\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A fun game for the family\u0026#34;, \u0026#34;price\u0026#34;: 75 }, { \u0026#34;id\u0026#34;: 9, \u0026#34;name\u0026#34;: \u0026#34;Bling Bling King\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Chess\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Gold-plated, diamond-studded King\u0026#34;, \u0026#34;price\u0026#34;: 1200 } ], \u0026#34;orders\u0026#34;: [ ] } 測試 json-server $ npx json-server data.json -p 4600 # 使用 4600 port \\{^_^}/ hi! Loading data.json Done Resources http://localhost:4600/products http://localhost:4600/orders Home http://localhost:4600 Type s + enter at any time to create a snapshot of the database GET /db 304 1.630 ms - - GET /__rules 404 4.536 ms - 2 設定 npm script in package.sjon \u0026#34;serve\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;json\u0026#34;: \u0026#34;json-server data.jus -p 4600\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;npm-run-all -p serve json\u0026#34; 在專案中使用 Bootstrap CSS 套件 安裝 bootstrap 5 $ npm install bootstrap@5.2.0\n引入 bootstrap in angular.json \u0026#34;architect\u0026#34;: { \u0026#34;build\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-devkit/build-angular:browser\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;outputPath\u0026#34;: \u0026#34;dist/angularapp\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;src/index.html\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;src/main.ts\u0026#34;, \u0026#34;polyfills\u0026#34;: \u0026#34;src/polyfills.ts\u0026#34;, \u0026#34;tsConfig\u0026#34;: \u0026#34;tsconfig.app.json\u0026#34;, \u0026#34;inlineStyleLanguage\u0026#34;: \u0026#34;scss\u0026#34;, \u0026#34;assets\u0026#34;: [ \u0026#34;src/favicon.ico\u0026#34;, \u0026#34;src/assets\u0026#34; ], \u0026#34;styles\u0026#34;: [ \u0026#34;src/styles.scss\u0026#34;, \u0026#34;node_modules/bootstrap/dist/css/bootstrap.min.css\u0026#34; ], 使用 bootstrap  修改 app.component.ts 修改 app.component.html  // app.component.ts import { Component } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent { title = \u0026#39;angularapp\u0026#39;; names: string[] = [\u0026#34;John\u0026#34;, \u0026#34;Alian\u0026#34;, \u0026#34;James\u0026#34;]; } \u0026lt;!-- app.component.html --\u0026gt; \u0026lt;h4 class=\u0026#34;bg-primary text-white text-center p-2\u0026#34;\u0026gt;Names\u0026lt;/h4\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let name of names\u0026#34;\u0026gt;{{ name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 為網站加入資料 建立資料模型 $ npx ng g class data/entities --skip-tests\n// entities.ts export type Product = { id: number, name: string, description: string, category: string, price: number }; export class OrderLine { constructor(public product: Product, public quantity: number) { } get total(): number { return this.product.price * this.quantity; } } export class Order { private lines = new Map\u0026lt;number, OrderLine\u0026gt;(); constructor(initialLines?: OrderLine[]) { if (initialLines) { initialLines.forEach(ol =\u0026gt; this.lines.set(ol.product.id, ol)); } } public addProduct(prod: Product, quantity: number) { if (this.lines.has(prod.id)) { if (quantity === 0) { this.removeProduct(prod.id); } else { this.lines.get(prod.id)!.quantity += quantity; } } else { this.lines.set(prod.id, new OrderLine(prod, quantity)); } } public removeProduct(id: number) { this.lines.delete(id); } get orderLines(): OrderLine[] { return [...this.lines.values()]; } get productCount(): number { return [...this.lines.values()] .reduce((total, ol) =\u0026gt; total += ol.quantity, 0); } get total(): number { return [...this.lines.values()].reduce((total, ol) =\u0026gt; total += ol.total, 0); } } 建立資料來源 服務程式 $ npx ng g s data/dataSource\n// data-source.service.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { Order, Product } from \u0026#39;./entities\u0026#39;; export type ProductProp = keyof Product; export abstract class DataSourceBase { abstract loadProducts(): Observable\u0026lt;Product[]\u0026gt;; abstract storeOrder(order: Order): Observable\u0026lt;number\u0026gt;; } @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class DataSourceService { private _products: Product[]; private _categories: Set\u0026lt;string\u0026gt;; public order: Order; constructor(private impl: DataSourceBase) { this._products = []; this._categories = new Set\u0026lt;string\u0026gt;(); this.order = new Order(); this.getData(); } getProducts(sortProp: ProductProp = \u0026#34;id\u0026#34;, category?: string): Product[]{ return this.selectProducts(this._products, sortProp, category); } protected getData(): void { this._products = []; this._categories.clear(); this.impl.loadProducts().subscribe(rawData =\u0026gt; { rawData.forEach(p =\u0026gt; { this._products.push(p); this._categories.add(p.category); }); }); } protected selectProducts(prods: Product[], sortProp: ProductProp, category?: string): Product[] { return prods.filter(p =\u0026gt; category === undefined || p.category == category) .sort((p1, p2) =\u0026gt; p1[sortProp] ? 1 : 0); } getCategories(): string[] { return [...this._categories.values()]; } storeOrder(): Observable\u0026lt;number\u0026gt; { return this.impl.storeOrder(this.order); } } 實作資料來源　服務程式 $ npx ng g s data/remoteDataSource\n// remote-data-source.service.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { DataSourceBase } from \u0026#39;./data-source.service\u0026#39;; import { Order, Product } from \u0026#39;./entities\u0026#39;; import { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; const protocol = \u0026#34;http\u0026#34;; const hostname= \u0026#34;localhost\u0026#34;; const prot = 4600; const urls = { products: `${protocol}://${hostname}:${prot}/products`, orders: `${protocol}://${hostname}:${prot}/orders` } @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class RemoteDataSourceService extends DataSourceBase { constructor(private http: HttpClient) { super(); } loadProducts(): Observable\u0026lt;Product[]\u0026gt; { return this.http.get\u0026lt;Product[]\u0026gt;(urls.products); } storeOrder(order: Order): Observable\u0026lt;number\u0026gt; { let orderData = { lines: [...order.orderLines.values()].map(ol =\u0026gt; ({ productId: ol.product.id, productName: ol.product.name, quantity: ol.quantity })) } return this.http.post\u0026lt;{ id: number }\u0026gt;(urls.orders, orderData).pipe\u0026lt;number\u0026gt;(map(val =\u0026gt; val.id)); } } 設定資料來源 模組 $ npx ng g module data\n// data.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;; import { DataSourceBase } from \u0026#39;./data-source.service\u0026#39;; import { RemoteDataSourceService } from \u0026#39;./remote-data-source.service\u0026#39;; @NgModule({ imports: [ HttpClientModule ], providers: [ { provide: DataSourceBase, useClass: RemoteDataSourceService} ] }) export class DataModule { } 建立商品訂購相關元件 $ npx ng g c pages/productItem $ npx ng g c pages/categoryList $ npx ng g c pages/header $ npx ng g c pages/productList 商品明細元件 (productItem) // product-item.component.ts import { Component, EventEmitter, Input, OnInit, Output } from \u0026#39;@angular/core\u0026#39;; import { Product } from \u0026#39;src/app/data/entities\u0026#39;; export type productSelection = { product: Product, quantity: number } @Component({ selector: \u0026#39;app-product-item\u0026#39;, templateUrl: \u0026#39;./product-item.component.html\u0026#39;, styleUrls: [\u0026#39;./product-item.component.scss\u0026#39;] }) export class ProductItemComponent { quantity: number = 1; @Input() product!: Product; @Output() addToCart = new EventEmitter\u0026lt;productSelection\u0026gt;(); handleAddToCart() { this.addToCart.emit({ product: this.product, quantity: Number(this.quantity) }) } } // product-item.component.html \u0026lt;div class=\u0026#34;card m-1 p-1 bg-light\u0026#34;\u0026gt; \u0026lt;h4\u0026gt; {{ product.name }} \u0026lt;span class=\u0026#34;badge rounded-pill bg-primary float-end\u0026#34;\u0026gt; ${{ product.price.toFixed(2) }} \u0026lt;/span\u0026gt; \u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;card-text bg-white p-1\u0026#34;\u0026gt; {{ product.description }} \u0026lt;button class=\u0026#34;btn btn-success btn-sm float-end\u0026#34; (click)=\u0026#34;handleAddToCart()\u0026#34;\u0026gt; Add To Cart \u0026lt;/button\u0026gt; \u0026lt;select title=\u0026#34;quantity\u0026#34; class=\u0026#34;form-control-inline float-end m-1\u0026#34; [(ngModel)]=\u0026#34;quantity\u0026#34;\u0026gt; \u0026lt;option\u0026gt;1\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;2\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 商品分類按鈕元件 (categoryList) // category-list.component.ts import { Component, EventEmitter, Input, OnInit, Output } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-category-list\u0026#39;, templateUrl: \u0026#39;./category-list.component.html\u0026#39;, styleUrls: [\u0026#39;./category-list.component.scss\u0026#39;] }) export class CategoryListComponent implements OnInit { @Input() selected!: string; @Input() categories!: string[]; @Output() selectCategory = new EventEmitter\u0026lt;string\u0026gt;(); constructor() { } ngOnInit(): void { } getBtnClass(category: string): string { return \u0026#34;btn \u0026#34; + (category === this.selected ? \u0026#34;btn-primary\u0026#34; : \u0026#34;btn-secondary\u0026#34;); } } // category-list.component.html \u0026lt;button *ngFor=\u0026#34;let category of categories\u0026#34; [class]=\u0026#34;getBtnClass(category)\u0026#34; (click)=\u0026#34;selectCategory.emit(category)\u0026#34;\u0026gt; {{ category }} \u0026lt;/button\u0026gt; 表頭元件 (header) // header.component.ts import { Component, EventEmitter, Input, OnInit, Output } from \u0026#39;@angular/core\u0026#39;; import { Order } from \u0026#39;src/app/data/entities\u0026#39;; @Component({ selector: \u0026#39;app-header\u0026#39;, templateUrl: \u0026#39;./header.component.html\u0026#39;, styleUrls: [\u0026#39;./header.component.scss\u0026#39;] }) export class HeaderComponent implements OnInit { @Input() order!: Order; @Output() submit = new EventEmitter\u0026lt;void\u0026gt;(); constructor() { } ngOnInit(): void { } get headerText(): string { let count = this.order.productCount; return count === 0 ? \u0026#34;(No Selection)\u0026#34; : `${count}product(s), $${this.order.total.toFixed(2)}` } } // header.component.html \u0026lt;div class=\u0026#34;p-1 bg-secondary text-white text-end\u0026#34;\u0026gt; {{ headerText }} \u0026lt;button class=\u0026#34;btn btn-sm btn-primary m-1\u0026#34; (click)=\u0026#34;submit.emit()\u0026#34;\u0026gt; Submit Order \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 商品清單元件 (productList) // product-list.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { Router } from \u0026#39;@angular/router\u0026#39;; import { DataSourceService } from \u0026#39;src/app/data/data-source.service\u0026#39;; import { Order, Product } from \u0026#39;src/app/data/entities\u0026#39;; @Component({ selector: \u0026#39;app-product-list\u0026#39;, templateUrl: \u0026#39;./product-list.component.html\u0026#39;, styleUrls: [\u0026#39;./product-list.component.scss\u0026#39;] }) export class ProductListComponent implements OnInit { selectedCategory = \u0026#34;All\u0026#34;; constructor(public dataSource: DataSourceService) { } ngOnInit(): void { } get products(): Product[] { return this.dataSource.getProducts(\u0026#34;id\u0026#34;, this.selectedCategory === \u0026#34;All\u0026#34; ? undefined : this.selectedCategory); } get categories():string[] { return [\u0026#34;All\u0026#34;, ...this.dataSource.getCategories()]; } handleCategorySelect(category: string) { this.selectedCategory = category; } handleAdd(data: { product: Product, quantity: number }) { this.dataSource.order.addProduct(data.product, data.quantity); } handleSubmit() { console.log(\u0026#34;SUBMIT\u0026#34;); } } // product-list.component.html \u0026lt;app-header [order]=\u0026#34;dataSource.order\u0026#34; (submit)=\u0026#34;handleSubmit()\u0026#34;\u0026gt;\u0026lt;/app-header\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-3 p-2\u0026#34;\u0026gt; \u0026lt;app-category-list class=\u0026#34;d-grid gap-2\u0026#34; [selected]=\u0026#34;selectedCategory\u0026#34; [categories]=\u0026#34;categories\u0026#34; (selectCategory)=\u0026#34;handleCategorySelect($event)\u0026#34;\u0026gt; \u0026lt;/app-category-list\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-9 p-2\u0026#34;\u0026gt; \u0026lt;app-product-item *ngFor=\u0026#34;let p of products\u0026#34; [product]=\u0026#34;p\u0026#34; (addToCart)=\u0026#34;handleAdd($event)\u0026#34;\u0026gt;\u0026lt;/app-product-item\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; AppComponent 修改 import { Component } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent { // title = \u0026#39;angularapp\u0026#39;;  // names: string[] = [\u0026#34;John\u0026#34;, \u0026#34;Alian\u0026#34;, \u0026#34;James\u0026#34;]; } \u0026lt;app-product-list\u0026gt;\u0026lt;/app-product-list\u0026gt; AppModule 設定 import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { ProductItemComponent } from \u0026#39;./pages/product-item/product-item.component\u0026#39;; import { CategoryListComponent } from \u0026#39;./pages/category-list/category-list.component\u0026#39;; import { HeaderComponent } from \u0026#39;./pages/header/header.component\u0026#39;; import { ProductListComponent } from \u0026#39;./pages/product-list/product-list.component\u0026#39;; import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; import { DataModule } from \u0026#39;./data/data.module\u0026#39;; @NgModule({ declarations: [ AppComponent, ProductItemComponent, CategoryListComponent, HeaderComponent, ProductListComponent ], imports: [ BrowserModule, AppRoutingModule, FormsModule, DataModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } 檔案結構 ##　執行程式\n$ npm start 完成其他功能 加入訂單確認元件 $ npx ng g c pages/orderDetails\nimport { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { Router } from \u0026#39;@angular/router\u0026#39;; import { DataSourceService } from \u0026#39;src/app/data/data-source.service\u0026#39;; import { Order } from \u0026#39;src/app/data/entities\u0026#39;; @Component({ selector: \u0026#39;app-order-details\u0026#39;, templateUrl: \u0026#39;./order-details.component.html\u0026#39;, styleUrls: [\u0026#39;./order-details.component.scss\u0026#39;] }) export class OrderDetailsComponent implements OnInit { constructor(private dataSource: DataSourceService, private router: Router) { } ngOnInit(): void { } get order(): Order { return this.dataSource.order; } submit() { this.dataSource.storeOrder().subscribe(id =\u0026gt; this.router.navigateByUrl(`/summary/${id}`)); } } \u0026lt;h3 class=\u0026#34;text-center bg-primary text-white p-2\u0026#34;\u0026gt;Order Summary\u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;p-3\u0026#34;\u0026gt; \u0026lt;table class=\u0026#34;table table-sm table-stgriped\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Quantity\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Product\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;text-end\u0026#34;\u0026gt;Price\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;text-end\u0026#34;\u0026gt;Subtotal\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr *ngFor=\u0026#34;let line of order.orderLines\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{ line.quantity }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ line.product.name }}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;text-end\u0026#34;\u0026gt;{{ line.product.price.toFixed(2) }}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;text-end\u0026#34;\u0026gt;{{ line.total.toFixed(2) }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th class=\u0026#34;text-end\u0026#34; colSpan=\u0026#34;3\u0026#34;\u0026gt;Total:\u0026lt;/th\u0026gt; \u0026lt;th class=\u0026#34;text-end\u0026#34;\u0026gt; ${{ order.total.toFixed(2) }} \u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-secondary m-1\u0026#34; routerLink=\u0026#34;/products\u0026#34;\u0026gt;Back\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary m-1\u0026#34; (click)=\u0026#34;submit()\u0026#34;\u0026gt;Submit Order\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 加入訂購成功元件 $ npx ng g c pages/summary\nimport { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRoute } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-summary\u0026#39;, templateUrl: \u0026#39;./summary.component.html\u0026#39;, styleUrls: [\u0026#39;./summary.component.scss\u0026#39;] }) export class SummaryComponent implements OnInit { constructor(private activatedRoute: ActivatedRoute) { } ngOnInit(): void { } get id(): string { return this.activatedRoute.snapshot.params[\u0026#34;id\u0026#34;]; } } \u0026lt;div class=\u0026#34;m-2 text-center\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Thanks!\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Thanks for placing your order.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Your order is #{{ id }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;We\u0026#39;ll ship your goods as soon as possible.\u0026lt;/p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; routerLink=\u0026#34;/products\u0026#34;\u0026gt;OK\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 修改路由設定 // app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { OrderDetailsComponent } from \u0026#39;./pages/order-details/order-details.component\u0026#39;; import { ProductListComponent } from \u0026#39;./pages/product-list/product-list.component\u0026#39;; import { SummaryComponent } from \u0026#39;./pages/summary/summary.component\u0026#39;; const routes: Routes = ([ { path: \u0026#34;products\u0026#34;, component: ProductListComponent }, { path: \u0026#34;order\u0026#34;, component: OrderDetailsComponent }, { path: \u0026#34;summary/:id\u0026#34;, component: SummaryComponent }, { path: \u0026#34;\u0026#34;, redirectTo: \u0026#34;/products\u0026#34;, pathMatch: \u0026#34;full\u0026#34; } ]); @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // product-list.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { Router } from \u0026#39;@angular/router\u0026#39;; import { DataSourceService } from \u0026#39;src/app/data/data-source.service\u0026#39;; import { Order, Product } from \u0026#39;src/app/data/entities\u0026#39;; @Component({ selector: \u0026#39;app-product-list\u0026#39;, templateUrl: \u0026#39;./product-list.component.html\u0026#39;, styleUrls: [\u0026#39;./product-list.component.scss\u0026#39;] }) export class ProductListComponent implements OnInit { selectedCategory = \u0026#34;All\u0026#34;; constructor(public dataSource: DataSourceService, private router: Router) {  this.dataSource.order = new Order; } ngOnInit(): void { } get products(): Product[] { return this.dataSource.getProducts(\u0026#34;id\u0026#34;, this.selectedCategory === \u0026#34;All\u0026#34; ? undefined : this.selectedCategory); } get categories():string[] { return [\u0026#34;All\u0026#34;, ...this.dataSource.getCategories()]; } handleCategorySelect(category: string) { this.selectedCategory = category; } handleAdd(data: { product: Product, quantity: number }) { this.dataSource.order.addProduct(data.product, data.quantity); } handleSubmit() { this.router.navigateByUrl(\u0026#34;/order\u0026#34;);  } }   \u0026lt;!-- app.component.html --\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; 佈署應用程式 使用 NodeJS \u0026amp; Express 來當作 Http Server \u0026amp; Web Api Server\n安裝 express 套件 \u0026amp; -connect-history-api-fallback 套件 $ npm install --save-dev express@4.18.1 connect-history-api-fallback@2.0.0\n建立 node 伺服器 $ touch server.js\nconst express = require(\u0026#34;express\u0026#34;); const jsonServer = require(\u0026#34;json-server\u0026#34;); const history = require(\u0026#34;connect-history-api-fallback\u0026#34;); const app = express(); app.use(history()); app.use(\u0026#34;/\u0026#34;, express.static(\u0026#34;dist/angularapp\u0026#34;)); const router = jsonServer.router(\u0026#34;data.json\u0026#34;); app.use(jsonServer.bodyParser); app.use(\u0026#34;/api\u0026#34;, (req, res, next) =\u0026gt; router(req, res, next)); const port = process.argv[3] || 4001; app.listen(port, ()=\u0026gt; console.log(`Running on port ${port}`)); 修改 url 路徑 修改 remoteDataSource.ts\n// const protocol = \u0026#34;http\u0026#34;; // const hostname= \u0026#34;localhost\u0026#34;; // const prot = 4600; // const urls = { // products: `${protocol}://${hostname}:${prot}/products`, // orders: `${protocol}://${hostname}:${prot}/orders` // } const urls = { products: `/api/products`, orders: `/api/orders` } 建置 Angular App $ npx ng build \u0026gt; angularapp@0.0.0 build \u0026gt; ng build ✔ Browser application bundle generation complete. ✔ Copying assets complete. ⠋ Generating index html...1 rules skipped due to selector errors: legend+* -\u0026gt; Cannot read properties of undefined (reading \u0026#39;type\u0026#39;) ✔ Index html generation complete. Initial Chunk Files | Names | Raw Size | Estimated Transfer Size main.ea031ef95dc394fc.js | main | 236.73 kB | 61.78 kB styles.698134ce9b91eefb.css | styles | 187.70 kB | 19.36 kB polyfills.d575d5a0c2fddf81.js | polyfills | 33.07 kB | 10.63 kB runtime.816becf396788283.js | runtime | 1.04 kB | 598 bytes | Initial Total | 458.56 kB | 92.36 kB Build at: 2022-08-22T10:34:24.214Z - Hash: 10534740714270dd - Time: 9530ms $ ls -al dist/angularapp/ 總用量 500 drwxrwxr-x 2 egs egs 4096 八 22 18:19 . drwxrwxr-x 3 egs egs 4096 八 22 18:19 .. -rw-rw-r-- 1 egs egs 14114 八 22 18:19 3rdpartylicenses.txt -rw-rw-r-- 1 egs egs 948 八 22 18:19 favicon.ico -rw-rw-r-- 1 egs egs 3043 八 22 18:19 index.html -rw-rw-r-- 1 egs egs 242506 八 22 18:19 main.1386edd316823fa4.js -rw-rw-r-- 1 egs egs 33867 八 22 18:19 polyfills.d575d5a0c2fddf81.js -rw-rw-r-- 1 egs egs 1070 八 22 18:19 runtime.816becf396788283.js 執行 $ node server.js Running on port 4001 容器化應用程式 $ touch deploy-package.json\n{ \u0026#34;name\u0026#34;: \u0026#34;angularapp\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Angular Web App\u0026#34;, \u0026#34;repository\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;0BSD\u0026#34;, \u0026#34;devDependencies\u0026#34;: { \u0026#34;connect-history-api-fallback\u0026#34;: \u0026#34;^2.0.0\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;^4.18.1\u0026#34;, \u0026#34;json-server\u0026#34;: \u0026#34;^0.17.0\u0026#34; } } $ touch Dockerfile\nFROMnode:14.19.0RUN mkdir -p /usr/src/angularappCOPY dist /usr/src/angularapp/distCOPY data.json /usr/src/angularapp/COPY server.js /usr/src/angularapp/COPY deploy-package.json /usr/src/angularapp/package.jsonWORKDIR/usr/src/angularappRUN echo \u0026#39;package-lock=false\u0026#39; \u0026gt;\u0026gt; .npmrcRUN npm installEXPOSE4001CMD [\u0026#34;node\u0026#34;, \u0026#34;server.js\u0026#34;]$ touch .dockerignore\nnode_modules $ docker build . -t angularapp -f Dockerfile\n$ docker run -p 4001:4001 angularapp\n查看 docker 上的 訂單資料 $ docker exec -it c46f23 bash $ cat data.json\n","permalink":"https://calvinegs.github.io/posts/webapp-angular/","summary":"github Source code\nAngular、React、Vue 是三個最受歡迎的前端框架，接下來的三篇筆記分別要紀錄使用這三個不同的框架來建立功能一模一樣的網路應用程式。\n這個網路應用程式的需求\n 産品訂購功能  表頭：訂購商品總數、總額及送出訂單功能 商品過濾功能：依産品類別來顯示商品 商品清單：顯示商品明細、商品售價、訂購數量下拉選單及加入購物車等功能   訂單確認功能：顯示訂購商品明細及總金額 訂購成功功能：顯示訂購完成資訊  使用技術:\n Angular 14 Bootstrap 5 (UI Framework) Angular  Router Services   NodeJS \u0026amp; Express json-server npm-run-all (npm 套件)  建立新專案 使用下列的 npm init 語法即可建立最新版 Angular 預設的應用程式結構\n$ npm init @angular angularapp -- --routing --style=scss Need to install the following packages: @angular/create@14.1.3 Ok to proceed? (y) CREATE angularapp/README.md (1064 bytes) CREATE angularapp/.","title":"使用 Angular 來建立網路應用程式"},{"content":"github Source code\n需求情境 希望我們的應用程式在每次成功導航後都能自動新瀏覽器的頁面標題。\n當使用者按下“功能列的HOME後，程式除了導覽至 Home Page外，瀏覽器的頁面標題顯示的是: \u0026ldquo;CRUD App - Home\u0026rdquo;\n當使用者按下“功能列的登入按鈕後，程式除了導覽至 登入畫面　外，瀏覽器的頁面標題顯示的是: \u0026ldquo;CRUD App - Login\u0026rdquo;\n檢視 Angular/CLI $ ng version _ _ ____ _ ___ / \\  _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 14.0.5 Node: 16.14.0 Package Manager: npm 8.3.1 OS: linux x64 Angular: undefined ... Package Version ------------------------------------------------------ @angular-devkit/architect 0.1400.5 @angular-devkit/core 14.0.5 @angular-devkit/schematics 14.0.5 @angular/cli 14.0.5 @schematics/angular 14.0.5 建立新專案 $ npx ng new angular-titlestrategy ? Would you like to add Angular routing? Yes ? Which stylesheet format would you like to use? SCSS [ https://sass-lang.com/documentation/syntax#scss ] CREATE angular-titlestrategy/README.md (1074 bytes) CREATE angular-titlestrategy/.editorconfig (274 bytes) CREATE angular-titlestrategy/.gitignore (548 bytes) CREATE angular-titlestrategy/angular.json (3171 bytes) CREATE angular-titlestrategy/package.json (1052 bytes) CREATE angular-titlestrategy/tsconfig.json (863 bytes) CREATE angular-titlestrategy/.browserslistrc (600 bytes) CREATE angular-titlestrategy/karma.conf.js (1438 bytes) CREATE angular-titlestrategy/tsconfig.app.json (287 bytes) CREATE angular-titlestrategy/tsconfig.spec.json (333 bytes) CREATE angular-titlestrategy/.vscode/extensions.json (130 bytes) CREATE angular-titlestrategy/.vscode/launch.json (474 bytes) CREATE angular-titlestrategy/.vscode/tasks.json (938 bytes) CREATE angular-titlestrategy/src/favicon.ico (948 bytes) CREATE angular-titlestrategy/src/index.html (306 bytes) CREATE angular-titlestrategy/src/main.ts (372 bytes) CREATE angular-titlestrategy/src/polyfills.ts (2338 bytes) CREATE angular-titlestrategy/src/styles.scss (80 bytes) CREATE angular-titlestrategy/src/test.ts (749 bytes) CREATE angular-titlestrategy/src/assets/.gitkeep (0 bytes) CREATE angular-titlestrategy/src/environments/environment.prod.ts (51 bytes) CREATE angular-titlestrategy/src/environments/environment.ts (658 bytes) CREATE angular-titlestrategy/src/app/app-routing.module.ts (245 bytes) CREATE angular-titlestrategy/src/app/app.module.ts (393 bytes) CREATE angular-titlestrategy/src/app/app.component.scss (0 bytes) CREATE angular-titlestrategy/src/app/app.component.html (23364 bytes) CREATE angular-titlestrategy/src/app/app.component.spec.ts (1118 bytes) CREATE angular-titlestrategy/src/app/app.component.ts (226 bytes) ✔ Packages installed successfully. Successfully initialized git. $ cd angular-titlestrategy $ cat package.json { \u0026#34;name\u0026#34;: \u0026#34;angular-titlestrategy\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;ng build --watch --configuration development\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34; }, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;rxjs\u0026#34;: \u0026#34;~7.5.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^2.3.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.11.4\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;^14.0.5\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~14.0.5\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~4.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~4.1.0\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~6.3.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~3.1.0\u0026#34;, \u0026#34;karma-coverage\u0026#34;: \u0026#34;~2.2.0\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;~1.7.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~4.7.2\u0026#34; } } 設置專案 建立相關元件 與 服務 $ ng g c pages/login $ ng g c pages/register $ ng g c pages/profile $ ng g c pages/home $ ng g c pages/userdata $ ng g c pages/order 使用 Bootstrap 開啟 src/index.html 在  加入 link tag\n 使用 bootstrap 5 如第 9 行匯入語法  1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;AngularTitlestrategy\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   路由設置 透過路由的設置，程式才會知道當使用者在瀏覧器特定的 URI 時，程式應該去執那支相對應的程式。路由模組檔案（app-routin.module.ts）內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { OrderComponent } from \u0026#39;./pages/order/order.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { UserdataComponent } from \u0026#39;./pages/userdata/userdata.component\u0026#39;; const routes: Routes = [  { path: \u0026#39;home\u0026#39;, component: HomeComponent }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, { path: \u0026#39;register\u0026#39;, component: RegisterComponent }, { path: \u0026#39;profile\u0026#39;, component: ProfileComponent }, { path: \u0026#39;userdata\u0026#39;, component: UserdataComponent}, { path: \u0026#39;order\u0026#39;, component: OrderComponent }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39;} ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   App Component 修改 App 元件的程式碼\n// app.component.ts import { Component } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent { } App 元件的 HTML\n\u0026lt;!-- app.component.html --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;nav class=\u0026#34;navbar navbar-expand navbar-dark bg-dark\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;navbar-brand\u0026#34;\u0026gt;Angular14\u0026lt;/a\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav me-auto\u0026#34; routerLinkActive=\u0026#34;active\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/home\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;home\u0026#34;\u0026gt;首頁\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/userdata\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;userdata\u0026#34;\u0026gt;使用者管理\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/order\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;order\u0026#34;\u0026gt;訂單\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav ms-auto\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/register\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;register\u0026#34;\u0026gt;註冊\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/login\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;login\u0026#34;\u0026gt;登入\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 執行程式 結行結果：\n導覽至首頁時 導覽至使用者資料功能時 導覽至訂單功能時 會發現瀏覽器的頁面標題都維護是\u0026quot;AngularTitlestrategy\u0026quot;。這個標題的設定值是在 index.html　中\n使用 Angular 14 新增的功能 - TitleStrategy Title　Strategy是 Angular 14內建的功能，只須在 Routes 設定值中加入 title 屬性值即可自動更新瀏覽器的頁面標題\n當導覽至Home時，瀏覽器的頁面標題自動更新為首頁 當導覽至使用者資料時，瀏覽器的頁面標題自動更新為使用者資料 當導覽至訂單時，瀏覽器的頁面標題自動更新為訂單 客制化標題 新增一個繼承自 TitleStrategy 的 Class 這個 class 會覆寫掉預設的 Title Strategy\n@Injectable() export class TemplatePageTitleStrategy extends TitleStrategy { constructor(private readonly title: Title) { super(); } override updateTitle(routerState: RouterStateSnapshot) { const title = this.buildTitle(routerState); if (title !== undefined) { this.title.setTitle(`My App - ${title}`); // 透過 setTitle 來覆寫預設的 Title 值  } } } 完整的 app-routing.module.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  import { Injectable, NgModule } from \u0026#39;@angular/core\u0026#39;; import { Title } from \u0026#39;@angular/platform-browser\u0026#39;; import { RouterModule, RouterStateSnapshot, Routes, TitleStrategy } from \u0026#39;@angular/router\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { OrderComponent } from \u0026#39;./pages/order/order.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { UserdataComponent } from \u0026#39;./pages/userdata/userdata.component\u0026#39;;  const routes: Routes = [ { path: \u0026#39;home\u0026#39;, component: HomeComponent, title: \u0026#39;首頁\u0026#39; }, { path: \u0026#39;login\u0026#39;, component: LoginComponent, title: \u0026#39;登入\u0026#39; }, { path: \u0026#39;register\u0026#39;, component: RegisterComponent, title: \u0026#39;註冊\u0026#39; }, { path: \u0026#39;profile\u0026#39;, component: ProfileComponent, title: \u0026#39;Profile\u0026#39; }, { path: \u0026#39;userdata\u0026#39;, component: UserdataComponent, title: \u0026#39;使用者資料\u0026#39; }, { path: \u0026#39;order\u0026#39;, component: OrderComponent, title: \u0026#39;訂單\u0026#39; }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39;} ]; @Injectable() export class TemplatePageTitleStrategy extends TitleStrategy { constructor(private readonly title: Title) { super(); } override updateTitle(routerState: RouterStateSnapshot) { const title = this.buildTitle(routerState); if (title !== undefined) { this.title.setTitle(`My App - ${title}`); } } } @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule], providers: [ { provide: TitleStrategy, useClass: TemplatePageTitleStrategy } ] }) export class AppRoutingModule { }   執行結果 真感謝 Angular 14 將此需求變成內建功能。\n","permalink":"https://calvinegs.github.io/posts/angular-titlestrategy/","summary":"github Source code\n需求情境 希望我們的應用程式在每次成功導航後都能自動新瀏覽器的頁面標題。\n當使用者按下“功能列的HOME後，程式除了導覽至 Home Page外，瀏覽器的頁面標題顯示的是: \u0026ldquo;CRUD App - Home\u0026rdquo;\n當使用者按下“功能列的登入按鈕後，程式除了導覽至 登入畫面　外，瀏覽器的頁面標題顯示的是: \u0026ldquo;CRUD App - Login\u0026rdquo;\n檢視 Angular/CLI $ ng version _ _ ____ _ ___ / \\  _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 14.","title":"使用 Angular 14 中內建的 TitleStrategy 功能來自定瀏覽器的頁面標題"},{"content":"github Source code\n本文主要的主題是要呈現如何完成具有 \u0026ldquo;新增、修改、刪除、查詢“ Todo List 功能的 Angular Application。同時搭配使用者角色/權限控管來呈現不同 UI 功能。\n在最後的章節會介紹到如何使用 Angular Directive 來簡化程式避免程式碼重覆。\n為完整性考量，還是記錄如何一步步從無到有使用 Angular 14 相關功能來建立一個使用者資料註冊、登入的表單功能（連結到後端 node+MySQL Web API )，在這些表單中按下送出時會自動檢核使用者所輸入的資料是否合乎程式中所設定的檢核邏輯，並顯示合適的訊息反應給使用者。其中將會使用到下列技術:\n Angular CLI 14 Bootstrap 5 (UI Framework) Angular  Reactive Form Custome Validator Interceptor JWT Session Storage Router Services Guard \u0026amp; Router Data RxJs Custome Directive     註1: 若你已經查閱過 使用 Angular 14 建立 Reactive Form 表單驗證範例 這篇筆記了，那可以直接跳到 \u0026ldquo;完成 Todo 相關 Component 的功能\u0026rdquo; 這個章節。\n註2: 若你要更瞭解後端 Web API 可參考此篇 使用 Node.js + express + MySQL 建立一個後端服務 REST API 筆記。\n 安裝 Angular/CLI 檢視目前環境為 node v16.14.0， global 安裝的是 Angular CLI 13.3.6\n$ node --version v16.14.0 $ ng version _ _ ____ _ ___ / \\  _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 13.3.6 Node: 16.14.0 Package Manager: npm 8.3.1 OS: linux x64 Angular: ... Package Version ------------------------------------------------------ @angular-devkit/architect 0.1303.6 (cli-only) @angular-devkit/core 13.3.6 (cli-only) @angular-devkit/schematics 13.3.6 (cli-only) @schematics/angular 13.3.6 (cli-only) 在 Local 安裝 Angular CLI ver.14 $ mkdir angular14 \u0026amp;\u0026amp; cd angular14 $ npm install @angular/cli@14 added 219 packages, and audited 220 packages in 6s 25 packages are looking for funding run `npm fund` for details found 0 vulnerabilities $ ls -al 總用量 176 drwxrwxr-x 3 egs egs 4096 六 16 11:10 . drwxrwxr-x 10 egs egs 4096 六 16 11:10 .. drwxrwxr-x 191 egs egs 4096 六 16 11:10 node_modules -rw-rw-r-- 1 egs egs 58 六 16 11:10 package.json -rw-rw-r-- 1 egs egs 163807 六 16 11:10 package-lock.json $ cat package.json { \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/cli\u0026#34;: \u0026#34;^14.0.2\u0026#34; } } $ npx ng version _ _ ____ _ ___ / \\  _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 14.0.5 Node: 16.14.0 Package Manager: npm 8.3.1 OS: linux x64 Angular: undefined ... Package Version ------------------------------------------------------ @angular-devkit/architect 0.1400.5 @angular-devkit/core 14.0.5 @angular-devkit/schematics 14.0.5 @angular/cli 14.0.5 @schematics/angular 14.0.5 建立新專案 $ npx ng new angular-webapi-crud ? Would you like to add Angular routing? Yes ? Which stylesheet format would you like to use? SCSS [ https://sass-lang.com/documentation/syntax#scss ] CREATE angular-webapi-crud/README.md (1071 bytes) CREATE angular-webapi-crud/.editorconfig (274 bytes) CREATE angular-webapi-crud/.gitignore (548 bytes) CREATE angular-webapi-crud/angular.json (3161 bytes) CREATE angular-webapi-crud/package.json (1050 bytes) CREATE angular-webapi-crud/tsconfig.json (863 bytes) CREATE angular-webapi-crud/.browserslistrc (600 bytes) CREATE angular-webapi-crud/karma.conf.js (1436 bytes) CREATE angular-webapi-crud/tsconfig.app.json (287 bytes) CREATE angular-webapi-crud/tsconfig.spec.json (333 bytes) CREATE angular-webapi-crud/.vscode/extensions.json (130 bytes) CREATE angular-webapi-crud/.vscode/launch.json (474 bytes) CREATE angular-webapi-crud/.vscode/tasks.json (938 bytes) CREATE angular-webapi-crud/src/favicon.ico (948 bytes) CREATE angular-webapi-crud/src/index.html (303 bytes) CREATE angular-webapi-crud/src/main.ts (372 bytes) CREATE angular-webapi-crud/src/polyfills.ts (2338 bytes) CREATE angular-webapi-crud/src/styles.scss (80 bytes) CREATE angular-webapi-crud/src/test.ts (749 bytes) CREATE angular-webapi-crud/src/assets/.gitkeep (0 bytes) CREATE angular-webapi-crud/src/environments/environment.prod.ts (51 bytes) CREATE angular-webapi-crud/src/environments/environment.ts (658 bytes) CREATE angular-webapi-crud/src/app/app-routing.module.ts (245 bytes) CREATE angular-webapi-crud/src/app/app.module.ts (393 bytes) CREATE angular-webapi-crud/src/app/app.component.scss (0 bytes) CREATE angular-webapi-crud/src/app/app.component.html (23364 bytes) CREATE angular-webapi-crud/src/app/app.component.spec.ts (1112 bytes) CREATE angular-webapi-crud/src/app/app.component.ts (224 bytes) ✔ Packages installed successfully. Successfully initialized git. $ cd angular-webapi-curd $ cat package.json { \u0026#34;name\u0026#34;: \u0026#34;angular-webapi-crud\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;ng build --watch --configuration development\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34; }, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;rxjs\u0026#34;: \u0026#34;~7.5.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^2.3.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.11.4\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;^14.0.5\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~14.0.5\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~4.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~4.1.0\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~6.3.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~3.1.0\u0026#34;, \u0026#34;karma-coverage\u0026#34;: \u0026#34;~2.2.0\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;~1.7.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~4.7.2\u0026#34; } } 執行由 CLI 産生的預設程式架構\n$ npm start \u0026gt; angular-webapi-crud@0.0.0 start \u0026gt; ng serve ✔ Browser application bundle generation complete. Initial Chunk Files | Names | Raw Size vendor.js | vendor | 2.02 MB | polyfills.js | polyfills | 315.29 kB | styles.css, styles.js | styles | 207.83 kB | main.js | main | 50.14 kB | runtime.js | runtime | 6.54 kB | | Initial Total | 2.58 MB Build at: 2022-07-11T09:47:38.380Z - Hash: 1a9fa50dab468973 - Time: 10661ms ** Angular Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ ** ✔ Compiled successfully. 開啟瀏覽器，輸入 http://localhost:4200/\n$ ls -al 總用量 868 drwxrwxr-x 7 egs egs 4096 六 15 11:24 . drwxrwxr-x 4 egs egs 4096 六 15 11:21 .. drwxrwxr-x 3 egs egs 4096 六 15 11:24 .angular -rw-rw-r-- 1 egs egs 3146 六 15 11:21 angular.json -rw-rw-r-- 1 egs egs 600 六 15 11:21 .browserslistrc -rw-rw-r-- 1 egs egs 274 六 15 11:21 .editorconfig drwxrwxr-x 8 egs egs 4096 六 15 11:22 .git -rw-rw-r-- 1 egs egs 548 六 15 11:21 .gitignore -rw-rw-r-- 1 egs egs 1433 六 15 11:21 karma.conf.js drwxrwxr-x 596 egs egs 20480 六 15 11:24 node_modules -rw-rw-r-- 1 egs egs 1047 六 15 11:21 package.json -rw-rw-r-- 1 egs egs 800093 六 15 11:22 package-lock.json -rw-rw-r-- 1 egs egs 1068 六 15 11:21 README.md drwxrwxr-x 5 egs egs 4096 六 15 11:21 src -rw-rw-r-- 1 egs egs 287 六 15 11:21 tsconfig.app.json -rw-rw-r-- 1 egs egs 863 六 15 11:21 tsconfig.json -rw-rw-r-- 1 egs egs 333 六 15 11:21 tsconfig.spec.json drwxrwxr-x 2 egs egs 4096 六 15 11:21 .vscode 設置專案 建立相關元件 與 服務 $ ng g s shared/services/auth # 新增 auth service $ ng g s shared/services/token-storage # 新增 token-storage service $ ng g s shared/services/todo # 新增 todo service $ ng g class shared/models/todo --type=model $ ng g interceptor shared/interceptor/auth　# 新增 auth interceptor $ ng g c pages/login $ ng g c pages/register $ ng g c pages/profile $ ng g c pages/home $ ng g c pages/add-todo $ ng g c pages/todo-detail $ ng g c pages/todo-list $ ng g guard shared/guard/auth --implements=\u0026#34;CanActivate\u0026#34; # 新增 auth guard $ ng g guard shared/guard/role --implements=\u0026#34;CanActivate\u0026#34; # 新增 role guard 檔案結構 定義 Ｍodel Class 主要會用到的 Model Class 是 Todo。shared/models/todo.model.ts\nexport class Todo { id?: any; title?: string; description?: string; status?: boolean; } 撰寫 Data Services 程式 打開 vscode\n$ code .　# 打開 vscode 將程式中會使用的參數值放在 appSettings.ts 中 在開始新增 Services 程式前，我們可以考慮將固定的參數值放在 appSettings.ts 中，來增加一些彈性。在 shared目錄下新增一個　helpers 的子目錄，並新增一支 appSettings.ts 程式，內容如下。設置一個靜態常數 API_URL，並把它 export 出來，讓外面的程式可以引用它。\nexport class AppSettings { static API_URL = \u0026#39;http://localhost:5000/api/\u0026#39;; } 註冊與登入使用的服務程式 auth.service.ts 註冊與登入功能須搭配後端 API，可參考　使用 Node.js + express + MariaDB 建立一個後端服務 REST API\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { AppSettings } from \u0026#39;../helpers/appSettings\u0026#39;; const API_URL = AppSettings.API_URL + \u0026#39;auth/\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class AuthService { constructor( private http: HttpClient) { } login(username: string, password: string): Observable\u0026lt;any\u0026gt; { return this.http.post(API_URL + \u0026#39;signin\u0026#39;, { username, password }) } register(username: string, email:string, password: string): Observable\u0026lt;any\u0026gt; { return this.http.post(API_URL + \u0026#39;signup\u0026#39;, { username, email, password }) } }   Token 相關的服務程式 token-storage.service.ts 在本範例中，我們會把由 API 讀取回來的 Token 儲存在 local 瀏覽器中的 Session Local Storage 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import { Injectable } from \u0026#39;@angular/core\u0026#39;; const TOKEN_KEY = \u0026#39;auth-token\u0026#39;; const USER_KEY = \u0026#39;auth-user\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class TokenStorageService { constructor() { } signOut(): void { window.sessionStorage.clear(); } public saveToken(token: string): void { sessionStorage.removeItem(TOKEN_KEY); sessionStorage.setItem(TOKEN_KEY, token); } public getToken(): string | null { return sessionStorage.getItem(TOKEN_KEY); } public saveUser(user: any): void { sessionStorage.removeItem(USER_KEY); sessionStorage.setItem(USER_KEY, JSON.stringify(user)); } public getUser(): any { const user = sessionStorage.getItem(USER_KEY); if (user) { return JSON.parse(user); } return user; } }   Todo 相關的服務程式 todo.service.ts todo service 是藉由 後端的 Web API 來完成 Todo 資料的新增、修改、刪除、查詢等資料庫功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { Todo } from \u0026#39;../models/todo.model\u0026#39;; import { AppSettings } from \u0026#39;../helpers/appSettings\u0026#39;; const API_URL = AppSettings.API_URL + \u0026#39;todos/\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class TodoService { constructor(private http: HttpClient) { } getAll(): Observable\u0026lt;Todo[]\u0026gt; { return this.http.get\u0026lt;Todo[]\u0026gt;(API_URL); } get(id: any): Observable\u0026lt;Todo\u0026gt; { return this.http.get(`${API_URL}/${id}`); } create(data: any): Observable\u0026lt;any\u0026gt; { return this.http.post(API_URL, data); } update(id: any, data: any): Observable\u0026lt;any\u0026gt; { return this.http.put(`${API_URL}/${id}`, data); } delete(id: any): Observable\u0026lt;any\u0026gt; { return this.http.delete(`${API_URL}/${id}`); } deleteAll(): Observable\u0026lt;any\u0026gt; { return this.http.delete(API_URL); } findByTitle(title: any): Observable\u0026lt;Todo[]\u0026gt; { return this.http.get\u0026lt;Todo[]\u0026gt;(`${API_URL}?title=${title}`); } }   撰寫 HTTP Interceptor 程式 HTTP Interceptor 可以讓我們很容易的在每一個 request Header 中加入我們登入成功後由 API 回傳回來的｀合法Token`。在這個程式中唯一要注意的是，不應更改原始的 request，而是應該透過 clone 功能來産生一個新的 request 再將 token 寫入這個新 request 的 Header。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // ./app/shared/interceptor/auth.interceptor.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor, HTTP_INTERCEPTORS } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { TokenStorageService } from \u0026#39;../services/token-storage.service\u0026#39;; @Injectable() export class AuthInterceptor implements HttpInterceptor { constructor(private tokenService: TokenStorageService) {} intercept(request: HttpRequest\u0026lt;any\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;any\u0026gt;\u0026gt; { let authRequest = request; const token = this.tokenService.getToken(); if (token != null) { authRequest = request.clone({ setHeaders: { Authorization: `Bearer ${token}` } }); } return next.handle(authRequest); } } export const authInterceptorProviders = [{ provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }]   將 HTTP Interceptor 加入到 app module 的 providers 上述完成的 Interceptor 要記得注入到 app module providers 設定中（第13、32行）。 同時，在前述的 services 中我們使用到了 HttpClient，所以也必須匯入 HttpClient Module（第14、30行）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { AddTodoComponent } from \u0026#39;./pages/add-todo/add-todo.component\u0026#39;; import { TodoDetailComponent } from \u0026#39;./pages/todo-detail/todo-detail.component\u0026#39;; import { TodoListComponent } from \u0026#39;./pages/todo-list/todo-list.component\u0026#39;; import { FormsModule } from \u0026#39;@angular/forms\u0026#39;; import { authInterceptorProviders } from \u0026#39;./shared/interceptor/auth.interceptor\u0026#39;; @NgModule({ declarations: [ AppComponent, LoginComponent, RegisterComponent, ProfileComponent, HomeComponent, AddTodoComponent, TodoDetailComponent, TodoListComponent ], imports: [ BrowserModule, AppRoutingModule,  FormsModule, HttpClientModule  ], providers: [authInterceptorProviders], bootstrap: [AppComponent] }) export class AppModule { }   新增 components 接著要來建立 components，在此我們使的是 Reactive Form 並使用 bootstrap CSS framework來裝飾我們的 component ，所必須先進行相關設定\n匯入 ReactiveFormModule 模組 開啟 src/app/app.module.ts 並由 @angular/forms 匯入 ReactiveFormModule\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; //... @NgModule({ declarations: [ AppComponent //...  ], imports: [ BrowserModule, AppRoutingModule, ReactiveFormsModule,  HttpClientModule ], providers: [authInterceptorProviders], bootstrap: [AppComponent] }) export class AppModule { }   使用 Bootstrap 開啟 src/index.html 在  加入 link tag\n 使用 bootstrap 5 如第 9 行匯入語法  1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;AngularAuthJwt\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   新增 Register Component 註冊元件的程式碼\n// register.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormControl, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; import Validation from \u0026#39;src/app/shared/helpers/validation\u0026#39;; import { AuthService } from \u0026#39;src/app/shared/services/auth.service\u0026#39;; @Component({ selector: \u0026#39;app-register\u0026#39;, templateUrl: \u0026#39;./register.component.html\u0026#39;, styleUrls: [\u0026#39;./register.component.scss\u0026#39;] }) export class RegisterComponent implements OnInit { form: FormGroup = new FormGroup({ username: new FormControl(\u0026#39;\u0026#39;), email: new FormControl(\u0026#39;\u0026#39;), password: new FormControl(\u0026#39;\u0026#39;), confirmPassword: new FormControl(\u0026#39;\u0026#39;) }); submitted = false; isSuccessful = false;; isSignUpFailed = false; errorMessage = \u0026#39;\u0026#39;; constructor(private formBuilder: FormBuilder, private authService: AuthService) { } ngOnInit(): void { this.form = this.formBuilder.group( { username: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(4), Validators.maxLength(20) ] ], email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]], password: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(40) ] ], confirmPassword: [\u0026#39;\u0026#39;,Validators.required], }, { validators: [Validation.match(\u0026#39;password\u0026#39;, \u0026#39;confirmPassword\u0026#39;)] } ) } get f(): { [key: string]: AbstractControl } { return this.form.controls; } onSubmit(): void { this.submitted = true; if (this.form.invalid) { return; } const { username, email, password } = this.form.getRawValue(); this.authService.register(username!, email!, password!).subscribe({ next: (data) =\u0026gt; { console.log(data); this.isSuccessful = true; this.isSignUpFailed = false; }, error: (err) =\u0026gt; { this.isSuccessful = false; this.isSignUpFailed = true; } }); } onReset(): void { this.submitted = false; this.isSignUpFailed = false; this.form.reset(); } } 在 Register Component 中我們使用了一個 Custom Validator，它用來比對二次輸入的密碼是否一致，程式碼如下：\n// validation.ts import { AbstractControl, ValidatorFn } from \u0026#34;@angular/forms\u0026#34;; export default class Validation { static match(controlName: string, checkControlName: string): ValidatorFn { return (controls: AbstractControl) =\u0026gt; { const control = controls.get(controlName); const checkControl = controls.get(checkControlName); if (checkControl?.errors \u0026amp;\u0026amp; !checkControl.errors[\u0026#39;matching\u0026#39;]) { return null; } if (control?.value !== checkControl?.value) { controls.get(checkControlName)?.setErrors({ matching: true }); return { match: true }; } else { return null; } } } } 註冊元件的 HTML\n\u0026lt;!-- register.component.html --\u0026gt; \u0026lt;div class=\u0026#34;container-fluid register-form\u0026#34;\u0026gt; \u0026lt;form needs-validation [formGroup]=\u0026#34;form\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; 使用者資料註冊 \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; autofocus formControlName=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;username\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Username 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;minlength\u0026#39;]\u0026#34;\u0026gt; Username 必須至少為六個字元 \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;maxlength\u0026#39;]\u0026#34;\u0026gt; Username 必須至多為二十個字元 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;email\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;email\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;email\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;email\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Email 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;email\u0026#39;].errors[\u0026#39;email\u0026#39;]\u0026#34;\u0026gt;Email 格式不符\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;password\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Password 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;minlength\u0026#39;]\u0026#34;\u0026gt; Password 必須至少為六個字元 \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;maxlength\u0026#39;]\u0026#34;\u0026gt; Password 必須至多為四十個字元 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;confirmPassword\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Confirm Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;confirmPassword\u0026#34; id=\u0026#34;confirmPassword\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;confirmPassword\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;confirmPassword\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;confirmPassword\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;confirmPassword\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Confirm Password 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;confirmPassword\u0026#39;].errors[\u0026#39;matching\u0026#39;]\u0026#34;\u0026gt; Confirm Password 不符 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;送出\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;onReset()\u0026#34; class=\u0026#34;btn btn-warning float-end\u0026#34;\u0026gt; 重置 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alert alert-warning\u0026#34; *ngIf=\u0026#34;isSignUpFailed\u0026#34;\u0026gt; 註冊失敗!\u0026lt;br /\u0026gt;{{ errorMessage }} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alert alert-success\u0026#34; *ngIf=\u0026#34;isSuccessful\u0026#34;\u0026gt; 註冊成功！ \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; 註冊元件的 CSS\n/* register.component.scss */ .register-form { max-width: 350px; margin: auto; } 新增 Login Component 登入元件的程式碼\n// login.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormControl, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; import { AuthService } from \u0026#39;src/app/shared/services/auth.service\u0026#39;; import { TokenStorageService } from \u0026#39;src/app/shared/services/token-storage.service\u0026#39;; @Component({ selector: \u0026#39;app-login\u0026#39;, templateUrl: \u0026#39;./login.component.html\u0026#39;, styleUrls: [\u0026#39;./login.component.scss\u0026#39;] }) export class LoginComponent implements OnInit { form: FormGroup = new FormGroup({ username: new FormControl(\u0026#39;\u0026#39;), password: new FormControl(\u0026#39;\u0026#39;) }); isLoggedIn = false; isLoginFailed = false; submitted = false; errorMessage = \u0026#39;\u0026#39;; roles: string[] = []; constructor(private formBuilder: FormBuilder, private authService: AuthService, private tokenStorage: TokenStorageService) { } ngOnInit(): void { if (this.tokenStorage.getToken()) { this.isLoggedIn = true; this.roles = this.tokenStorage.getUser().roles; } this.form = this.formBuilder.group( { username: [\u0026#39;\u0026#39;,[Validators.required]], password: [\u0026#39;\u0026#39;,[Validators.required]] } ) } get f(): { [key: string]: AbstractControl } { return this.form.controls; } onSubmit(): void { this.submitted = true; if (this.form.invalid) { return; } const { username, password } = this.form.getRawValue(); this.authService.login(username, password).subscribe({ next: data =\u0026gt; { this.tokenStorage.saveToken(data.accessToken); this.tokenStorage.saveUser(data); this.isLoggedIn = true; this.roles = this.tokenStorage.getUser().roles; this.roloadPage(); }, error: err =\u0026gt; { this.errorMessage = err.error.message; this.isLoginFailed = true; } }) } roloadPage(): void { this.submitted = false; location.reload(); } onReset(): void { this.submitted = false; this.isLoginFailed = false; this.form.reset(); } } 登入元件的 HTML\n\u0026lt;!-- login.component.html --\u0026gt; \u0026lt;div class=\u0026#34;container-fluid register-form\u0026#34;\u0026gt; \u0026lt;form *ngIf=\u0026#34;!isLoggedIn\u0026#34; needs-validation [formGroup]=\u0026#34;form\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; 使用者登入 \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; autofocus formControlName=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;username\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Username 為必填\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;password\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Password 為必填\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;送出\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;onReset()\u0026#34; class=\u0026#34;btn btn-warning float-end\u0026#34;\u0026gt; 重置 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alert alert-warning\u0026#34; *ngIf=\u0026#34;isLoginFailed\u0026#34;\u0026gt; Signin failed!\u0026lt;br /\u0026gt;{{ errorMessage }} \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;alert alert-success\u0026#34; *ngIf=\u0026#34;isLoggedIn\u0026#34;\u0026gt; 登入者具備的角色 {{ roles }}. \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 登入元件的 CSS\n/* login.component.scss */ .login-form { max-width: 350px; margin: auto; } 新增 Profile Component 個人檔案的程式碼\n// profile.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { TokenStorageService } from \u0026#39;src/app/shared/services/token-storage.service\u0026#39;; @Component({ selector: \u0026#39;app-profile\u0026#39;, templateUrl: \u0026#39;./profile.component.html\u0026#39;, styleUrls: [\u0026#39;./profile.component.scss\u0026#39;] }) export class ProfileComponent implements OnInit { currentUser: any; constructor(private token: TokenStorageService) { } ngOnInit(): void { this.currentUser = this.token.getUser(); } } 個人檔案的 HTML\n\u0026lt;!-- profile.component.html --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34; *ngIf=\u0026#34;currentUser; else loggedOut\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;jumbotron\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;strong\u0026gt;{{ currentUser.username }}\u0026lt;/strong\u0026gt; 個人訊息\u0026lt;/h3\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Token:\u0026lt;/strong\u0026gt; {{ currentUser.accessToken.substring(0, 20)}} ... {{ currentUser.accessToken.substr( currentUser.accessToken.length - 20)}} \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;電子信箱:\u0026lt;/strong\u0026gt; {{ currentUser.email }} \u0026lt;/p\u0026gt; \u0026lt;strong\u0026gt;參與的角色:\u0026lt;/strong\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let role of currentUser.roles\u0026#34;\u0026gt; {{ role }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ng-template #loggedOut\u0026gt; 請先登入 \u0026lt;/ng-template\u0026gt; 路由設置 透過路由的設置，程式才會知道當使用者在瀏覧器特定的 URI 時，程式應該去執那支相對應的程式。路由模組檔案（app-routin.module.ts）內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { AddTodoComponent } from \u0026#39;./pages/add-todo/add-todo.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { TodoDetailComponent } from \u0026#39;./pages/todo-detail/todo-detail.component\u0026#39;; import { TodoListComponent } from \u0026#39;./pages/todo-list/todo-list.component\u0026#39;; const routes: Routes = [  { path: \u0026#39;home\u0026#39;, component: HomeComponent }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, { path: \u0026#39;register\u0026#39;, component: RegisterComponent }, { path: \u0026#39;profile\u0026#39;, component: ProfileComponent }, { path: \u0026#39;add-todo\u0026#39;, component: AddTodoComponent }, { path: \u0026#39;todo-detail\u0026#39;, component: TodoDetailComponent }, { path: \u0026#39;todo-list\u0026#39;, component: TodoListComponent }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39; } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   App Module 的設置 // app.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { AddTodoComponent } from \u0026#39;./pages/add-todo/add-todo.component\u0026#39;; import { TodoDetailComponent } from \u0026#39;./pages/todo-detail/todo-detail.component\u0026#39;; import { TodoListComponent } from \u0026#39;./pages/todo-list/todo-list.component\u0026#39;; import { authInterceptorProviders } from \u0026#39;./shared/interceptor/auth.interceptor\u0026#39;; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;; import { ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;; @NgModule({ declarations: [ AppComponent, LoginComponent, RegisterComponent, ProfileComponent, HomeComponent, AddTodoComponent, TodoDetailComponent, TodoListComponent ], imports: [ BrowserModule, AppRoutingModule, ReactiveFormsModule, HttpClientModule ], providers: [authInterceptorProviders], bootstrap: [AppComponent] }) export class AppModule { } App Component 修改 // app.component.ts import { Component } from \u0026#39;@angular/core\u0026#39;; import { TokenStorageService } from \u0026#39;./shared/services/token-storage.service\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent { private roles: string[] = []; //使用者具備的角色  isLoggedIn = false; //用來記錄是否已登入系統的變數  showAdminFunction = false; //記錄是否有｀管理者｀角色的變數  username?: string; constructor(private tokenStorageService: TokenStorageService) { } ngOnInit(): void { // 若在 session storage 中有有效的 token 則表示已有正常的登入系統  this.isLoggedIn = !!this.tokenStorageService.getToken(); if(this.isLoggedIn) { const user = this.tokenStorageService.getUser(); this.roles = user.roles; this.showAdminFunction = this.roles.includes(\u0026#34;ADMIN\u0026#34;); this.username = user.username; } } logout(): void { this.tokenStorageService.signOut(); //清除 session storage  location.reload(); } } \u0026lt;!-- app.component.html --\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;nav class=\u0026#34;navbar navbar-expand navbar-dark bg-dark\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;navbar-brand\u0026#34;\u0026gt;Angular curd example\u0026lt;/a\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav me-auto\u0026#34; routerLinkActive=\u0026#34;active\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/home\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;home\u0026#34;\u0026gt;首頁\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/todo-list\u0026#34; class=\u0026#34;nav-link\u0026#34; *ngIf=\u0026#34;isLoggedIn\u0026#34; routerLink=\u0026#34;todo-list\u0026#34;\u0026gt;Todo\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34; *ngIf=\u0026#34;showAdminFunction\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/add-todo\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;add-todo\u0026#34;\u0026gt;新增\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav ms-auto\u0026#34; *ngIf=\u0026#34;!isLoggedIn\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/register\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;register\u0026#34;\u0026gt;註冊\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/login\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;login\u0026#34;\u0026gt;登入\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav ms-auto\u0026#34; *ngIf=\u0026#34;isLoggedIn\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/profile\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;profile\u0026#34;\u0026gt;{{ username }}\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href class=\u0026#34;nav-link\u0026#34; (click)=\u0026#34;logout()\u0026#34;\u0026gt;登出\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 執行程式 結行結果：\n Home Page  首頁為預設的 Page，同時它也是一供公開的功能，沒有使用權限的限定，所以即使你未登入，也可以瀏覽此網頁。\n一般使用者登入後的畫面  以已註冊的使用者登入系統後，可以發現主頁面上的功能選項多出了 “Todo” 與 \u0026ldquo;tomchen\u0026rdquo; 兩項\n其中 ｀tomchen｀ 指的是現在已登入者的 username (登入帳號)，同時點進這功能會顯示使用者的明細資料。 而｀Todo｀這個功能項目也是隨著使用者登入成功後才顯示出來的。\n管理角色使用者登入後的畫面  下圖是以｀管理者｀角色登入後所顯示的畫面。而因為這個使用者具備有管理者角色（admin)，所以功能選項同時出現了 ｀Add｀這個項目。 Route Guard (路由保護器) 由上述的測試，發現一個問題，當使用一般 User 帳號登時時，雖然在畫面上方的功能選項中沒有出現 \u0026ldquo;新增\u0026rdquo; 的功能選項，但你卻可以直接在瀏覽器的網址列輸入 http://localhost:4200/add-todo 來執行 Todo 的功能。這個路由所對應到的程式是可以被執行的。\n還有一個更嚴重的情境，在未登入的狀態下，你也可以直接在瀏覽器的網址列輸入 http://localhost:4200/add-todo 來執行 Todo 的功能。\n由而看起來，我們的權限控制只做了半套。那麼應該要如何來解決這樣的問題呢？\n帳號認證攔截器 首先介紹的　路由保護器(攔截器)　是一種 local 端保護機制。透過 Route Guard 的設置可以在使用者端就能效管理各個 route 的執行權限的控管。\nauthGuard 這個路由保護器的功能就是來攔截沒有正常登入系統的使用者不得執行特定的路由。在程式中透過 tokenService.getToken() 功能來讀取 token，若 session storeage 中沒有合法 token，表示目前還沒有正確的登入系統，並將程式指向登入功能。\n// auth.guard.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRouteSnapshot, CanActivate, Router, RouterStateSnapshot, UrlTree } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { TokenStorageService } from \u0026#39;../services/token-storage.service\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class AuthGuard implements CanActivate { constructor(private router: Router, private tokenService: TokenStorageService) {} canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable\u0026lt;boolean | UrlTree\u0026gt; | Promise\u0026lt;boolean | UrlTree\u0026gt; | boolean | UrlTree { if (this.tokenService.getToken()) return true; this.router.navigate([\u0026#39;/login\u0026#39;]); return true; } } app-routing.module.ts 中的路由設定，將 AuthGurad 加入到要保護的 路由設定　中。 如下程式第18行{ path: 'add-todo', canActivate:[AuthGuard], component: AddTodoComponent },，其中的　canActivate:[AuthGuard] 就是幫這個路由設定加入了 ‘AuthGuard’ 這個攔截器來起到保護這個路由的作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { AddTodoComponent } from \u0026#39;./pages/add-todo/add-todo.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { TodoDetailComponent } from \u0026#39;./pages/todo-detail/todo-detail.component\u0026#39;; import { TodoListComponent } from \u0026#39;./pages/todo-list/todo-list.component\u0026#39;; import { AuthGuard } from \u0026#39;./shared/guard/auth.guard\u0026#39;;  const routes: Routes = [ { path: \u0026#39;home\u0026#39;, component: HomeComponent }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, { path: \u0026#39;register\u0026#39;, component: RegisterComponent }, { path: \u0026#39;profile\u0026#39;, component: ProfileComponent }, { path: \u0026#39;add-todo\u0026#39;, canActivate:[AuthGuard], component: AddTodoComponent },  { path: \u0026#39;todo-detail\u0026#39;, canActivate:[AuthGuard], component: TodoDetailComponent }, { path: \u0026#39;todo-list\u0026#39;, canActivate:[AuthGuard], component: TodoListComponent }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39; } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   完成上述的程式後，我們再來測試一下“未登入而直接在瀏覽器的網址列輸入 http://localhost:4200/add-todo 這個情境。你會發現輸入 http://localhost:4200/add-todo再按下 enter 鍵後，系統會檢核出尚未登入而自動轉址到使用者登入功能中。\n角色授權攔截器 接下來要介紹roleGuard 這個路由保護器的功能就是來攔截現行的使用者是否具備有特定的角色，若沒有指定的角色不得執行特定的路由。並顯示目前使有者所具備的角色有那些。\n// role.guard.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRouteSnapshot, CanActivate, Router, RouterStateSnapshot, UrlTree } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { TokenStorageService } from \u0026#39;../services/token-storage.service\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class RoleGuard implements CanActivate { constructor(private router: Router, private tokenService: TokenStorageService) {}; canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable\u0026lt;boolean | UrlTree\u0026gt; | Promise\u0026lt;boolean | UrlTree\u0026gt; | boolean | UrlTree { const roles = this.tokenService.getUser().roles; const rolesPara = route.data[\u0026#34;roles\u0026#34;] as Array\u0026lt;string\u0026gt;; let searchRole = \u0026#39;ADMIN\u0026#39;; if (rolesPara) { searchRole = rolesPara[0].toUpperCase(); } if (roles) { const rolesArray = roles as Array\u0026lt;string\u0026gt; if (rolesArray.indexOf(searchRole) != -1) return true; }; this.router.navigate([\u0026#39;/login\u0026#39;]); return true; } } 將 RoleGurad 加入到要保護的 路由設定　中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { AddTodoComponent } from \u0026#39;./pages/add-todo/add-todo.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { TodoDetailComponent } from \u0026#39;./pages/todo-detail/todo-detail.component\u0026#39;; import { TodoListComponent } from \u0026#39;./pages/todo-list/todo-list.component\u0026#39;; import { AuthGuard } from \u0026#39;./shared/guard/auth.guard\u0026#39;; import { RoleGuard } from \u0026#39;./shared/guard/role.guard\u0026#39;;  const routes: Routes = [ { path: \u0026#39;home\u0026#39;, component: HomeComponent }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, { path: \u0026#39;register\u0026#39;, component: RegisterComponent }, { path: \u0026#39;profile\u0026#39;, component: ProfileComponent }, { path: \u0026#39;add-todo\u0026#39;, canActivate:[AuthGuard, RoleGuard], component: AddTodoComponent },  { path: \u0026#39;todo-detail\u0026#39;, canActivate:[AuthGuard], component: TodoDetailComponent }, { path: \u0026#39;todo-list\u0026#39;, canActivate:[AuthGuard], component: TodoListComponent }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39; } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   完成上述功能後，就只有具備有“ADMIN”角色者才能執行“add-todo”功能了。\n完成 Todo 相關 Component 的功能 程式至止算是完成了“基礎“的部份，接下來要回歸本篇筆記的主題 - Todo list 的資料維護。包含有“新增 Todo Item\u0026rdquo;、“顯示 Todo Item 清單”、\u0026ldquo;Todo 明細\u0026quot;等 Component。\n新增 Todo Item 的 Component 新增 Todo Item 時透過　TodoService.create() function來完成。\n// add-todo.component.ts import { Component, OnInit, ValueProvider } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormControl, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; import { Router } from \u0026#39;@angular/router\u0026#39;; import { Todo } from \u0026#39;src/app/shared/models/todo.model\u0026#39;; import { TodoService } from \u0026#39;src/app/shared/services/todo.service\u0026#39;; @Component({ selector: \u0026#39;app-add-todo\u0026#39;, templateUrl: \u0026#39;./add-todo.component.html\u0026#39;, styleUrls: [\u0026#39;./add-todo.component.scss\u0026#39;] }) export class AddTodoComponent implements OnInit { form: FormGroup = new FormGroup({ title: new FormControl(\u0026#39;\u0026#39;), description: new FormControl(\u0026#39;\u0026#39;) }); submitted = false; // 送出否  isAddFailed = false; // 新增有誤否  isAdded = false; // 新增成功否  errorMessage = \u0026#34;\u0026#34;; constructor(private formBuilder: FormBuilder, private router: Router, private todoService: TodoService) { } ngOnInit(): void { this.form = this.formBuilder.group( { title: [\u0026#39;\u0026#39;,[Validators.required]], description: [\u0026#39;\u0026#39;,[Validators.required]] } )} onSubmit(): void { this.submitted = true; if (this.form.invalid) { return; } const data = this.form.getRawValue(); this.todoService.create(data) .subscribe({ next: (res) =\u0026gt; { this.isAdded = true; this.router.navigate([\u0026#39;/todolist\u0026#39;]); }, error: (e) =\u0026gt; { this.errorMessage = e.message this.isAddFailed = true; } }); } get f(): { [key: string]: AbstractControl } { return this.form.controls; } onReset(): void { this.submitted = false; this.isAddFailed = false; this.form.reset(); } } \u0026lt;!-- add-todo.component.html --\u0026gt; \u0026lt;div class=\u0026#34;container-fluid submit-form\u0026#34;\u0026gt; \u0026lt;form *ngIf=\u0026#34;!isAdded\u0026#34; needs-validation [formGroup]=\u0026#34;form\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; 新增 Todo \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;title\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Title\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; autofocus formControlName=\u0026#34;title\u0026#34; id=\u0026#34;title\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;title\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;title\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;title\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;title\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Title 為必填\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;description\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Description\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;description\u0026#34; formControlName=\u0026#34;description\u0026#34; id=\u0026#34;description\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;description\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;description\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;description\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;description\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Description 為必填\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;送出\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;onReset()\u0026#34; class=\u0026#34;btn btn-warning float-end\u0026#34;\u0026gt; 重置 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alert alert-warning\u0026#34; *ngIf=\u0026#34;isAddFailed\u0026#34;\u0026gt; 新增有誤!\u0026lt;br /\u0026gt;{{ errorMessage }} \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;alert alert-success\u0026#34; *ngIf=\u0026#34;isAdded\u0026#34;\u0026gt; 新增成功! \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; /* add-todo.scss */ .submit-form { max-width: 400px; margin: auto; } Todo Item 清單 的 Component // todo-list.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { VirtualTimeScheduler } from \u0026#39;rxjs\u0026#39;; import { Todo } from \u0026#39;src/app/shared/models/todo.model\u0026#39;; import { TodoService } from \u0026#39;src/app/shared/services/todo.service\u0026#39;; @Component({ selector: \u0026#39;app-todo-list\u0026#39;, templateUrl: \u0026#39;./todo-list.component.html\u0026#39;, styleUrls: [\u0026#39;./todo-list.component.scss\u0026#39;] }) export class TodoListComponent implements OnInit { todos?: Todo[]; currentTodo: Todo = {}; currentIndex = -1; title=\u0026#39;\u0026#39;; constructor(private todoService: TodoService) { } ngOnInit(): void { this.retrieveTodos(); } // 取得所有的 Todo Lists  retrieveTodos(): void { this.todoService.getAll() .subscribe({ next: (data) =\u0026gt; { this.todos = data; }, error: (e) =\u0026gt; console.log(e) }); } // 重新取得所有的 Todo Lists  refreshList(): void { this.retrieveTodos(); this.currentTodo = {}; this.currentIndex = -1 } // 設定現行 Todo  setActiveTodo(todo: Todo, index: number): void { this.currentTodo = todo; this.currentIndex = index; } // 移除所有 Todo Lists  removeAllTodos(): void { this.todoService.deleteAll() .subscribe({ next: (res) =\u0026gt; { this.refreshList(); }, error: (e) =\u0026gt; console.log(e) }); } // 以關鍵字查詢標題欄以取得 Todo Lists  searchTitle(): void { this.currentTodo = {}; this.currentIndex = -1; this.todoService.findByTitle(this.title) .subscribe({ next: (data) =\u0026gt; { this.todos = data; console.log(data); }, error: (e) =\u0026gt; console.log(e) }); } } \u0026lt;!-- todo-list.component.html --\u0026gt; \u0026lt;div class=\u0026#34;list row\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Todo 資料維護\u0026lt;/h2\u0026gt; \u0026lt;!-- 以關鍵字查詢標題欄以取得 Todo Lists --\u0026gt; \u0026lt;div class=\u0026#34;col-md-8\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-group mb-3\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Search by title\u0026#34; [(ngModel)]=\u0026#34;title\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;input-group-append\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-outline-secondary\u0026#34; type=\u0026#34;button\u0026#34; (click)=\u0026#34;searchTitle()\u0026#34;\u0026gt; 搜尋 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 顯示符合的 Todo 清單 --\u0026gt; \u0026lt;div class=\u0026#34;col-md-6\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;Todo 清單\u0026lt;/h4\u0026gt; \u0026lt;ul class=\u0026#34;list-group\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;list-group-item\u0026#34; *ngFor=\u0026#34;let todo of todos; let i = index\u0026#34; [class.active]=\u0026#34;i == currentIndex\u0026#34; (click)=\u0026#34;setActiveTodo(todo, i)\u0026#34;\u0026gt; {{ todo.title }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 刪除所有 Todo --\u0026gt; \u0026lt;button class=\u0026#34;m-3 btn btn-sm btn-danger\u0026#34; (click)=\u0026#34;removeAllTodos()\u0026#34;\u0026gt; 刪除所有 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 將\u0026#34;Todo 明細\u0026#34;子元件篏入到 Todo List 元件中 --\u0026gt; \u0026lt;div class=\u0026#34;col-md-6\u0026#34;\u0026gt; \u0026lt;app-todo-detail [viewMode]=\u0026#34;false\u0026#34; [currentTodo]=\u0026#34;currentTodo\u0026#34; (refreshProcess)=\u0026#34;refreshList()\u0026#34;\u0026gt;\u0026lt;/app-todo-detail\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; /* todo-list.component.scss */ .list { text-align: left; max-width: 750px; margin: auto; } Todo Item 明細 的 Component // todo-detail.component.ts import { Component, EventEmitter, Input, OnInit, Output } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRoute, Router } from \u0026#39;@angular/router\u0026#39;; import { Todo } from \u0026#39;src/app/shared/models/todo.model\u0026#39;; import { TodoService } from \u0026#39;src/app/shared/services/todo.service\u0026#39;; @Component({ selector: \u0026#39;app-todo-detail\u0026#39;, templateUrl: \u0026#39;./todo-detail.component.html\u0026#39;, styleUrls: [\u0026#39;./todo-detail.component.scss\u0026#39;] }) export class TodoDetailComponent implements OnInit { @Input() viewMode = false; @Input() currentTodo: Todo = { title: \u0026#39;\u0026#39;, description: \u0026#39;\u0026#39;, status: false, } @Output() refreshProcess = new EventEmitter() message = \u0026#39;\u0026#39;; showBackto = 0; constructor(private todoService: TodoService, private route: ActivatedRoute, private router: Router) { } ngOnInit(): void { if (!this.viewMode) { this.message = \u0026#39;\u0026#39;; this.getTodo(this.route.snapshot.params[\u0026#34;id\u0026#34;]); } this.route.queryParams.subscribe(params =\u0026gt; { this.showBackto = params[\u0026#39;showbackto\u0026#39;]; }); } // 取得 Todo 明細內容  getTodo(id: string): void { this.todoService.get(id) .subscribe({ next: (data) =\u0026gt; { this.currentTodo = data; // console.log(data);  }, error: (e) =\u0026gt; console.log(e) }); } // 更新 Todo 狀態  updateStatus(status: boolean): void { const data = { title: this.currentTodo.title, description: this.currentTodo.description, status: status, }; this.message = \u0026#39;\u0026#39;; this.todoService.update(this.currentTodo.id, data) .subscribe({ next: (res) =\u0026gt; { console.log(res); this.currentTodo.status = status; this.message = res.message ? res.message : \u0026#39;狀態更新成功！\u0026#39;; }, error: (e) =\u0026gt; console.log(e) }); } // 修改 Todo 明細  updateTodo(): void { this.message = \u0026#39;\u0026#39;; this.todoService.update(this.currentTodo.id, this.currentTodo) .subscribe({ next: (res) =\u0026gt; { console.log(res); this.message = res.message ? res.message : \u0026#39;todo 更新成功！\u0026#39;; }, error: (e) =\u0026gt; console.log(e) }); } // 刪除 Todo 明細  deleteTodo(): void { this.todoService.delete(this.currentTodo.id) .subscribe({ next: (res) =\u0026gt; { console.log(res); this.router.navigate([\u0026#39;/todolist\u0026#39;]); this.refreshProcess.emit(); }, error: (e) =\u0026gt; console.log(e) }); } backtoTodo(): void { this.router.navigate([\u0026#39;/todolist\u0026#39;]); } } \u0026lt;!-- doto-detail.component.html --\u0026gt; \u0026lt;div *ngIf=\u0026#34;viewMode; else editable\u0026#34;\u0026gt; \u0026lt;!-- 顯示 Todo 明細內容 --\u0026gt; \u0026lt;div *ngIf=\u0026#34;currentTodo.id\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;Todo\u0026lt;/h4\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt;\u0026lt;strong\u0026gt;Title:\u0026lt;/strong\u0026gt;\u0026lt;/label\u0026gt; {{ currentTodo.title }} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt;\u0026lt;strong\u0026gt;Description:\u0026lt;/strong\u0026gt;\u0026lt;/label\u0026gt; {{ currentTodo.description }} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt;\u0026lt;strong\u0026gt;Status:\u0026lt;/strong\u0026gt;\u0026lt;/label\u0026gt; {{ currentTodo.status ? \u0026#34;Done\u0026#34; : \u0026#34;Pending\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;!-- 切換至編輯畫面 --\u0026gt; \u0026lt;a [routerLink]=\u0026#34;[\u0026#39;/tododetail/\u0026#39; + currentTodo.id]\u0026#34; [queryParams]=\u0026#34;{showbackto: 1}\u0026#34;\u0026gt; Edit \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;!currentTodo\u0026#34;\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;p\u0026gt;請點選 Todo...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Todo 明細編輯畫面 --\u0026gt; \u0026lt;ng-template #editable\u0026gt; \u0026lt;div *ngIf=\u0026#34;currentTodo.id\u0026#34; class=\u0026#34;edit-form\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;Todo\u0026lt;/h4\u0026gt; \u0026lt;form\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;title\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Title\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; id=\u0026#34;title\u0026#34; [(ngModel)]=\u0026#34;currentTodo.title\u0026#34; name=\u0026#34;title\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;description\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Description\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; id=\u0026#34;description\u0026#34; [(ngModel)]=\u0026#34;currentTodo.description\u0026#34; name=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label\u0026gt;\u0026lt;strong\u0026gt;Status:\u0026lt;/strong\u0026gt;\u0026lt;/label\u0026gt; {{ currentTodo.status ? \u0026#34;Done\u0026#34; : \u0026#34;Pending\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;!-- 將狀態更新成 Pending --\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; *ngIf=\u0026#34;currentTodo.status\u0026#34; (click)=\u0026#34;updateStatus(false)\u0026#34;\u0026gt; Pending \u0026lt;/button\u0026gt; \u0026lt;!-- 將狀態更新成 `完成` --\u0026gt; \u0026lt;button *ngIf=\u0026#34;!currentTodo.status\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; (click)=\u0026#34;updateStatus(true)\u0026#34;\u0026gt; Done \u0026lt;/button\u0026gt; \u0026lt;!-- 刪除 Todo --\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; (click)=\u0026#34;deleteTodo()\u0026#34;\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;!-- 更新明細內容 --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-warning\u0026#34; (click)=\u0026#34;updateTodo()\u0026#34;\u0026gt; Update \u0026lt;/button\u0026gt; \u0026lt;button *ngIf=\u0026#34;showBackto == 1\u0026#34; class=\u0026#34;btn btn-primary float-end\u0026#34; (click)=\u0026#34;backtoTodo()\u0026#34;\u0026gt; Back \u0026lt;/button\u0026gt; \u0026lt;!-- 顯示操作後訊息 --\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;!currentTodo.id\u0026#34;\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;p\u0026gt;Cannot access this Todo...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/ng-template\u0026gt; /* todo-detail.component.scss */ .edit-form { max-width: 400px; margin: auto; } 執行 Todo 功能測試 新增 Todo Item 新增 Todo 的功能畫面\n輸入資料後按下 Enter\n自動跳到 Todo 維護功能中\n資料檢核，若資料欄位未輸入時送出前會有警語出現\nTodo 資料維護  Title 欄位的關鍵字查詢 Todo 清單顯示區，可透過滑鼠點選來顯示詳細資料（顯示在 3. Todo 詳細區） Todo 詳細區，除顯示Todo 詳細欄位資訊外，也提供了維護的相關按鈕，如：Done/Pending 按鈕是用來切換狀態欄資料、Delete 按鈕用來刪除現行的這筆 Todo、Update按鈕則是更新資料用。 ｀刪除所有｀按鈕會清除所有 Todo Item  Custom Directive 在前述的程式中，我們在不同角色使用登入時會自動控制畫面上方的功能列，只有具有Admin角色的使用者登入時才會出現。若這個需求也出現在 Todo 維護功能中，譬如： 刪除所有 以及 Delete 兩個功能，也希望只有具有Admin角色的使用者才能操作。\n控制新增功能的程式碼是在 app.component.ts 以及 app.component.html 中 很顯然的必須把這些程式碼複制貼上到 TodoList 及 TodoDetail 二個元件中。當然我們會思考如何避免程式重覆及程式公用的問題。上述的需求可利用 Angular Directive 的功能來完美解決。\n首先一樣先透過 ng Cli 來建立程式框架\n$ ng g d shared/directive/if 再打開 if.directive.ts 輸入以下程式碼：\nimport { Directive, TemplateRef, ViewContainerRef } from \u0026#39;@angular/core\u0026#39;; import { TokenStorageService } from \u0026#39;../services/token-storage.service\u0026#39;; @Directive({ selector: \u0026#39;[csdIf]\u0026#39; }) export class IfDirective { private roles: string[] = []; //使用者具備的角色  constructor(private templateRef: TemplateRef\u0026lt;unknown\u0026gt;, private vcr: ViewContainerRef, private tokenStorageService: TokenStorageService) { } ngOnInit(): void { this.displayTemplate(); } private displayTemplate() { this.vcr.clear(); const user = this.tokenStorageService.getUser(); this.roles = user.roles; if (this.roles.includes(\u0026#34;ADMIN\u0026#34;)) { this.vcr.createEmbeddedView(this.templateRef); } else { this.vcr.clear(); } } } 將這個 自定的 Directive 宣告在 app.module.ts 中 完成後，分別\n 將 app.components.ts 原來的程式碼移除 將 app.component.html 中的 *ngIf=\u0026quot;showAdminFunction\u0026quot; 改成 *csdIf 將 todo-list.component.html 中的刪除所有 button 加入 *csdIf　屬性 將 todo-list.component.html 中的Delete button 加入 *csdIf　屬性  修改完成後，再執行一次，發現在三個要被控制的地方都已順利的被控制完成了。同時程式也變得更加簡潔了。\n","permalink":"https://calvinegs.github.io/posts/angular-webapi-crud/","summary":"github Source code\n本文主要的主題是要呈現如何完成具有 \u0026ldquo;新增、修改、刪除、查詢“ Todo List 功能的 Angular Application。同時搭配使用者角色/權限控管來呈現不同 UI 功能。\n在最後的章節會介紹到如何使用 Angular Directive 來簡化程式避免程式碼重覆。\n為完整性考量，還是記錄如何一步步從無到有使用 Angular 14 相關功能來建立一個使用者資料註冊、登入的表單功能（連結到後端 node+MySQL Web API )，在這些表單中按下送出時會自動檢核使用者所輸入的資料是否合乎程式中所設定的檢核邏輯，並顯示合適的訊息反應給使用者。其中將會使用到下列技術:\n Angular CLI 14 Bootstrap 5 (UI Framework) Angular  Reactive Form Custome Validator Interceptor JWT Session Storage Router Services Guard \u0026amp; Router Data RxJs Custome Directive     註1: 若你已經查閱過 使用 Angular 14 建立 Reactive Form 表單驗證範例 這篇筆記了，那可以直接跳到 \u0026ldquo;完成 Todo 相關 Component 的功能\u0026rdquo; 這個章節。","title":"Angular 14 範例: 透過 Web API 完成 CRUD 的應用程式"},{"content":"github Source code\nTechnology:\n NodeJs 17.6.0 Express 4.18.1 cors 2.8.5 crypto-js 4.1.1 # 加解密套件 jsonwebtoken 8.5.1 # Json Web Token 的功能套件 sequelize 6.20.2 # ORM 套件 mysql2 2.3.3 # MySQL client for Node.js MariaDB 10.8.3 # 使用的資料庫  專案完成後的檔案結構 ./專案目錄 ├── app/ │ ├── config/ │ │ └── db.config.js │ ├── middleware/ │ │ ├── auth.jwt.js │ │ ├── index.js │ │ └── verify.signup.js │ ├── models/ │ │ ├── index.js │ │ ├── role.model.js │ │ ├── todo.model.js │ │ └── user.model.js │ ├── routes/ │ │ ├── auth.routes.js │ │ ├── todo.routes.js │ │ └── user.routes.js │ └── services/ │ ├── auth.service.js │ ├── todo.service.js │ └── user.service.js ├── node_modules/ ├── .env ├── .gitignore ├── package.json ├── README.md ├── server.js └── yarn-lock 專案完成後所提供的 API 端點    Methods Urls Actions     POST /api/auth/signup 註冊新使用者帳號   POST /api/auth/signin 使用者帳號登入   GET /api/todos get all Todos   GET /api/todos/:id get Todo by id   GET /api/todos/done find all done Todos   GET /api/todos/title=[keyword] find all Todos whick title contains keyword   POST /api/todos add New Todo   PUT /api/todos/:id update Todo by id   DELETE /api/todos/:id remove Todo by id   DELETE /api/todos remove all Todos    設置專案環境 這個專案不會從頭從無到有紀錄每一個建置的步驟，而是採取套用 \u0026ldquo;使用 Node.js + express + MySQL 建立一個後端服務 REST API\u0026rdquo; 這篇筆記內容來修改成為使用 Mariadb 資料庫而完成。\n複製即有專案 首先 git clone 即有的 MySQL 專案\n$ git clone https://github.com/calvinegs/nodejs-webapi-jwt-mysql.git nodejs-webapi-jwt-mariadb $ cd nodejs-webapi-jwt-mariadb clone 成功後，再來調整相依的套件。調整前先回復原專案所使用的套件\n$ yarn install yarn install v1.22.19 info No lockfile found. [1/4] Resolving packages... [2/4] Fetching packages... [3/4] Linking dependencies... [4/4] Building fresh packages... success Saved lockfile. Done in 4.92s. 在 \u0026ldquo;使用 Node.js + express + MySQL 建立一個後端服務 REST API\u0026rdquo; 這專案裡採用了 ORM 的套件來存取資料庫，使用 ORM 工具層的好處是它是一個抽象層，不直接使用 SQL 來，當後端資料庫轉換時，只要搭配不用的 Driver 便可完成，完全不須修改相關程式。\n移除 mysql driver 套件 $ yarn remove mysql2 yarn remove v1.22.19 [1/2] Removing module mysql2... [2/2] Regenerating lockfile and installing missing dependencies... success Uninstalled packages. Done in 0.49s. 安裝 mariadb driver 套件 $ yarn add mariadb arn add v1.22.19 [1/4] Resolving packages... [2/4] Fetching packages... [3/4] Linking dependencies... [4/4] Building fresh packages... success Saved lockfile. success Saved 7 new dependencies. info Direct dependencies └─ mariadb@3.0.0 info All dependencies ├─ @alloc/quick-lru@5.2.0 ├─ @types/geojson@7946.0.8 ├─ @types/node@17.0.45 ├─ denque@2.0.1 ├─ mariadb@3.0.0 ├─ please-upgrade-node@3.2.0 └─ semver-compare@1.0.0 Done in 2.45s. 修改完成後的 package.json 預設的內容\n{ \u0026quot;name\u0026quot;: \u0026quot;nodejs-webapi-jwt-mariadb\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Node.js + express + JWT + MariaDB\u0026quot;, \u0026quot;main\u0026quot;: \u0026quot;server.js\u0026quot;, \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;nodemon server.js\u0026quot; }, \u0026quot;keywords\u0026quot;: [ \u0026quot;node.js\u0026quot;, \u0026quot;express\u0026quot;, \u0026quot;jwt\u0026quot;, \u0026quot;mysql\u0026quot; ], \u0026quot;author\u0026quot;: \u0026quot;calvin\u0026quot;, \u0026quot;license\u0026quot;: \u0026quot;ISC\u0026quot;, \u0026quot;dependencies\u0026quot;: { \u0026quot;cors\u0026quot;: \u0026quot;^2.8.5\u0026quot;, \u0026quot;crypto-js\u0026quot;: \u0026quot;^4.1.1\u0026quot;, \u0026quot;dotenv\u0026quot;: \u0026quot;^16.0.1\u0026quot;, \u0026quot;express\u0026quot;: \u0026quot;^4.18.1\u0026quot;, \u0026quot;jsonwebtoken\u0026quot;: \u0026quot;^8.5.1\u0026quot;, \u0026quot;mariadb\u0026quot;: \u0026quot;^3.0.0\u0026quot;, \u0026quot;sequelize\u0026quot;: \u0026quot;^6.21.2\u0026quot; }, \u0026quot;devDependencies\u0026quot;: { \u0026quot;nodemon\u0026quot;: \u0026quot;^2.0.18\u0026quot; } } 修改程式 調整資料庫連結資料 修改 app/config/db.config.js\nmodule.exports = { HOST: \u0026#34;localhost\u0026#34;, USER: \u0026#34;root\u0026#34;, PASSWORD: \u0026#34;mariadb@12345\u0026#34;, DB: \u0026#34;testdb\u0026#34;, dialect: \u0026#34;mariadb\u0026#34;, pool: { max: 5, min: 0, acquire: 3000, idle: 10000 } } 調整 Server.js 將原本被註解掉的 “資料庫初始化程式碼”打開，以便初次執行前程式可以自動建立相關資料表(Tables)\nconst express = require(\u0026quot;express\u0026quot;); const dotenv = require(\u0026quot;dotenv\u0026quot;); const cors = require(\u0026quot;cors\u0026quot;); dotenv.config(); const app = express(); const corsOptions = { origin: \u0026quot;http://localhost:4200\u0026quot; }; app.use(cors(corsOptions)); // const { Sequelize } = require('sequelize'); // const sequelize = new Sequelize('testdb', 'root', 'mysql@12345', { // host: 'localhost', // dialect: 'mysql' // }); // try { // sequelize.authenticate(); // console.log('Connection has been established successfully.'); // } catch (error) { // console.error('Unable to connect to the database:', error); // } // app.get(\u0026quot;/api/test\u0026quot;, (req, res) =\u0026gt; { // console.log(\u0026quot;test is successful\u0026quot;); // res.send(\u0026quot;test is successful\u0026quot;); // }); const db = require(\u0026quot;./app/models\u0026quot;); const Role = db.role; db.sequelize.sync({ force: true }).then(() =\u0026gt; { console.log('Drop and Resync Database with { force: true }'); initial(); }).catch((err) =\u0026gt; { console.log(err); }); app.use(express.json()); const userRoute = require(\u0026quot;./app/routes/user.routes\u0026quot;); app.use(\u0026quot;/api/users\u0026quot;, userRoute); const todoRoute = require(\u0026quot;./app/routes/todo.routes\u0026quot;); app.use(\u0026quot;/api/todos\u0026quot;, todoRoute); const authRoute = require(\u0026quot;./app/routes/auth.routes\u0026quot;); app.use(\u0026quot;/api/auth\u0026quot;, authRoute); const PORT = process.env.PORT || 5000; app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); }); // 為 roles table 新增二筆初始資料 function initial() { Role.create({ id: 1, name: \u0026quot;user\u0026quot; }); Role.create({ id: 2, name: \u0026quot;admin\u0026quot; }); } 開始執行程式 安裝 MariaDB 資料庫 程式執行前要備妥 MariaDB 資料庫，為方便起見，採用 docker 方式來執行 MariaDB 資料管理系統，詳細內容可參考 使用 Docker 執行 Mariadb  這篇筆紀。\n執行程式 MariaDB Docker 啟動成功後就可以開始執行程式\n$ npm start 使用 DBeaver 查看資料庫 使用 DBeaver 連結到 MariaDB 後，發現透過程式已成功的産生相關的 Tables (資料表)。\n使用 Postman 操作 Web API 註冊一個使用者帳號\n使用註冊成功的帳號登入系統，登入成功後會回傳一個 Token\n帶入 token 就可成功的新增一個 todo\n結語 至此你可看到只須少許的程式調整就已完成抽換後端資料庫的動作。在程式中所採用 ORM 套件是 Sequelize，它只要搭配不同的 dirver 便可支援 Postgres、MySQL、MariaDb、SQLite、MS SQL Server 等不同的關連式資料庫管理系統。（Sequelize 詳細資訊請參考　Sequelize Getting Started  ）\n","permalink":"https://calvinegs.github.io/posts/nodejs-restapi-mariadb/","summary":"github Source code\nTechnology:\n NodeJs 17.6.0 Express 4.18.1 cors 2.8.5 crypto-js 4.1.1 # 加解密套件 jsonwebtoken 8.5.1 # Json Web Token 的功能套件 sequelize 6.20.2 # ORM 套件 mysql2 2.3.3 # MySQL client for Node.js MariaDB 10.8.3 # 使用的資料庫  專案完成後的檔案結構 ./專案目錄 ├── app/ │ ├── config/ │ │ └── db.config.js │ ├── middleware/ │ │ ├── auth.jwt.js │ │ ├── index.js │ │ └── verify.signup.js │ ├── models/ │ │ ├── index.","title":"使用 Node.js + express + MariaDB 建立一個後端服務 REST API"},{"content":"使用 Docker 執行 Mariadb 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 Mariadb。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.17 API version: 1.41 Go version: go1.17.11 Git commit: 100c701 Built: Mon Jun 6 23:02:57 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.17 API version: 1.41 (minimum version 1.12) Go version: go1.17.11 Git commit: a89b842 Built: Mon Jun 6 23:01:03 2022 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.6 GitCommit: 10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1 runc: Version: 1.1.2 GitCommit: v1.1.2-0-ga916309 docker-init: Version: 0.19.0 GitCommit: de40ad0 檢查是否已安裝了 docker compose $ docker compose version Docker Compose version v2.6.0 使用 docker run 來執行 Mariadb 10.8.3 參數說明： \u0026ndash;name: docker name \u0026ndash;rm: 停止時移除 container -v: 將 container 中的 Mariadb 資料映射到 local 端的目錄(/tmp/mariadb)中 -e: 環境變數設定, MARIADB_ROOT_PASSWORD 指的是 root 帳號的密碼，MARIADB_DATABASE 指的是資料庫名稱 -p: Port number\n$ docker run --name mdb --rm \\ -v /tmp/mariadb:/var/lib/mysql \\ -e MARIADB_ROOT_PASSWORD=Password123! \\ -e MARIADB_DATABASE=testing \\ -p 3306:3306 \\ -it mariadb:10.8.3 $ docker exec -it mdb mariadb --user root -pPassword123! Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 3 Server version: 10.8.3-MariaDB-1:10.8.3+maria~jammy mariadb.org binary distribution Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. MariaDB [(none)]\u0026gt; # 建立一個資料庫 MariaDB [(none)]\u0026gt; CREATE DATABASE mariadb_is_awesome; Query OK, 1 row affected (0.001 sec) MariaDB [(none)]\u0026gt; 查看 docker 執行的情況 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f42da79c0a72 mariadb:10.8.3 \u0026#34;docker-entrypoint.s…\u0026#34; About a minute ago Up About a minute 0.0.0.0:3306-\u0026gt;3306/tcp, :::3306-\u0026gt;3306/tcp mdb 查看 local Mariadb 資料庫目錄 (/tmp/mariadb) $ lm /tmp/mariadb/ 總用量 139276 drwxr-xr-x 7 systemd-coredump systemd-coredump 4096 七 7 18:04 . drwxrwxrwt 27 root root 12288 七 7 18:06 .. -rw-rw---- 1 systemd-coredump systemd-coredump 16719872 七 7 18:03 aria_log.00000001 -rw-rw---- 1 systemd-coredump systemd-coredump 52 七 7 18:03 aria_log_control -rw-rw---- 1 systemd-coredump systemd-coredump 9 七 7 18:03 ddl_recovery.log -rw-rw---- 1 systemd-coredump systemd-coredump 868 七 7 18:03 ib_buffer_pool -rw-rw---- 1 systemd-coredump systemd-coredump 12582912 七 7 18:03 ibdata1 -rw-rw---- 1 systemd-coredump systemd-coredump 100663296 七 7 18:06 ib_logfile0 -rw-rw---- 1 systemd-coredump systemd-coredump 12582912 七 7 18:03 ibtmp1 drwx------ 2 systemd-coredump systemd-coredump 4096 七 7 18:04 mariadb_is_awesome -rw-rw---- 1 systemd-coredump systemd-coredump 0 七 7 18:03 multi-master.info drwx------ 2 systemd-coredump systemd-coredump 4096 七 7 18:03 mysql -rw-r--r-- 1 systemd-coredump systemd-coredump 14 七 7 18:03 mysql_upgrade_info drwx------ 2 systemd-coredump systemd-coredump 4096 七 7 18:03 performance_schema drwx------ 2 systemd-coredump systemd-coredump 12288 七 7 18:03 sys drwx------ 2 systemd-coredump systemd-coredump 4096 七 7 18:03 testing 使用 dbeaver-cd 連結到 Mariadb 開啟 dbeaver-cd 程式，按下 ｀New Database Connection` 按鈕\n開始設置連線資料設定，選擇資料庫 - Mariadb 按下 ｀Next`\n輸入相關資訊，如 Database name、Username、Password\u0026hellip;等，按下｀Test Connectiono\u0026hellip;｀來測試設定是否成功。\n設定無誤會顯示 ｀已連結的訊息視窗｀。按下｀OK｀回到設置畫面，再按下 \u0026ldquo;Finish\u0026rdquo; 即可進入 DBeaver 資料庫管理功能中。\n使用 docker compose 來執行 Mariadb （10.8.3） 建置專案目錄結構 $ mkdir mariadb \u0026amp;\u0026amp; cd mariadb $ touch docker-compose.yml README.md $ mkdir sql $ touch ./sql/init.sql ./mariadb ├── docker-compose.yml ├── README.md └── sql └── init.sql 建立 docker-compose.yml 在這個 compse command file 中一個 services: db，用來下載並啟動 Mariadb。指令與說明如下\nversion: \u0026#39;3.8\u0026#39; services: db: container_name: maria_db  # container name image: mariadb:10.8.3  # image name cap_add: # 將　cap_add　設定為 SYS_NICE會抑制一些無用的錯誤消息 - SYS_NICE restart: always # 當發生系統錯誤時永遠都會重啟 environment: - MARIADB_DATABASE=testdb  # 預設資料庫名稱 - MARIADB_ROOT_PASSWORD=mariadb@12345 # root 密碼 ports: - \u0026#39;3306:3306\u0026#39; volumes: - /tmp/mariadb:/var/lib/mariadb # 將 local /tmp/mariadb 映射成 Mariadb 實際資料庫檔案 #- db:/var/lib/mariadb # 若以此語法將可搭配下面 volumes 的額外參數來指定實際資料庫檔案存放的位置，預設是 /var/lib/docker/volumes/mariadb/_data - ./sql:/docker-entrypoint-initdb.d # 在 local 目錄中可置入相關的 sql 檔案 到initdb.d 目錄下來進行資料庫資料 initial 的動作。 #volumes: # db: # driver: local 透過 init.sql 來建立一個 Table 在 init.sql 檔案中輸入以下 SQL 語法。這個檔案的內容會在 docker 啟動成功後被執行。\nuse testdb; CREATE TABLE IF NOT EXISTS tasks ( task_id INT AUTO_INCREMENT PRIMARY KEY, title VARCHAR(255) NOT NULL, start_date DATE, due_date DATE, status TINYINT NOT NULL, priority TINYINT NOT NULL, description TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ) ENGINE=INNODB; 執行 docker compose 上述的目錄與檔案內容準備完成後，在與 docker-compose.yml 的相同目錄中執行 docker compose up -d來啟動 db Services，啟動成功後，在 terminal 使用 ｀$ docker ps｀ 指令查看容器啟動狀況\n$ docker compose up -d [+] Running 2/2 ⠿ Network mariadb_default Created 0.0s ⠿ Container maria_db Started 0.5s 查看 docker 執行的情況 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1db21d9e4eab mariadb:10.8.3 \u0026#34;docker-entrypoint.s…\u0026#34; 2 minutes ago Up 2 minutes 0.0.0.0:3306-\u0026gt;3306/tcp, :::3306-\u0026gt;3306/tcp maria_db e 使用 dbeaver-cd 連結到 Mariadb DB 設置連線資料設定後開始資料庫會發現已自動新建立一個 task 的 Table了。\n資料庫的實際檔案存放在 Local 的 /tmp/mariadb 目錄中 使用作業系統管理者權限來查看此目錄\n$ ls -al /tmp/mariadb/ 總用量 139272 drwxr-xr-x 6 systemd-coredump systemd-coredump 4096 七 7 18:26 . drwxrwxrwt 27 root root 12288 七 7 18:31 .. -rw-rw---- 1 systemd-coredump systemd-coredump 16719872 七 7 18:26 aria_log.00000001 -rw-rw---- 1 systemd-coredump systemd-coredump 52 七 7 18:26 aria_log_control -rw-rw---- 1 systemd-coredump systemd-coredump 9 七 7 18:26 ddl_recovery.log -rw-rw---- 1 systemd-coredump systemd-coredump 884 七 7 18:26 ib_buffer_pool -rw-rw---- 1 systemd-coredump systemd-coredump 12582912 七 7 18:26 ibdata1 -rw-rw---- 1 systemd-coredump systemd-coredump 100663296 七 7 18:28 ib_logfile0 -rw-rw---- 1 systemd-coredump systemd-coredump 12582912 七 7 18:26 ibtmp1 -rw-rw---- 1 systemd-coredump systemd-coredump 0 七 7 18:26 multi-master.info drwx------ 2 systemd-coredump systemd-coredump 4096 七 7 18:26 mysql -rw-r--r-- 1 systemd-coredump systemd-coredump 14 七 7 18:26 mysql_upgrade_info drwx------ 2 systemd-coredump systemd-coredump 4096 七 7 18:26 performance_schema drwx------ 2 systemd-coredump systemd-coredump 12288 七 7 18:26 sys drwx------ 2 systemd-coredump systemd-coredump 4096 七 7 18:26 testdb 停止 Docker 關閉資料庫 $ docker compose down [+] Running 2/2 ⠿ Container maria_db Removed 0.5s ⠿ Network mariadb_default Removed 0.2s $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ","permalink":"https://calvinegs.github.io/posts/docker-mariadb/","summary":"使用 Docker 執行 Mariadb 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 Mariadb。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.17 API version: 1.41 Go version: go1.17.11 Git commit: 100c701 Built: Mon Jun 6 23:02:57 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.17 API version: 1.41 (minimum version 1.12) Go version: go1.17.11 Git commit: a89b842 Built: Mon Jun 6 23:01:03 2022 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.","title":"使用 Docker 執行 Mariadb"},{"content":"github Source code\nTechnology:\n NodeJs 17.6.0 Express 4.18.1 cors 2.8.5 crypto-js 4.1.1 # 加解密套件 jsonwebtoken 8.5.1 # Json Web Token 的功能套件 sequelize 6.20.2 # ORM 套件 mysql2 2.3.3 # MySQL client for Node.js MySQL 8.0 # 使用的資料庫  專案完成後的檔案結構 ./專案目錄 ├── app/ │ ├── config/ │ │ └── db.config.js │ ├── middleware/ │ │ ├── auth.jwt.js │ │ ├── index.js │ │ └── verify.signup.js │ ├── models/ │ │ ├── index.js │ │ ├── role.model.js │ │ ├── todo.model.js │ │ └── user.model.js │ ├── routes/ │ │ ├── auth.routes.js │ │ ├── todo.routes.js │ │ └── user.routes.js │ └── services/ │ ├── auth.service.js │ ├── todo.service.js │ └── user.service.js ├── node_modules/ ├── .env ├── .gitignore ├── package.json ├── README.md ├── server.js └── yarn-lock 專案完成後所提供的 API 端點    Methods Urls Actions     POST /api/auth/signup 註冊新使用者帳號   POST /api/auth/signin 使用者帳號登入   GET /api/todos get all Todos   GET /api/todos/:id get Todo by id   GET /api/todos/done find all done Todos   GET /api/todos/title=[keyword] find all Todos whick title contains keyword   POST /api/todos add New Todo   PUT /api/todos/:id update Todo by id   DELETE /api/todos/:id remove Todo by id   DELETE /api/todos remove all Todos    設置專案環境 $ node --version # 檢測環境已裝妥 node.js (若已安裝會顯示目前安裝的版本） v17.6.0 $ mkdir nodejs-webapi-jwt-mysql \u0026amp;\u0026amp; cd nodejs-webapi-jwt-mysql ＃ 建立一個專案目錄 $ npm init\t＃ 産生一專案設定檔 package.json $ touch server.js\t＃ 産生一個新檔案 package.json 預設的內容\n{ \u0026#34;name\u0026#34;: \u0026#34;nodejs-webapi-jwt-mysql\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Node.js + express + JWT + MySQL\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;server.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;keywords\u0026#34;: [ \u0026#34;node.js\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;jwt\u0026#34;, \u0026#34;mysql\u0026#34; ], \u0026#34;author\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } 安裝相依套件 $ yarn add express dotenv sequelize mysql2 # 加入相依套件 $ yarn add --dev nodemon # 加入開發時期相依套件 $ yarn add crypto-js jsonwebtoken # 使用者密碼加解密 / Json Web Token $ yarn add cors # 可跨網域提供 Webapi service 建立 git 初始版本\n$ git init $ echo 'node_modules/' \u0026gt; .gitignore # 新增 git ignore 設定檔，並設定 node_modules/ 目錄不加入版控 $ echo 'yarn.lock' \u0026gt;\u0026gt; .gitignore $ git add . \u0026amp;\u0026amp; git commit -m \u0026quot;Initial commit\u0026quot; 建立 git 初始版本的資訊 開啟 VSCode\n$ code . 設定專案啟動指令（如第七行的指令設定），當輸入 npm start 時系統自動以 node 來執行 server.js 程式，並即時監測 server.js 檔案有變化存檔時馬上重新啟動 node server.js 來執行該程式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  { \u0026#34;name\u0026#34;: \u0026#34;nodejs-webapi-jwt-mysql\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Node.js + exporess + JWT + MySQL\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;server.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;nodemon server.js\u0026#34;  }, \u0026#34;keywords\u0026#34;: [ \u0026#34;node.js\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;jwt\u0026#34;, \u0026#34;mysql\u0026#34; ], \u0026#34;author\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;dotenv\u0026#34;: \u0026#34;^16.0.1\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;^4.18.1\u0026#34;, \u0026#34;pg\u0026#34;: \u0026#34;^8.7.3\u0026#34;, \u0026#34;pg-hstore\u0026#34;: \u0026#34;^2.3.4\u0026#34;, \u0026#34;sequelize\u0026#34;: \u0026#34;^6.20.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;nodemon\u0026#34;: \u0026#34;^2.0.16\u0026#34; } }    在 server.js 中加入此行程式，並在 vscode Terminal 中輸入 npm start\n console.log(\u0026#34;Hi NodeJS...\u0026#34;)\t 顯示結果如下\n \u0026gt; nodejs-webapi-jwt-mysql@1.0.0 start \u0026gt; nodemon server.js [nodemon] 2.0.18 [nodemon] to restart at any time, enter `rs` [nodemon] watching path(s): *.* [nodemon] watching extensions: js,mjs,json [nodemon] starting `node server.js` Hi NodeJS... [nodemon] clean exit - waiting for changes before restart 建立一個 Express 應用程式  使用以下程式覆蓋 server.js 檔案\n const express = require(\u0026#34;express\u0026#34;); const app = express(); app.get(\u0026#39;/\u0026#39;, function (req, res) { res.send(\u0026#39;Hello World\u0026#39;) }); app.get(\u0026#34;/api/test\u0026#34;, (req, res) =\u0026gt; { console.log(\u0026#34;test is successful\u0026#34;); res.send(\u0026#34;test is successful\u0026#34;); }); const PORT = process.env.PORT || 5000; app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); })  存檔後，開啟 瀏覽器，輸入 localhost:5000/api/test，在 vscode terminal 視窗中會顯示：\n Backend server is running on port 5000 test is successful 使用 Node.js 連結 MySQL 若你還沒有安裝 MySQL 可以參考這筆記先將資料庫管理系統備妥 使用 Docker 執行 MySQL\n在程式中使用了 sequelize 這個套件的功能來連結 mysql 資料庫，直接透過 Sequelize constructor 來給定連結資料庫的參數，包含 “資料庫名稱“、”User Id\u0026quot;、\u0026ldquo;Password\u0026rdquo;、“Host Name\u0026quot;、\u0026ldquo;資料庫類別“(dialect)等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const express = require(\u0026#34;express\u0026#34;); const app = express(); const { Sequelize } = require(\u0026#39;sequelize\u0026#39;); const sequelize = new Sequelize(\u0026#39;testdb\u0026#39;, \u0026#39;root\u0026#39;, \u0026#39;mysql@12345\u0026#39;, { host: \u0026#39;localhost\u0026#39;, dialect: \u0026#39;mysql\u0026#39; }); try { sequelize.authenticate(); console.log(\u0026#39;Connection has been established successfully.\u0026#39;); } catch (error) { console.error(\u0026#39;Unable to connect to the database:\u0026#39;, error); } app.get(\u0026#34;/api/test\u0026#34;, (req, res) =\u0026gt; { console.log(\u0026#34;test is successful\u0026#34;); res.send(\u0026#34;test is successful\u0026#34;); }); const PORT = process.env.PORT || 5000; app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); })    存檔後，在 vscode terminal 視窗中會顯示：\n Connection has been established successfully. Backend server is running on port 5000  表示連結成功。\n 專案目錄 接下來要陸續完成相關程式，為使程式架構更顯清晰，專案目錄規劃如下：\n./專案目錄 ├── app/ # 程式目錄 │ ├── config/ # 設置連結 MySQL 資料庫的參數 │ ├── middleware/ │ ├── models/ │ ├── routes/ │ └── services/ # 業務邏輯 ├── node_modules/ ├── .env # 程式中的相關“設定值” ├── .gitignore ├── package.json ├── README.md ├── server.js # 主程式 └── yarn.loc 彈性管理參數值 管理程式中的“資料庫連結設定值” 在 app/config/目錄中新增一支 db.config.js 程式內容如下：\nmodule.exports = { HOST: \u0026#34;localhost\u0026#34;, // Host Name  USER: \u0026#34;mysql\u0026#34;, // User Name  PASSWORD: \u0026#34;12345\u0026#34;, // Password  DB: \u0026#34;testdb\u0026#34;, // Database Name  dialect: \u0026#34;mysql\u0026#34;, // 資料庫類別  pool: { max: 5, //　連結池中最大的 connection 數  min: 0, acquire: 30000, //　連結 Timeout 時間(毫秒)  idle: 10000 //　連結被釋放的 idle 時間(毫秒)  } }; 管理程式中的“設定值” 使用 dotenv 套件的功能來管理程式中相關的設定值\n 首先在專案根目錄下建立一個名為 \u0026ldquo;.env\u0026rdquo; 的檔案，內容如下：  JWT_SEC=Jason-Web-Token-Secret-key-jaslkdjfhjwkej01kd1954  在程式中先匯入 dotenv 套件(第1行），再“啟動它”(第2行），使用時透過 “process.env.JWT_SEC\u0026rdquo; 語法取得 JWT_SEC 的設定值 第四行程式碼中的 process.env.PORT 為相同的原則可在 .evn 檔案中加入 PORT 的設定值調整  const dotenv = require(\u0026#34;dotenv\u0026#34;); dotenv.config(); // ... const PORT = process.env.PORT || 5000; // port 預設為 5000 ，並可以在 .env 檔案中進行客製化 （如：PORT＝5001） app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); }) 定義 Sequelize 模型 在 app/models/目錄中新增一支 user.model.js 程式內容如下，這個設定資料可搭合 sequelize.sync() 功能自動在 MySQL 資料庫中建立一個名為 users 的資料表(table)，共有三個皆為 string 型態的欄位，分別為 username、email、password。\nmodule.exports = (sequelize, Sequelize) =\u0026gt; { const User = sequelize.define(\u0026#34;users\u0026#34;, { username: { type: Sequelize.STRING }, email: { type: Sequelize.STRING }, password: { type: Sequelize.STRING } }); return User; }; 同時在 initial Sequelize 後，我們不需要編寫 CRUD 函數，Sequelize 支持所有這些函數\n 建立一個新的 user: create(object) 透過 id 找到一個　user: findByPk(id) 透過 email 找到一個　user: findOne({ where: { email: \u0026hellip; } }) 取得所有使用者: findAll() 透過 username 找到符合的　user: findAll({ where: { username: \u0026hellip; } })  在 app/models/目錄中新增一支 role.model.js 程式內容如下\nmodule.exports = (sequelize, Sequelize) =\u0026gt; { const Role = sequelize.define(\u0026#34;roles\u0026#34;, { id: { type: Sequelize.INTEGER, primaryKey: true }, name: { type: Sequelize.STRING } }); return Role; }; 在 app/models/目錄中新增一支 role.model.js 程式內容如下\nmodule.exports = (sequelize, Sequelize) =\u0026gt; { const Role = sequelize.define(\u0026#34;roles\u0026#34;, { id: { type: Sequelize.INTEGER, primaryKey: true }, name: { type: Sequelize.STRING } }); return Role; }; 初始化 Sequelize 在 app/models/目錄中新增一支 index.js 程式內容如下\nconst config = require(\u0026#34;../config/db.config.js\u0026#34;); // 引入資料庫連結設定檔 const Sequelize = require(\u0026#34;sequelize\u0026#34;); const sequelize = new Sequelize( // 由資料庫連結設定檔的設定值來備置 Sequelize  config.DB, config.USER, config.PASSWORD, { host: config.HOST, dialect: config.dialect, operatorsAliases: 0, pool: { max: config.pool.max, min: config.pool.min, acquire: config.pool.acquire, idle: config.pool.idle } } ); const db = {}; db.Sequelize = Sequelize; db.sequelize = sequelize; db.user = require(\u0026#34;../models/user.model.js\u0026#34;)(sequelize, Sequelize); db.role = require(\u0026#34;../models/role.model.js\u0026#34;)(sequelize, Sequelize); // 設定兩資料表的對應關係（多對多，所以會多出一個新的表 user_roles） // 一個使用者可能有多個角色 // 一個角色也可能有多個使用者 db.role.belongsToMany(db.user, { through: \u0026#34;user_roles\u0026#34;, foreignKey: \u0026#34;roleId\u0026#34;, otherKey: \u0026#34;userId\u0026#34; }); db.user.belongsToMany(db.role, { through: \u0026#34;user_roles\u0026#34;, foreignKey: \u0026#34;userId\u0026#34;, otherKey: \u0026#34;roleId\u0026#34; }); db.ROLES = [\u0026#34;user\u0026#34;, \u0026#34;admin\u0026#34;]; module.exports = db; 執行程式産生資料表與資料 在 server.js 主程式中加入以下程式 const db = require(\u0026#34;./app/models\u0026#34;); // 引入 app/models/index.js 匯出的程式碼(即 sequelize model 定義檔) const Role = db.role; // 呼叫 sync function 將會依 model 定義內容産生資料表，force 參數值為 true 將會重建已存在的資料表 db.sequelize.sync({ force: true }).then(() =\u0026gt; { console.log(\u0026#39;Drop and Resync Database with { force: true }\u0026#39;); initial(); // 産生資料表後，呼叫 initial function 為 roles table 新增二筆初始資料 }).catch((err) =\u0026gt; { console.log(err); }); const PORT = process.env.PORT || 5000; // port 預設為 5000 ，並可以在 .env 檔案中進行客製化 （如：PORT＝5001） app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); }) // 為 roles table 新增二筆初始資料 function initial() { Role.create({ id: 1, name: \u0026#34;user\u0026#34; }); Role.create({ id: 2, name: \u0026#34;admin\u0026#34; }); } 執行程式産生資料表 程式執行成功後可以查看資料庫已順利産生四個資料表以及 roles table 中的二筆初始資料\n了解 Node.js 路由 建立 user.routes.js router file 新增 routes 目錄，在此目錄下新增 user.routes.js 檔案\n routes/user.routes.js\n const router = require(\u0026#34;express\u0026#34;).Router(); router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); module.exports = router; 在 server.js 程式中先匯入 \u0026ldquo;./app/routes/user.routes\u0026rdquo; 這個 router 設定檔，再透過 app.use 語法來使用這個 router(第9行)。\n1 2 3 4 5 6 7 8 9 10 11 12 13  const express = require(\u0026#34;express\u0026#34;); const app = express(); const dotenv = require(\u0026#34;dotenv\u0026#34;); const userRoute = require(\u0026#34;./app/routes/user.routes\u0026#34;);  dotenv.config(); app.use(\u0026#34;/api/users\u0026#34;, userRoute);  app.listen(process.env.PORT || 5000, ()=\u0026gt;{ console.log(\u0026#34;Backend server is running...\u0026#34;); });   開啟瀏覧器，輸入 http:5000/api/users/usertest，瀏覧器將呈現成功訊息\nuser test is successfull! 為 routes/user.routes.js 再新增一個 post method\n1 2 3 4 5 6 7 8 9 10 11  const router = require(\u0026#34;express\u0026#34;).Router(); router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); router.post(\u0026#34;/userposttest\u0026#34;, (req, res) =\u0026gt; { const username = req.body.username; res.send(\u0026#34;your username is: \u0026#34; + username) });  module.exports = router;   使用 postman 來測試 post，結果回傳的是 Server Error，原因是 express 預設是不接受 json 格式的資料。\n在 server.js 程式中加入如第一行的設定\n1 2  app.use(express.json()); app.use(\u0026#34;/api/users\u0026#34;, userRoute);   設定完成後就可正常了\n建立 auth.routes.js router file 將使用者資料註冊和資用者帳號驗證的機制獨立在這個 route file 中，讓程式結構更清晰。內容如下：\n1 2 3 4 5 6 7 8 9 10  // routes/auth.routes.js const router = require(\u0026#34;express\u0026#34;).Router(); const authService = require(\u0026#34;../services/auth.service\u0026#34;);  // 帳號註冊 router.post(\u0026#34;/signup\u0026#34;, authService.signup); // 登入 router.post(\u0026#34;/signin\u0026#34;, authService.signin);  module.exports = router;    在 auth.routes.js route 程式中基於｀關注點分離原則｀把｀商業邏輯｀的部份再分離至 services 中。\n  在 ./app 目錄下新增 services 子目錄，並新增一支 auth.service.js 程式，將使用者註冊及登入邏輯放在這支 service 程式中，內容如下：\n  在這支程式中會使用到額外的套件，必須先進行安裝。$ yarn add crypto-js jsonwebtoken。其中 crypto-js 用來進行使用者密碼加解密(程式第2、15、50、51行)，而 jsonwebtoken 套件則是支援 Json Web Token 功能(程式第55行使用 jwt.sign 産生合法 Token)。\n // auth.service.js const db = require(\u0026quot;../models\u0026quot;); const CryptoJS = require(\u0026quot;crypto-js\u0026quot;); const jwt = require(\u0026quot;jsonwebtoken\u0026quot;); const User = db.user; const Role = db.role; const Op = db.Sequelize.Op; const signup = (req, res) =\u0026gt; { // Save User to Database User.create({ username: req.body.username, email: req.body.email, password: CryptoJS.AES.encrypt(req.body.password, process.env.PASS_SEC).toString()， }).then(user =\u0026gt; { if (req.body.roles) { Role.findAll({ where: { name: { [Op.or]: req.body.roles } } }).then(roles =\u0026gt; { user.setRoles(roles).then(() =\u0026gt; { res.send({ message: \u0026quot;User registered successfully!\u0026quot; }); }); }); } else { // user role = 1 user.setRoles([1]).then(() =\u0026gt; { res.send({ message: \u0026quot;User registered successfully!\u0026quot; }); }); } }).catch(err =\u0026gt; { res.status(500).send({ message: err.message }); }); }; const signin = (req, res) =\u0026gt; { User.findOne({ where: { username: req.body.username } }).then(user =\u0026gt; { if (!user) { return res.status(404).send({ message: \u0026quot;Wrong Credentials.\u0026quot; }); } const hashedPassword = CryptoJS.AES.decrypt(user.password, process.env.PASS_SEC); const orginalPassword = hashedPassword.toString(CryptoJS.enc.Utf8); orginalPassword !== req.body.password \u0026amp;\u0026amp; res.status(401).json(\u0026quot;Wrong Credentials\u0026quot;); const accessToken = jwt.sign( {id: user.id}, process.env.JWT_SEC, { expiresIn: \u0026quot;3d\u0026quot; } ); var authorities = []; user.getRoles().then(roles =\u0026gt; { for (let i = 0; i \u0026lt; roles.length; i++) { authorities.push(\u0026quot;ROLE_\u0026quot; + roles[i].name.toUpperCase()); } res.status(200).send({ id: user.id, username: user.username, email: user.email, roles: authorities, accessToken: accessToken }); }); }).catch(err =\u0026gt; { res.status(500).send({ message: err.message }); }); }; module.exports = { signup, signin };  在 server.js 引用這個新的 router\n 1 2 3 4 5 6 7 8 9 10 11 12  // ... const userRoute = require(\u0026#34;./app/routes/user.routes\u0026#34;); const authRoute = require(\u0026#34;./app/routes/auth.routes\u0026#34;); app.use(express.json()); app.use(\u0026#34;/api/users\u0026#34;, userRoute); app.use(\u0026#34;/api/auth\u0026#34;, authRoute);  const PORT = process.env.PORT || 5000; // port 預設為 5000 ，並可以在 .env 檔案中進行客製化 （如：PORT＝5001） app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); })   測試使用者註冊及登入功能 使用 postman 進行使用者註冊功能測試\n 註冊成功後，在資料庫中已新增一筆使用者資料\n 使用 postman 進行使用者登入功能測試\n 登入成功後會回傳一個 Token\n 在 Node.js 中使用 JWT 來進行 Token-Based 的使用者授權驗證 使用 jsonwebtoken套件可以實現 Token-base 的身份驗證與授權讓我們的 API 程式更安全\nJWT 實作的過程大致可以分成三個部分:\n 在登入成功後産生合法的 JWT Token 每次收到 request 時驗證是否為合法有效的 JWT Token 在特定 API Endpoint 上驗證是否帶有 “合法有效的 JWT Token”，以達到權限管理的需求  産生合法 JWT 在登入證驗中加入産生 Token 的邏輯，在檢核使用者輸入的密碼正確後，將 User ID (_id這個內部 Key)這個屬性值透過 sign function 來産生 access token，並回傳給前端。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); // 匯入 JsonWebToken套件 //...  const accessToken = jwt.sign({  id: user._id }, process.env.JWT_SEC,  { expiresIn: \u0026#34;3d\u0026#34; } ); var authorities = []; user.getRoles().then(roles =\u0026gt; { for (let i = 0; i \u0026lt; roles.length; i++) { authorities.push(roles[i].name.toUpperCase()); } res.status(200).send({ id: user.id, username: user.username, email: user.email, roles: authorities, accessToken: accessToken }); });   encrypt function 參數除了要加密的字串外，需要一個加密 Key，為彈性起見，把它寫在 .env 檔案\n1 2  # .env JWT_SEC=Jason-Web-Token-Secret-key-thisisaprivatekey   使用 JWT 來驗證 Token 在前端取得合法的 JWT Token後，來看看當使用者在呼叫其他 API 時一併回傳的 Token　如何在 server 端來進行驗證。\n首先，我們要在 app/ 目錄下新增一個 middleware/ 的子目錄，並在其中新增一個名為 auth.jwt.js 的 express Middleware，程式內容如下\n在程式第14行中使用 jsonwebtoken 套件的 verify function 就是用來驗證 request 中的 Token 是否為合法 Token。驗證時一樣需要｀加密 Key｀來當參數。\n在這程式中除了驗證 request 中是否有合法的 Token 外，還有其他授權檢核的邏輯：驗證是否為管理者、驗證是否為版主、驗證是否為管理者或是版主等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const db = require(\u0026#34;../models\u0026#34;); const User = db.user; const verifyToken = (req, res, next) =\u0026gt; {  let authHeader = req.headers.authorization; if (!authHeader) { return res.status(403).send({ message: \u0026#34;Your are not authenticated!\u0026#34; }); } const token = authHeader.split(\u0026#34; \u0026#34;)[1]; jwt.verify(token, process.env.JWT_SEC, (err, decoded) =\u0026gt; {  if (err) { return res.status(401).send({ message: \u0026#34;Token is not valid!\u0026#34; }); } req.userId = decoded.id; next(); }); }; const isAdmin = (req, res, next) =\u0026gt; {  User.findByPk(req.userId).then(user =\u0026gt; { user.getRoles().then(roles =\u0026gt; { for (let i = 0; i \u0026lt; roles.length; i++) { if (roles[i].name === \u0026#34;admin\u0026#34;) { next(); return; } } res.status(403).send({ message: \u0026#34;Require Admin Role!\u0026#34; }); return; }); }); }; const authJwt = {  verifyToken: verifyToken, isAdmin: isAdmin }; module.exports = authJwt;   為簡化 middleware 使用時的匯入路徑，我們在　middleware/ 的子目錄，再新增一個名為 index.js 的程式，內容如下\nconst authJwt = require(\u0026#34;./auth.jwt\u0026#34;); module.exports = { authJwt }; 在特定 API Endpoint 上驗證是否帶有 “合法有效的 JWT Token” 在前面完成了驗證 Token 的 Middleware 後，我們來看看如何在 router 中套用這些 middleware， 打開　routers/userroutes.js 程式檔，並將內容修改如下：\n在程式第九行 post 的第二個參數，加入呼叫 authJwt.verifyToken 這個 middleware 驗證 token 的 function。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const router = require(\u0026#34;express\u0026#34;).Router(); const { authJwt } = require(\u0026#34;../middleware\u0026#34;);  router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); router.post(\u0026#34;/userposttest\u0026#34;, authJwt.verifyToken,  (req, res) =\u0026gt; { const username = req.body.username; res.send(\u0026#34;your username is: \u0026#34; + username) } ) module.exports = router;   再次執行前面已執行過的 Postman 的 postusertest 這個 request，結果這次會回傳 ｀未授權｀的警告訊息。\n將登入成功時回傳的 token，加入到 Header 中，再執行一次 postusertest 即可執行成功。\n 若送出 request 中未包含 Token 則會回傳“未被授權執行本功能”。\n  若送出 request 中包含的是不合法的 Token 則會回傳“Token不合法“。\n 完成 todo list 相關功能 定義 todo 資料模型 在 app/models/目錄中新增一支 todo.model.js 程式內容如下\nmodule.exports = (sequelize, Sequelize) =\u0026gt; { const Todo = sequelize.define(\u0026#34;todo\u0026#34;, { title: { type: Sequelize.STRING }, description: { type: Sequelize.STRING }, status: { type: Sequelize.BOOLEAN } }); return Todo; }; 修改 app/models/index.js app/models/index.js 中加入 db.todo = require(\u0026quot;../models/todo.model\u0026quot;)(sequelize, Sequelize);\nconst config = require(\u0026quot;../config/db.config\u0026quot;); const Sequelize = require(\u0026quot;sequelize\u0026quot;); const sequelize = new Sequelize( config.DB, config.USER, config.PASSWORD, { host: config.HOST, dialect: config.dialect, operatorsAliases: 0, pool: { max: config.pool.max, min: config.pool.min, acquire: config.pool.acquire, idle: config.pool.idle } } ); const db = {}; db.Sequelize = Sequelize; db.sequelize = sequelize; db.user = require(\u0026quot;../models/user.model\u0026quot;)(sequelize, Sequelize); db.role = require(\u0026quot;../models/role.model\u0026quot;)(sequelize, Sequelize); db.todo = require(\u0026quot;../models/todo.model\u0026quot;)(sequelize, Sequelize); db.role.belongsToMany(db.user, { through: \u0026quot;user_roles\u0026quot;, foreignKey: \u0026quot;roleId\u0026quot;, otherKey: \u0026quot;userId\u0026quot; }); db.user.belongsToMany(db.role, { through: \u0026quot;user_roles\u0026quot;, foreignKey: \u0026quot;userId\u0026quot;, otherKey: \u0026quot;roleId\u0026quot; }); db.ROLES = [\u0026quot;user\u0026quot;, \u0026quot;admin\u0026quot;]; module.exports = db; 新增 todo.service.js 將實際讀寫資料的動作寫在 service 中。\n//./app/services.todo.service.js const db = require(\u0026#34;../models\u0026#34;); const Todo = db.todo; const Op = db.Sequelize.Op; const create = (req, res) =\u0026gt; { if (!req.body.title) { res.status(400).send({ message: \u0026#34;內容不得為空白！\u0026#34; }); return; } // 新增一個 Todo  const todo = { title: req.body.title, description: req.body.description, status: req.body.status ? req.body.status : false } // 將 todo 存入資料庫  Todo.create(todo) .then(data =\u0026gt; { res.send(data); }).catch(err =\u0026gt; { res.status(500).send({ message: err.message || \u0026#34;資料存檔時發生錯誤！\u0026#34; }); }); } const findAll = (req, res) =\u0026gt; { const title = req.query.title; let condition = title ? { title: { [Op.like]: `%${title}%` } } : null; Todo.findAll({ where: condition }) .then(data =\u0026gt; { res.send(data); }) .catch(err =\u0026gt; { res.status(500).send({ message: err.message || \u0026#34;由資料庫讀取 Todo 資料時發生錯誤！\u0026#34; }); }); }; const findOne = (req, res) =\u0026gt; { const id = req.params.id; Todo.findByPk(id) .then(data =\u0026gt; { if (data) { res.send(data) } else { res.status(400).send({ message: `使用id=${id}搜尋時找到不 Todo 資料!` }) } }) .catch(err =\u0026gt; { res.status(500).send({ message: `使用id=${id}搜尋時找到不 Todo 資料!` }); }); }; const update = (req, res) =\u0026gt; { const id = req.params.id; Todo.update(req.body, { where: { id: id } }) .then(num =\u0026gt; { if (num == 1) { res.send({ mdssage: \u0026#34;Todo 更新完成！\u0026#34; }); } else { res.status(500).send({ message: `使用 id= ${id}更新資料時發生錯誤！` }); }; }) }; const deleteOne = (req, res) =\u0026gt; { const id = req.params.id; Todo.destroy({ where: { id: id } }) .then(num =\u0026gt; { if (num === 1) { res.send({ message: \u0026#34;Todo 刪除成功！\u0026#34; }) } else { res.send({ message: `使用 id= ${id}刪除 Todo 時未找到任何資料！` }) }; }) .catch(err =\u0026gt; { res.status(500).send({ message: `使用 id= ${id}刪除 Todo 時發生錯誤！` }) }) }; const deleteAll = (req, res) =\u0026gt; { Todo.destroy({ where: {}, truncat: false }) .then(nums =\u0026gt; { res.send({ message: `${nums}Todo 資料被刪除成功！` }) }) .catch(err =\u0026gt; { res.status(500).send({ message: err.message || \u0026#34;刪除所有資料時發生錯誤！\u0026#34; }) }) }; const findAllDoneTodos = (req, res) =\u0026gt; { Todo.findAll({ where: { status: true } }) .then(data =\u0026gt; { res.send(data); }) .catch(err =\u0026gt; { res.status(500).send({ message: err.message || \u0026#34;讀取資料時發生錯誤！\u0026#34; }) }) }; module.exports = { create, findAll, findOne, update, deleteAll, deleteOne, findAllDoneTodos }; 新增 todo.router.js // ./app/routers/todo.routes.js const router = require(\u0026#34;express\u0026#34;).Router(); const todo = require(\u0026#34;../services/todo.service\u0026#34;); router.post(\u0026#34;/\u0026#34;, todo.create); router.get(\u0026#34;/\u0026#34;, todo.findAll); router.get(\u0026#34;/done\u0026#34;, todo.findAllDoneTodos); router.get(\u0026#34;/:id\u0026#34;, todo.findOne); router.put(\u0026#34;/:id\u0026#34;, todo.update); router.delete(\u0026#34;/:id\u0026#34;, todo.deleteOne); router.delete(\u0026#34;/\u0026#34;, todo.deleteAll); module.exports = router; 將 todo router 加入到 service.js //... app.use(express.json()); const userRoute = require(\u0026#34;./app/routes/user.routes\u0026#34;); app.use(\u0026#34;/api/users\u0026#34;, userRoute); const todoRoute = require(\u0026#34;./app/routes/todo.routes\u0026#34;); app.use(\u0026#34;/api/todos\u0026#34;, todoRoute); const authRoute = require(\u0026#34;./app/routes/auth.routes\u0026#34;); app.use(\u0026#34;/api/auth\u0026#34;, authRoute); const PORT = process.env.PORT || 5000; app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); }); //... 執行測試 新增一筆 Todo 找出所有的 Todos 找出 title 中有含某個 keyword 的所有 Todos 以 ID 找出 Todo 更新某一個 Todo 的 status 欄位 查詢所有已經完成的 Todos 刪除某一個 Todo 刪除所有的 Todos 使用 middleware 來進行檢核使用者角色 將 app/routes/todo.routes.js 內容修改成如下：\n 第五行：create 功能加入 authJwt.verifyToken middleware 檢核，必須是已登入的使用者才能執行 第六行：findall 功能加入 authJwt.verifyToken 以及 authJwt.isAdmin middleware 檢核，必須是已登入的使用者且具有管理者身份才能執行  1 2 3 4 5 6 7 8 9 10 11 12 13  const router = require(\u0026#34;express\u0026#34;).Router(); const todo = require(\u0026#34;../services/todo.service\u0026#34;); const { authJwt } = require(\u0026#34;../middleware\u0026#34;); router.post(\u0026#34;/\u0026#34;, authJwt.verifyToken, todo.create); router.get(\u0026#34;/\u0026#34;, [authJwt.verifyToken, authJwt.isAdmin], todo.findAll); router.get(\u0026#34;/done\u0026#34;, todo.findAllDoneTodos); router.get(\u0026#34;/:id\u0026#34;, todo.findOne); router.put(\u0026#34;/:id\u0026#34;, todo.update); router.delete(\u0026#34;/:id\u0026#34;, todo.deleteOne); router.delete(\u0026#34;/\u0026#34;, todo.deleteAll); module.exports = router;   再次執行 create Todo API endpoint，發現未登入的使用者已無法執行。\n以一般使用者進行登入\n打開 Postman 先使用已註冊的使用者帳號登入，取得 token\n再將這個 token (使表使用者是 tom) 加入 request authorization header 中，再次造再次執行 create Todo API endpoint，結果可正常新建一個 Todo\n再以相同 token (代表使用者是 tom) 造訪 get All Todos API endpoint ，結果回傳 \u0026ldquo;須為管理者角色者\u0026quot;才能造訪。\n註冊一個新使用者且具備有 admin 角色\n改用新註冊的使用者 Jeff 來重新登入，並取得回傳的 token\n改採此 token (代表使用者是 jeff) 再次造訪 get All Todos API endpoint ，結果顯示可正常顯示所有的 Todos。\n使用 middleware 來進行其他資料檢核 程式至此已經可以透過 JWT 相關功能查核使用者是否已正確登入系統、是以何種身份（角色）登入的。\n最後要再呈現的是使用 middleware 功能來查核其他資料正確性，如：使用者註冊時是否使用了相同的使用者名稱？是否 email 已經被其他使用者使用過？\n在 app/middleware 目錄下新增 verify.signup.js，內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  const db = require(\u0026#34;../models\u0026#34;); const ROLES = db.Roles; const User = db.user; checkDuplicateUsernameOrEmail = (req, res, next) =\u0026gt; {  // Username  User.findOne({ where: { username: req.body.username } }).then(user =\u0026gt; { if (user) { res.status(400).send({ message: \u0026#34;Failed! Username is already in use!\u0026#34; }); return; } // Email  User.findOne({ where: { email: req.body.email } }).then(user =\u0026gt; { if (user) { res.status(400).send({ message: \u0026#34;Failed! Email is already in use!\u0026#34; }); return; } next(); }); }); }; checkRolesExisted = (req, res, next) =\u0026gt; {  if (req.body.roles) { for (let i = 0; i \u0026lt; req.body.roles.length; i++) { if (!ROLES.includes(req.body.roles[i])) { res.status(400).send({ message: \u0026#34;Failed! Role does not exist = \u0026#34; + req.body.roles[i] }); return; } } } next(); }; const verifySignUp = { checkDuplicateUsernameOrEmail: checkDuplicateUsernameOrEmail, checkRolesExisted: checkRolesExisted }; module.exports = verifySignUp;   修改 app/middleware/index.js 檔案如下：\n1 2 3 4 5 6 7  const authJwt = require(\u0026#34;./auth.jwt\u0026#34;); const verifySignUp = require(\u0026#34;./verify.signup\u0026#34;);  module.exports = { authJwt, verifySignUp };   將新的 middleware　功能放入到 SignUp 功能中。 打開　app/routes/auth.routes.js 程式檔，修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const router = require(\u0026#34;express\u0026#34;).Router(); const authService = require(\u0026#34;../services/auth.service\u0026#34;); const { verifySignUp } = require(\u0026#34;../middleware\u0026#34;) // 帳號註冊 router.post(\u0026#34;/signup\u0026#34;, [ verifySignUp.checkDuplicateUsernameOrEmail, verifySignUp.checkRolesExisted ], authService.signup); // 登入 router.post(\u0026#34;/signin\u0026#34;, authService.signin); module.exports = router;   先使用已經被註冊過的 EMail來進行測試，結果回傳 EMail 已被使用。\n再使用已被註冊過的 UserName 來進行註冊，結果回傳：\ncors 這個後端專案預計要給前端 Angular 來使用，跨域存取問題就用 cors 設定來解決。\n先安裝 cors 套件\n$ yarn add cors yarn add v1.22.19 [1/4] Resolving packages... [2/4] Fetching packages... [3/4] Linking dependencies... [4/4] Building fresh packages... success Saved lockfile. success Saved 2 new dependencies. info Direct dependencies └─ cors@2.8.5 info All dependencies ├─ cors@2.8.5 └─ object-assign@4.1.1 Done in 0.86s. 打開 server.js，修改如下：\n1 2 3 4 5 6 7 8 9 10 11  const express = require(\u0026#34;express\u0026#34;); const dotenv = require(\u0026#34;dotenv\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); dotenv.config(); const app = express(); const corsOptions = { origin: \u0026#34;http://localhost:4200\u0026#34; }; app.use(cors(corsOptions)); //...   ","permalink":"https://calvinegs.github.io/posts/nodejs-restapi-mysql/","summary":"github Source code\nTechnology:\n NodeJs 17.6.0 Express 4.18.1 cors 2.8.5 crypto-js 4.1.1 # 加解密套件 jsonwebtoken 8.5.1 # Json Web Token 的功能套件 sequelize 6.20.2 # ORM 套件 mysql2 2.3.3 # MySQL client for Node.js MySQL 8.0 # 使用的資料庫  專案完成後的檔案結構 ./專案目錄 ├── app/ │ ├── config/ │ │ └── db.config.js │ ├── middleware/ │ │ ├── auth.jwt.js │ │ ├── index.js │ │ └── verify.signup.js │ ├── models/ │ │ ├── index.","title":"使用 Node.js + express + MySQL 建立一個後端服務 REST API"},{"content":"使用 Docker 執行 MySQL 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 MySQL。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.17 API version: 1.41 Go version: go1.17.11 Git commit: 100c701 Built: Mon Jun 6 23:02:57 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.17 API version: 1.41 (minimum version 1.12) Go version: go1.17.11 Git commit: a89b842 Built: Mon Jun 6 23:01:03 2022 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.6 GitCommit: 10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1 runc: Version: 1.1.2 GitCommit: v1.1.2-0-ga916309 docker-init: Version: 0.19.0 GitCommit: de40ad0 檢查是否已安裝了 docker compose $ docker compose version Docker Compose version v2.6.0 使用 docker run 來執行 MySQL 8.0 參數說明： \u0026ndash;name: docker name \u0026ndash;rm: 停止時移除 container -v: 將 container 中的 MySQL 資料映射到 local 端的目錄(/tmp/mysqldb)中 -e: 環境變數設定, MYSQL_ROOT_PASSWORD 指的是 root 帳號的密碼，MYSQL_DATABASE 指的是資料庫名稱 -p: Port number\n$ mkdir /tmp/mysqldb $ docker run --name mysql-test --rm \\ -v /tmp/mysqldb:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=mysql@12345 \\ -e MYSQL_DATABASE=testing \\ -p 3306:3306 -it mysql:8.0 2022-06-17 04:45:36+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.29-1debian10 started. 2022-06-17 04:45:36+00:00 [Note] [Entrypoint]: Switching to dedicated user \u0026#39;mysql\u0026#39; 2022-06-17 04:45:36+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.29-1debian10 started. 2022-06-17T04:45:37.264452Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.29) starting as process 1 2022-06-17T04:45:37.270146Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2022-06-17T04:45:37.445525Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2022-06-17T04:45:37.644757Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. 2022-06-17T04:45:37.644831Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. 2022-06-17T04:45:37.646485Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location \u0026#39;/var/run/mysqld\u0026#39; in the path is accessible to all OS users. Consider choosing a different directory. 2022-06-17T04:45:37.667321Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: \u0026#39;8.0.29\u0026#39; socket: \u0026#39;/var/run/mysqld/mysqld.sock\u0026#39; port: 3306 MySQL Community Server - GPL. 2022-06-17T04:45:37.667312Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Bind-address: \u0026#39;::\u0026#39; port: 33060, socket: /var/run/mysqld/mysqlx.sock 查看 docker 執行的情況 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 986d25a3e618 mysql:8.0 \u0026#34;docker-entrypoint.s…\u0026#34; 37 seconds ago Up 36 seconds 0.0.0.0:3306-\u0026gt;3306/tcp, :::3306-\u0026gt;3306/tcp, 33060/tcp mysql-tes 查看 local MySQL 資料庫目錄 (/tmp/mysqldb) $ lm /tmp/mysqldb/ 總用量 198088 drwxrwxr-x 7 systemd-coredump egs 4096 六 17 15:45 . drwxrwxrwt 26 root root 12288 六 17 15:45 .. -rw-r----- 1 systemd-coredump systemd-coredump 56 六 17 15:45 auto.cnf -rw-r----- 1 systemd-coredump systemd-coredump 3117132 六 17 15:45 binlog.000001 -rw-r----- 1 systemd-coredump systemd-coredump 157 六 17 15:45 binlog.000002 -rw-r----- 1 systemd-coredump systemd-coredump 32 六 17 15:45 binlog.index -rw------- 1 systemd-coredump systemd-coredump 1680 六 17 15:45 ca-key.pem -rw-r--r-- 1 systemd-coredump systemd-coredump 1112 六 17 15:45 ca.pem -rw-r--r-- 1 systemd-coredump systemd-coredump 1112 六 17 15:45 client-cert.pem -rw------- 1 systemd-coredump systemd-coredump 1680 六 17 15:45 client-key.pem -rw-r----- 1 systemd-coredump systemd-coredump 1382 六 17 15:45 d7ac1e06b7cb.err -rw-r----- 1 systemd-coredump systemd-coredump 196608 六 17 15:45 \u0026#39;#ib_16384_0.dblwr\u0026#39; -rw-r----- 1 systemd-coredump systemd-coredump 8585216 六 17 15:45 \u0026#39;#ib_16384_1.dblwr\u0026#39; -rw-r----- 1 systemd-coredump systemd-coredump 5683 六 17 15:45 ib_buffer_pool -rw-r----- 1 systemd-coredump systemd-coredump 12582912 六 17 15:45 ibdata1 -rw-r----- 1 systemd-coredump systemd-coredump 50331648 六 17 15:45 ib_logfile0 -rw-r----- 1 systemd-coredump systemd-coredump 50331648 六 17 15:45 ib_logfile1 -rw-r----- 1 systemd-coredump systemd-coredump 12582912 六 17 15:45 ibtmp1 drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 15:45 \u0026#39;#innodb_temp\u0026#39; drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 15:45 mysql -rw-r----- 1 systemd-coredump systemd-coredump 31457280 六 17 15:45 mysql.ibd drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 15:45 performance_schema -rw------- 1 systemd-coredump systemd-coredump 1680 六 17 15:45 private_key.pem -rw-r--r-- 1 systemd-coredump systemd-coredump 452 六 17 15:45 public_key.pem -rw-r--r-- 1 systemd-coredump systemd-coredump 1112 六 17 15:45 server-cert.pem -rw------- 1 systemd-coredump systemd-coredump 1676 六 17 15:45 server-key.pem drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 15:45 sys drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 15:45 testing -rw-r----- 1 systemd-coredump systemd-coredump 16777216 六 17 15:45 undo_001 -rw-r----- 1 systemd-coredump systemd-coredump 16777216 六 17 15:45 undo_002 使用 dbeaver-cd 連結到 MySQL 開啟 dbeaver-cd 程式，按下 ｀New Database Connection` 按鈕\n開始設置連線資料設定，選擇資料庫 - MySQL 按下 ｀Next`\n輸入相關資訊，如 Database name、Username、Password\u0026hellip;等，按下｀Test Connectiono\u0026hellip;｀來測試設定是否成功。\n若出現以下錯誤,請回到設置畫面的 \u0026ldquo;Driver properties\u0026rdquo; 頁簽中去修改 \u0026ldquo;allowPublicKeyRetrieval\u0026rdquo; 的值。\n將\u0026quot;allowPublicKeyRetrieval\u0026quot; 的值改成 True。按下 \u0026ldquo;Finish\u0026rdquo;，回到設置主頁面，再按下 Test Connection 測試一次。\n設定無誤會顯示 ｀已連結的訊息視窗｀。按下｀OK｀回到設置畫面，再按下 \u0026ldquo;Finish\u0026rdquo; 即可進入 DBeaver 資料庫管理功能中。\n使用 docker compose 來執行 MySQL 8.0 建置專案目錄結構 $ mkdir mysql \u0026amp;\u0026amp; cd mysql $ touch docker-compose.yml README.md $ mkdir sql $ touch ./sql/initdb.sql ./mysql ├── docker-compose.yml ├── README.md └── sql └── initdb.sql 建立 docker-compose.yml 在這個 compse command file 中一個 services: db，用來下載並啟動 MySQL。指令與說明如下\nversion: \u0026#39;3.8\u0026#39; services: db: container_name: mysql_db  # container name image: mysql:8.0  # image name cap_add: # 將　cap_add　設定為 SYS_NICE會抑制一些無用的錯誤消息 - SYS_NICE restart: always # 當發生系統錯誤時永遠都會重啟 environment: - MYSQL_DATABASE=testdb  # 預設資料庫名稱 - MYSQL_ROOT_PASSWORD=mysql@12345 # root 密碼 ports: - \u0026#39;3306:3306\u0026#39; volumes: - /tmp/mysqldb:/var/lib/mysql # 將 local /tmp/mysqldb 映射成 MySQL 實際資料庫檔案 #- db:/var/lib/mysql # 若以此語法將可搭配下面 volumes 的額外參數來指定實際資料庫檔案存放的位置，預設是 /var/lib/docker/volumes/mysqldb/_data - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql # 在 local 目錄中可置入相關的 sql 到init.sql檔案中來進行資料庫資料 initial 的動作。 #volumes: # db: # driver: local 執行 docker compose 上述的目錄與檔案內容準備完成後，在與 docker-compose.yml 的相同目錄中執行 docker compose up來啟動 db Services，啟動成功後開啟另一個 terminal 使用 ｀$ docker ps｀ 指令查看容器啟動狀況\n$ docker compose up # ... ⠿ Container mysql_db Created 0.0s Attaching to mysql_db mysql_db | 2022-06-17 08:23:58+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.29-1debian10 started. mysql_db | 2022-06-17 08:23:58+00:00 [Note] [Entrypoint]: Switching to dedicated user \u0026#39;mysql\u0026#39; mysql_db | 2022-06-17 08:23:58+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.29-1debian10 started. mysql_db | 2022-06-17 08:23:58+00:00 [Note] [Entrypoint]: Initializing database files mysql_db | 2022-06-17T08:23:58.480385Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.29) initializing of server in progress as process 43 mysql_db | 2022-06-17T08:23:58.486258Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. mysql_db | 2022-06-17T08:23:58.797788Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. mysql_db | 2022-06-17T08:23:59.921507Z 6 [Warning] [MY-010453] [Server] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. mysql_db | 2022-06-17 08:24:01+00:00 [Note] [Entrypoint]: Database files initialized mysql_db | 2022-06-17 08:24:01+00:00 [Note] [Entrypoint]: Starting temporary server mysql_db | 2022-06-17T08:24:02.084039Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.29) starting as process 92 mysql_db | 2022-06-17T08:24:02.107066Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. mysql_db | 2022-06-17T08:24:02.294283Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. mysql_db | 2022-06-17T08:24:02.522288Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. mysql_db | 2022-06-17T08:24:02.522366Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. mysql_db | 2022-06-17T08:24:02.524085Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location \u0026#39;/var/run/mysqld\u0026#39; in the path is accessible to all OS users. Consider choosing a different directory. mysql_db | 2022-06-17T08:24:02.545272Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: \u0026#39;8.0.29\u0026#39; socket: \u0026#39;/var/run/mysqld/mysqld.sock\u0026#39; port: 0 MySQL Community Server - GPL. mysql_db | 2022-06-17T08:24:02.545306Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Socket: /var/run/mysqld/mysqlx.sock mysql_db | 2022-06-17 08:24:02+00:00 [Note] [Entrypoint]: Temporary server started. mysql_db | Warning: Unable to load \u0026#39;/usr/share/zoneinfo/iso3166.tab\u0026#39; as time zone. Skipping it. mysql_db | Warning: Unable to load \u0026#39;/usr/share/zoneinfo/leap-seconds.list\u0026#39; as time zone. Skipping it. mysql_db | Warning: Unable to load \u0026#39;/usr/share/zoneinfo/zone.tab\u0026#39; as time zone. Skipping it. mysql_db | Warning: Unable to load \u0026#39;/usr/share/zoneinfo/zone1970.tab\u0026#39; as time zone. Skipping it. mysql_db | 2022-06-17 08:24:04+00:00 [Note] [Entrypoint]: Creating database testdb mysql_db | mysql_db | 2022-06-17 08:24:04+00:00 [Note] [Entrypoint]: /usr/local/bin/docker-entrypoint.sh: running /docker-entrypoint-initdb.d/init.sql mysql_db | ERROR: Can\u0026#39;t initialize batch_readline - may be the input source is a directory or a block device. mysql_db exited with code 1 mysql_db | 2022-06-17 08:24:05+00:00 [Note] [Entrypoint]: Switching to dedicated user \u0026#39;mysql\u0026#39; mysql_db | 2022-06-17 08:24:05+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.29-1debian10 started. mysql_db | 2022-06-17T08:24:05.567299Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.29) starting as process 1 mysql_db | 2022-06-17T08:24:05.573086Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. mysql_db | 2022-06-17T08:24:06.719902Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. mysql_db | 2022-06-17T08:24:06.853179Z 0 [System] [MY-010229] [Server] Starting XA crash recovery... mysql_db | 2022-06-17T08:24:06.860721Z 0 [System] [MY-010232] [Server] XA crash recovery finished. mysql_db | 2022-06-17T08:24:06.953529Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. mysql_db | 2022-06-17T08:24:06.953559Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. mysql_db | 2022-06-17T08:24:06.954832Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location \u0026#39;/var/run/mysqld\u0026#39; in the path is accessible to all OS users. Consider choosing a different directory. mysql_db | 2022-06-17T08:24:06.973370Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: \u0026#39;8.0.29\u0026#39; socket: \u0026#39;/var/run/mysqld/mysqld.sock\u0026#39; port: 3306 MySQL Community Server - GPL. mysql_db | 2022-06-17T08:24:06.973520Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Bind-address: \u0026#39;::\u0026#39; port: 33060, socket: /var/run/mysqld/mysqlx.sock 查看 docker 執行的情況 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d081aaf01c4e mysql:8.0 \u0026#34;docker-entrypoint.s…\u0026#34; About a minute ago Up About a minute 0.0.0.0:3306-\u0026gt;3306/tcp, :::3306-\u0026gt;3306/tcp, 33060/tcp mysql_db 使用 dbeaver-cd 連結到 MySQL DB 開啟 dbeaver-cd 程式，按下 ｀New Database Connection` 按鈕\n開始設置連線資料設定，選擇資料庫 - MySQL 按下 ｀Next`\n輸入相關資訊，如 Database name、Username、Password\u0026hellip;等，按下｀Test Connectiono\u0026hellip;｀來測試設定是否成功。\n資料庫的實際檔案存放在 Local 的 /tmp/mysqldb 目錄中 使用作業系統管理者權限來查看此目錄\n$ ls -al /tmp/mysqldb/ 總用量 198084 drwxrwxr-x 7 systemd-coredump egs 4096 六 17 16:24 . drwxrwxrwt 26 root root 12288 六 17 16:31 .. -rw-r----- 1 systemd-coredump systemd-coredump 56 六 17 16:23 auto.cnf -rw-r----- 1 systemd-coredump systemd-coredump 3117106 六 17 16:24 binlog.000001 -rw-r----- 1 systemd-coredump systemd-coredump 157 六 17 16:24 binlog.000002 -rw-r----- 1 systemd-coredump systemd-coredump 32 六 17 16:24 binlog.index -rw------- 1 systemd-coredump systemd-coredump 1676 六 17 16:23 ca-key.pem -rw-r--r-- 1 systemd-coredump systemd-coredump 1112 六 17 16:23 ca.pem -rw-r--r-- 1 systemd-coredump systemd-coredump 1112 六 17 16:23 client-cert.pem -rw------- 1 systemd-coredump systemd-coredump 1680 六 17 16:23 client-key.pem -rw-r----- 1 systemd-coredump systemd-coredump 196608 六 17 16:26 \u0026#39;#ib_16384_0.dblwr\u0026#39; -rw-r----- 1 systemd-coredump systemd-coredump 8585216 六 17 16:23 \u0026#39;#ib_16384_1.dblwr\u0026#39; -rw-r----- 1 systemd-coredump systemd-coredump 5954 六 17 16:24 ib_buffer_pool -rw-r----- 1 systemd-coredump systemd-coredump 12582912 六 17 16:24 ibdata1 -rw-r----- 1 systemd-coredump systemd-coredump 50331648 六 17 16:26 ib_logfile0 -rw-r----- 1 systemd-coredump systemd-coredump 50331648 六 17 16:23 ib_logfile1 -rw-r----- 1 systemd-coredump systemd-coredump 12582912 六 17 16:24 ibtmp1 drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 16:24 \u0026#39;#innodb_temp\u0026#39; drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 16:23 mysql -rw-r----- 1 systemd-coredump systemd-coredump 31457280 六 17 16:24 mysql.ibd drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 16:23 performance_schema -rw------- 1 systemd-coredump systemd-coredump 1680 六 17 16:23 private_key.pem -rw-r--r-- 1 systemd-coredump systemd-coredump 452 六 17 16:23 public_key.pem -rw-r--r-- 1 systemd-coredump systemd-coredump 1112 六 17 16:23 server-cert.pem -rw------- 1 systemd-coredump systemd-coredump 1676 六 17 16:23 server-key.pem drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 16:24 sys drwxr-x--- 2 systemd-coredump systemd-coredump 4096 六 17 16:24 testdb -rw-r----- 1 systemd-coredump systemd-coredump 16777216 六 17 16:26 undo_001 -rw-r----- 1 systemd-coredump systemd-coredump 16777216 六 17 16:26 undo_002 ","permalink":"https://calvinegs.github.io/posts/docker-mysql/","summary":"使用 Docker 執行 MySQL 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 MySQL。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.17 API version: 1.41 Go version: go1.17.11 Git commit: 100c701 Built: Mon Jun 6 23:02:57 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.17 API version: 1.41 (minimum version 1.12) Go version: go1.17.11 Git commit: a89b842 Built: Mon Jun 6 23:01:03 2022 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.","title":"使用 Docker 執行 MySQL"},{"content":"github Source code\n本文記錄如何一步步從無到有使用 Angular 14 Reactive Form 表單驗證 與 Bootstrap 5 建立 一個使用者資料註冊、登入的表單功能連結到後端 API (node+postgresSQL)，在這些表單中按下送出時會自動檢核使用者所輸入的資料是否合乎程式中所設定的檢核邏輯，並顯示合適的訊息反應給使用者。其中將會使用到下列技術:\n Angular CLI 14 Bootstrap 5 (UI Framework) Angular  Reactive Form Custome Validator Interceptor JWT Session Storage Router Services Guard \u0026amp; Router Data    安裝 Angular/CLI 檢視目前環境為 node v16.14.0， global 安裝的是 Angular CLI 13.3.6\n$ node --version v16.14.0 $ ng version _ _ ____ _ ___ / \\  _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 13.3.6 Node: 16.14.0 Package Manager: npm 8.3.1 OS: linux x64 Angular: ... Package Version ------------------------------------------------------ @angular-devkit/architect 0.1303.6 (cli-only) @angular-devkit/core 13.3.6 (cli-only) @angular-devkit/schematics 13.3.6 (cli-only) @schematics/angular 13.3.6 (cli-only) 在 Local 安裝 Angular CLI ver.14 $ mkdir angular14 \u0026amp;\u0026amp; cd angular14 $ npm install @angular/cli@14 added 219 packages, and audited 220 packages in 6s 25 packages are looking for funding run `npm fund` for details found 0 vulnerabilities $ ls -al 總用量 176 drwxrwxr-x 3 egs egs 4096 六 16 11:10 . drwxrwxr-x 10 egs egs 4096 六 16 11:10 .. drwxrwxr-x 191 egs egs 4096 六 16 11:10 node_modules -rw-rw-r-- 1 egs egs 58 六 16 11:10 package.json -rw-rw-r-- 1 egs egs 163807 六 16 11:10 package-lock.json $ cat package.json { \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/cli\u0026#34;: \u0026#34;^14.0.2\u0026#34; } } $ npx ng version _ _ ____ _ ___ / \\  _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 14.0.1 Node: 16.14.0 Package Manager: npm 8.3.1 OS: linux x64 Angular: undefined ... Package Version ------------------------------------------------------ @angular-devkit/architect 0.1400.1 @angular-devkit/core 14.0.1 @angular-devkit/schematics 14.0.1 @angular/cli 14.0.1 @schematics/angular 14.0.1 建立新專案 $ npx ng new angular-auth-jwt ? Would you like to add Angular routing? Yes ? Which stylesheet format would you like to use? SCSS [ https://sass-lang.com/documentation/syntax#scss ] CREATE angular-auth-jwt/README.md (1068 bytes) CREATE angular-auth-jwt/.editorconfig (274 bytes) CREATE angular-auth-jwt/.gitignore (548 bytes) CREATE angular-auth-jwt/angular.json (3146 bytes) CREATE angular-auth-jwt/package.json (1047 bytes) CREATE angular-auth-jwt/tsconfig.json (863 bytes) CREATE angular-auth-jwt/.browserslistrc (600 bytes) CREATE angular-auth-jwt/karma.conf.js (1433 bytes) CREATE angular-auth-jwt/tsconfig.app.json (287 bytes) CREATE angular-auth-jwt/tsconfig.spec.json (333 bytes) CREATE angular-auth-jwt/.vscode/extensions.json (130 bytes) CREATE angular-auth-jwt/.vscode/launch.json (474 bytes) CREATE angular-auth-jwt/.vscode/tasks.json (938 bytes) CREATE angular-auth-jwt/src/favicon.ico (948 bytes) CREATE angular-auth-jwt/src/index.html (300 bytes) CREATE angular-auth-jwt/src/main.ts (372 bytes) CREATE angular-auth-jwt/src/polyfills.ts (2338 bytes) CREATE angular-auth-jwt/src/styles.scss (80 bytes) CREATE angular-auth-jwt/src/test.ts (749 bytes) CREATE angular-auth-jwt/src/assets/.gitkeep (0 bytes) CREATE angular-auth-jwt/src/environments/environment.prod.ts (51 bytes) CREATE angular-auth-jwt/src/environments/environment.ts (658 bytes) CREATE angular-auth-jwt/src/app/app-routing.module.ts (245 bytes) CREATE angular-auth-jwt/src/app/app.module.ts (393 bytes) CREATE angular-auth-jwt/src/app/app.component.scss (0 bytes) CREATE angular-auth-jwt/src/app/app.component.html (23364 bytes) CREATE angular-auth-jwt/src/app/app.component.spec.ts (1103 bytes) CREATE angular-auth-jwt/src/app/app.component.ts (221 bytes) ✔ Packages installed successfully. Successfully initialized git. $ cd angular-auth-jwt $ cat package.json { \u0026#34;name\u0026#34;: \u0026#34;angular-auth-jwt\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;ng build --watch --configuration development\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34; }, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;rxjs\u0026#34;: \u0026#34;~7.5.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^2.3.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.11.4\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;^14.0.1\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~14.0.1\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;^14.0.0\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~4.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~4.1.0\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~6.3.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~3.1.0\u0026#34;, \u0026#34;karma-coverage\u0026#34;: \u0026#34;~2.2.0\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;~1.7.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~4.7.2\u0026#34; } } 執行由 CLI 産生的預設程式架構\n$ npm start ✔ Browser application bundle generation complete. Initial Chunk Files | Names | Raw Size vendor.js | vendor | 2.02 MB | polyfills.js | polyfills | 313.40 kB | styles.css, styles.js | styles | 207.83 kB | main.js | main | 50.14 kB | runtime.js | runtime | 6.53 kB | | Initial Total | 2.58 MB Build at: 2022-06-15T03:24:52.638Z - Hash: abf680be2edec496 - Time: 9646ms ** Angular Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ ** ✔ Compiled successfully. 開啟瀏覽器，輸入 http://localhost:4200/\n$ ls -al 總用量 868 drwxrwxr-x 7 egs egs 4096 六 15 11:24 . drwxrwxr-x 4 egs egs 4096 六 15 11:21 .. drwxrwxr-x 3 egs egs 4096 六 15 11:24 .angular -rw-rw-r-- 1 egs egs 3146 六 15 11:21 angular.json -rw-rw-r-- 1 egs egs 600 六 15 11:21 .browserslistrc -rw-rw-r-- 1 egs egs 274 六 15 11:21 .editorconfig drwxrwxr-x 8 egs egs 4096 六 15 11:22 .git -rw-rw-r-- 1 egs egs 548 六 15 11:21 .gitignore -rw-rw-r-- 1 egs egs 1433 六 15 11:21 karma.conf.js drwxrwxr-x 596 egs egs 20480 六 15 11:24 node_modules -rw-rw-r-- 1 egs egs 1047 六 15 11:21 package.json -rw-rw-r-- 1 egs egs 800093 六 15 11:22 package-lock.json -rw-rw-r-- 1 egs egs 1068 六 15 11:21 README.md drwxrwxr-x 5 egs egs 4096 六 15 11:21 src -rw-rw-r-- 1 egs egs 287 六 15 11:21 tsconfig.app.json -rw-rw-r-- 1 egs egs 863 六 15 11:21 tsconfig.json -rw-rw-r-- 1 egs egs 333 六 15 11:21 tsconfig.spec.json drwxrwxr-x 2 egs egs 4096 六 15 11:21 .vscode 設置專案 建立相關元件 與 服務 $ ng g s shared/services/auth # 新增 auth service $ ng g s shared/services/token-storage # 新增 token-storage service $ ng g s shared/services/user # 新增 user service $ ng g interceptor shared/interceptor/auth　# 新增 auth interceptor $ ng g c pages/login $ ng g c pages/register $ ng g c pages/profile $ ng g c pages/home $ ng g c pages/board-user $ ng g c pages/board-moderator $ ng g c pages/board-admin $ ng g guard shared/guard/auth --implements=\u0026#34;CanActivate\u0026#34; # 新增 auth guard $ ng g guard shared/guard/role --implements=\u0026#34;CanActivate\u0026#34; # 新增 role guard 檔案結構 撰寫 Services 程式 打開 vscode\n$ code .　# 打開 vscode 將程式中會使用的參數值放在 appSettings.ts 中 在開始新增 Services 程式前，我們可以考慮將固定的參數值放在 appSettings.ts 中，來增加一些彈性。在 shared目錄下新增一個　helpers 的子目錄，並新增一支 appSettings.ts 程式，內容如下。設置一個靜態常數 API_URL，並把它 export 出來，讓外面的程式可以引用它。\nexport class AppSettings { static API_URL = \u0026#39;http://localhost:5000/api/\u0026#39;; } 註冊與登入使用的服務程式 auth.service.ts 註冊與登入功能須搭配後端 API，可參考　使用 Node.js + express + postgres 建立一個後端服務 REST API\nimport { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { AppSettings } from \u0026#39;../helpers/appSettings\u0026#39;; const API_URL = AppSettings.API_URL + \u0026#39;auth/\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class AuthService { constructor( private http: HttpClient) { } login(username: string, password: string): Observable\u0026lt;any\u0026gt; { return this.http.post(API_URL + \u0026#39;signin\u0026#39;, { username, password }) } register(username: string, email:string, password: string): Observable\u0026lt;any\u0026gt; { return this.http.post(API_URL + \u0026#39;signup\u0026#39;, { username, email, password }) } } Token 相關的服務程式 token-storage.service.ts 在本範例中，我們會把由 API 回來回來的 Token 儲存在 local 瀏覽器中的 Session Local Storage 中。\nimport { Injectable } from \u0026#39;@angular/core\u0026#39;; const TOKEN_KEY = \u0026#39;auth-token\u0026#39;; const USER_KEY = \u0026#39;auth-user\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class TokenStorageService { constructor() { } signOut(): void { window.sessionStorage.clear(); } public saveToken(token: string): void { sessionStorage.removeItem(TOKEN_KEY); sessionStorage.setItem(TOKEN_KEY, token); } public getToken(): string | null { return sessionStorage.getItem(TOKEN_KEY); } public saveUser(user: any): void { sessionStorage.removeItem(USER_KEY); sessionStorage.setItem(USER_KEY, JSON.stringify(user)); } public getUser(): any { const user = sessionStorage.getItem(USER_KEY); if (user) { return JSON.parse(user); } return user; } } User 相關的服務程式 user.service.ts user service 是藉由 API 來展示如何透過權限管理功能來管理不同的子功能。這由的權限管控時直接利用後端 API 功能來檢核目前的使用者是否具有相關權限來執行這些功能。在本筆記後面我們也會利用 Angular Router Guard 的功能來實現 Local 如何來管理 user 與路由間的執行權限。\nimport { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { AppSettings } from \u0026#39;../helpers/appSettings\u0026#39;; const API_URL = AppSettings.API_URL + \u0026#39;users/test/\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class UserService { constructor(private http: HttpClient) { } getPublicContent(): Observable\u0026lt;any\u0026gt; { return this.http.get(API_URL + \u0026#39;all\u0026#39;, { responseType: \u0026#39;text\u0026#39; }) } getUserBoard(): Observable\u0026lt;any\u0026gt; { return this.http.get(API_URL + \u0026#39;user\u0026#39;, { responseType: \u0026#39;text\u0026#39; }) } getModeratorBoard(): Observable\u0026lt;any\u0026gt; { return this.http.get(API_URL + \u0026#39;moderator\u0026#39;, { responseType: \u0026#39;text\u0026#39; }) } getAdminBoard(): Observable\u0026lt;any\u0026gt; { return this.http.get(API_URL + \u0026#39;admin\u0026#39;, { responseType: \u0026#39;text\u0026#39; }) } } 撰寫 HTTP Interceptor 程式 HTTP Interceptor 可以讓我們很容易的在每一個 request Header 中加入我們登入成功後由 API 回傳回來的｀合法Token`。在這個程式中唯一要注意的是，不應更改原始的 request，而是應該透過 clone 功能來産生一個新的 request 再將 token 寫入這個新 request 的 Header。\n// ./app/shared/interceptor/auth.interceptor.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor, HTTP_INTERCEPTORS } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { TokenStorageService } from \u0026#39;../services/token-storage.service\u0026#39;; @Injectable() export class AuthInterceptor implements HttpInterceptor { constructor(private tokenService: TokenStorageService) {} intercept(request: HttpRequest\u0026lt;any\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;any\u0026gt;\u0026gt; { let authRequest = request; const token = this.tokenService.getToken(); if (token != null) { authRequest = request.clone({ setHeaders: { Authorization: `Bearer ${token}` } }); } return next.handle(authRequest); } } export const authInterceptorProviders = [{ provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }] 將 HTTP Interceptor 加入到 app module 的 providers 上述完成的 Interceptor 要記得注入到 app module providers 設定中（第14、32行）。 同時，在前述的 services 中我們使用到了 HttpClient，所以也必須匯入 HttpClient Module（第3、30行）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;;  import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { BoardAdminComponent } from \u0026#39;./pages/board-admin/board-admin.component\u0026#39;; import { BoardModeratorComponent } from \u0026#39;./pages/board-moderator/board-moderator.component\u0026#39;; import { BoardUserComponent } from \u0026#39;./pages/board-user/board-user.component\u0026#39;; import { authInterceptorProviders } from \u0026#39;./shared/interceptor/auth.interceptor\u0026#39;;  @NgModule({ declarations: [ AppComponent, LoginComponent, RegisterComponent, HomeComponent, ProfileComponent, BoardAdminComponent, BoardModeratorComponent, BoardUserComponent ], imports: [ BrowserModule, AppRoutingModule, HttpClientModule  ], providers: [authInterceptorProviders],  bootstrap: [AppComponent] }) export class AppModule { }   新增 components 接著要來建立 components，在此我們使的是 Reactive Form 並使用 bootstrap CSS framework來裝飾我們的 component ，所必須先進行相關設定\n匯入 ReactiveFormModule 模組 開啟 src/app/app.module.ts 並由 @angular/forms 匯入 ReactiveFormModule\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; //... @NgModule({ declarations: [ AppComponent //...  ], imports: [ BrowserModule, AppRoutingModule, ReactiveFormsModule,  HttpClientModule ], providers: [authInterceptorProviders], bootstrap: [AppComponent] }) export class AppModule { }   使用 Bootstrap 開啟 src/index.html 在  加入 link tag\n 使用 bootstrap 5 如第 9 行匯入語法  1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;AngularAuthJwt\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   新增 Register Component // register.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormControl, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; import Validation from \u0026#39;src/app/shared/helpers/validation\u0026#39;; import { AuthService } from \u0026#39;src/app/shared/services/auth.service\u0026#39;; @Component({ selector: \u0026#39;app-register\u0026#39;, templateUrl: \u0026#39;./register.component.html\u0026#39;, styleUrls: [\u0026#39;./register.component.scss\u0026#39;] }) export class RegisterComponent implements OnInit { form: FormGroup = new FormGroup({ username: new FormControl(\u0026#39;\u0026#39;), email: new FormControl(\u0026#39;\u0026#39;), password: new FormControl(\u0026#39;\u0026#39;), confirmPassword: new FormControl(\u0026#39;\u0026#39;) }); submitted = false; isSuccessful = false;; isSignUpFailed = false; errorMessage = \u0026#39;\u0026#39;; constructor(private formBuilder: FormBuilder, private authService: AuthService) { } ngOnInit(): void { this.form = this.formBuilder.group( { username: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(4), Validators.maxLength(20) ] ], email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]], password: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(40) ] ], confirmPassword: [\u0026#39;\u0026#39;,Validators.required], }, { validators: [Validation.match(\u0026#39;password\u0026#39;, \u0026#39;confirmPassword\u0026#39;)] } ) } get f(): { [key: string]: AbstractControl } { return this.form.controls; } onSubmit(): void { this.submitted = true; if (this.form.invalid) { return; } const { username, email, password } = this.form.getRawValue(); this.authService.register(username!, email!, password!).subscribe({ next: (data) =\u0026gt; { console.log(data); this.isSuccessful = true; this.isSignUpFailed = false; }, error: (err) =\u0026gt; { this.isSuccessful = false; this.isSignUpFailed = true; } }); } onReset(): void { this.submitted = false; this.isSignUpFailed = false; this.form.reset(); } } 在 Register Component 中我們使用了一個 Custom Validator，它用來比對二次輸入的密碼是否一致，程式碼如下：\n註冊元件的程式碼 // validation.ts import { AbstractControl, ValidatorFn } from \u0026#34;@angular/forms\u0026#34;; export default class Validation { static match(controlName: string, checkControlName: string): ValidatorFn { return (controls: AbstractControl) =\u0026gt; { const control = controls.get(controlName); const checkControl = controls.get(checkControlName); if (checkControl?.errors \u0026amp;\u0026amp; !checkControl.errors[\u0026#39;matching\u0026#39;]) { return null; } if (control?.value !== checkControl?.value) { controls.get(checkControlName)?.setErrors({ matching: true }); return { match: true }; } else { return null; } } } } 註冊元件的 HTML\n\u0026lt;!-- register.component.html --\u0026gt; \u0026lt;div class=\u0026#34;container-fluid register-form\u0026#34;\u0026gt; \u0026lt;form needs-validation [formGroup]=\u0026#34;form\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; 使用者資料註冊 \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; autofocus formControlName=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;username\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Username 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;minlength\u0026#39;]\u0026#34;\u0026gt; Username 必須至少為六個字元 \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;maxlength\u0026#39;]\u0026#34;\u0026gt; Username 必須至多為二十個字元 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;email\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;email\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;email\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;email\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Email 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;email\u0026#39;].errors[\u0026#39;email\u0026#39;]\u0026#34;\u0026gt;Email 格式不符\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;password\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Password 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;minlength\u0026#39;]\u0026#34;\u0026gt; Password 必須至少為六個字元 \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;maxlength\u0026#39;]\u0026#34;\u0026gt; Password 必須至多為四十個字元 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;confirmPassword\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Confirm Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;confirmPassword\u0026#34; id=\u0026#34;confirmPassword\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;confirmPassword\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;confirmPassword\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;confirmPassword\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;confirmPassword\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Confirm Password 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;confirmPassword\u0026#39;].errors[\u0026#39;matching\u0026#39;]\u0026#34;\u0026gt; Confirm Password 不符 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;送出\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;onReset()\u0026#34; class=\u0026#34;btn btn-warning float-end\u0026#34;\u0026gt; 重置 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alert alert-warning\u0026#34; *ngIf=\u0026#34;isSignUpFailed\u0026#34;\u0026gt; 註冊失敗!\u0026lt;br /\u0026gt;{{ errorMessage }} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alert alert-success\u0026#34; *ngIf=\u0026#34;isSuccessful\u0026#34;\u0026gt; 註冊成功！ \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; 註冊元件的 CSS\n/* register.component.scss */ .register-form { max-width: 350px; margin: auto; } 新增 Login Component 登入元件的程式碼\n// login.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormControl, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; import { AuthService } from \u0026#39;src/app/shared/services/auth.service\u0026#39;; import { TokenStorageService } from \u0026#39;src/app/shared/services/token-storage.service\u0026#39;; @Component({ selector: \u0026#39;app-login\u0026#39;, templateUrl: \u0026#39;./login.component.html\u0026#39;, styleUrls: [\u0026#39;./login.component.scss\u0026#39;] }) export class LoginComponent implements OnInit { form: FormGroup = new FormGroup({ username: new FormControl(\u0026#39;\u0026#39;), password: new FormControl(\u0026#39;\u0026#39;) }); isLoggedIn = false; isLoginFailed = false; submitted = false; errorMessage = \u0026#39;\u0026#39;; roles: string[] = []; constructor(private formBuilder: FormBuilder, private authService: AuthService, private tokenStorage: TokenStorageService) { } ngOnInit(): void { if (this.tokenStorage.getToken()) { this.isLoggedIn = true; this.roles = this.tokenStorage.getUser().roles; } this.form = this.formBuilder.group( { username: [\u0026#39;\u0026#39;,[Validators.required]], password: [\u0026#39;\u0026#39;,[Validators.required]] } ) } get f(): { [key: string]: AbstractControl } { return this.form.controls; } onSubmit(): void { this.submitted = true; if (this.form.invalid) { return; } const { username, password } = this.form.getRawValue(); this.authService.login(username, password).subscribe({ next: data =\u0026gt; { this.tokenStorage.saveToken(data.accessToken); this.tokenStorage.saveUser(data); this.isLoggedIn = true; this.roles = this.tokenStorage.getUser().roles; this.roloadPage(); }, error: err =\u0026gt; { this.errorMessage = err.error.message; this.isLoginFailed = true; } }) } roloadPage(): void { this.submitted = false; location.reload(); } onReset(): void { this.submitted = false; this.isLoginFailed = false; this.form.reset(); } } 登入元件的 HTML\n\u0026lt;!-- login.component.html --\u0026gt; \u0026lt;div class=\u0026#34;container-fluid register-form\u0026#34;\u0026gt; \u0026lt;form *ngIf=\u0026#34;!isLoggedIn\u0026#34; needs-validation [formGroup]=\u0026#34;form\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; 使用者登入 \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; autofocus formControlName=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;username\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Username 為必填\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;password\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Password 為必填\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;送出\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;onReset()\u0026#34; class=\u0026#34;btn btn-warning float-end\u0026#34;\u0026gt; 重置 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;alert alert-warning\u0026#34; *ngIf=\u0026#34;isLoginFailed\u0026#34;\u0026gt; Signin failed!\u0026lt;br /\u0026gt;{{ errorMessage }} \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;alert alert-success\u0026#34; *ngIf=\u0026#34;isLoggedIn\u0026#34;\u0026gt; 登入者具備的角色 {{ roles }}. \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 登入元件的 CSS\n/* login.component.scss */ .login-form { max-width: 350px; margin: auto; } 新增 Profile Component 個人檔案的程式碼\n// profile.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { TokenStorageService } from \u0026#39;src/app/shared/services/token-storage.service\u0026#39;; @Component({ selector: \u0026#39;app-profile\u0026#39;, templateUrl: \u0026#39;./profile.component.html\u0026#39;, styleUrls: [\u0026#39;./profile.component.scss\u0026#39;] }) export class ProfileComponent implements OnInit { currentUser: any; constructor(private token: TokenStorageService) { } ngOnInit(): void { this.currentUser = this.token.getUser(); } } 個人檔案的 HTML\n\u0026lt;!-- profile.component.html --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34; *ngIf=\u0026#34;currentUser; else loggedOut\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;jumbotron\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;strong\u0026gt;{{ currentUser.username }}\u0026lt;/strong\u0026gt; 個人訊息\u0026lt;/h3\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Token:\u0026lt;/strong\u0026gt; {{ currentUser.accessToken.substring(0, 20)}} ... {{ currentUser.accessToken.substr( currentUser.accessToken.length - 20)}} \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;電子信箱:\u0026lt;/strong\u0026gt; {{ currentUser.email }} \u0026lt;/p\u0026gt; \u0026lt;strong\u0026gt;參與的角色:\u0026lt;/strong\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let role of currentUser.roles\u0026#34;\u0026gt; {{ role }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ng-template #loggedOut\u0026gt; 請先登入 \u0026lt;/ng-template\u0026gt; 新增 Role-base components 接下來要完成的功能是為了展示不同授權使用者可以看到的 UI 及 執行不同功能的權限控制。\n新增 Public Component //home.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { UserService } from \u0026#39;../_services/user.service\u0026#39;; @Component({ selector: \u0026#39;app-home\u0026#39;, templateUrl: \u0026#39;./home.component.html\u0026#39;, styleUrls: [\u0026#39;./home.component.css\u0026#39;] }) export class HomeComponent implements OnInit { content?: string; constructor(private userService: UserService) { } ngOnInit(): void { this.userService.getPublicContent().subscribe({ next: data =\u0026gt; { this.content = data; }, error: err =\u0026gt; { this.content = JSON.parse(err.error).message; } }); } } \u0026lt;!-- home.component.heml --\u0026gt; \u0026lt;!-- board-user.component.heml --\u0026gt; \u0026lt;!-- board-moderator.component.heml --\u0026gt; \u0026lt;!-- board-admin.component.heml --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;jumbotron\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ content }}\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;/div\u0026gt; 新增 User Component // board-user.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { UserService } from \u0026#39;src/app/shared/services/user.service\u0026#39;; @Component({ selector: \u0026#39;app-board-user\u0026#39;, templateUrl: \u0026#39;./board-user.component.html\u0026#39;, styleUrls: [\u0026#39;./board-user.component.scss\u0026#39;] }) export class BoardUserComponent implements OnInit { content?: string; constructor(private userService: UserService) { } ngOnInit(): void { this.userService.getUserBoard().subscribe({ next: data =\u0026gt; { this.content = data; }, error: err =\u0026gt; { this.content = JSON.parse(err.error).message; } }) } } 新增 Moderator Component // board-moderator.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { UserService } from \u0026#39;src/app/shared/services/user.service\u0026#39;; @Component({ selector: \u0026#39;app-board-moderator\u0026#39;, templateUrl: \u0026#39;./board-moderator.component.html\u0026#39;, styleUrls: [\u0026#39;./board-moderator.component.scss\u0026#39;] }) export class BoardModeratorComponent implements OnInit { content?: string; constructor(private userService: UserService) { } ngOnInit(): void { this.userService.getModeratorBoard().subscribe({ next: data =\u0026gt; { this.content = data; }, error: err =\u0026gt; { this.content = JSON.parse(err.error).message; } }) } } 新增 Admin Component // board-admin.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { UserService } from \u0026#39;src/app/shared/services/user.service\u0026#39;; @Component({ selector: \u0026#39;app-board-admin\u0026#39;, templateUrl: \u0026#39;./board-admin.component.html\u0026#39;, styleUrls: [\u0026#39;./board-admin.component.scss\u0026#39;] }) export class BoardAdminComponent implements OnInit { content?: string; constructor(private userService: UserService) { } ngOnInit(): void { this.userService.getAdminBoard().subscribe({ next: data =\u0026gt; { this.content = data; }, error: err =\u0026gt; { this.content = JSON.parse(err.error).message; } }) } } 路由設置 透過路由的設置，程式才會知道當使用者在瀏覧器特定的 URI 時，程式應該去執那支相對應的程式。路由模組檔案（app-routin.module.ts）內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { BoardAdminComponent } from \u0026#39;./pages/board-admin/board-admin.component\u0026#39;; import { BoardModeratorComponent } from \u0026#39;./pages/board-moderator/board-moderator.component\u0026#39;; import { BoardUserComponent } from \u0026#39;./pages/board-user/board-user.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; const routes: Routes = [  { path: \u0026#39;home\u0026#39;, component: HomeComponent }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, { path: \u0026#39;register\u0026#39;, component: RegisterComponent }, { path: \u0026#39;profile\u0026#39;, component: ProfileComponent }, { path: \u0026#39;user\u0026#39;, component: BoardUserComponent}, { path: \u0026#39;moderator\u0026#39;, component: BoardModeratorComponent }, { path: \u0026#39;admin\u0026#39;, component: BoardAdminComponent }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39;} ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   App Module 的設置 // app.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;; import { AppRoutingModule } from \u0026#39;./app-routing.module\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { BoardAdminComponent } from \u0026#39;./pages/board-admin/board-admin.component\u0026#39;; import { BoardModeratorComponent } from \u0026#39;./pages/board-moderator/board-moderator.component\u0026#39;; import { BoardUserComponent } from \u0026#39;./pages/board-user/board-user.component\u0026#39;; import { authInterceptorProviders } from \u0026#39;./shared/interceptor/auth.interceptor\u0026#39;; @NgModule({ declarations: [ AppComponent, LoginComponent, RegisterComponent, HomeComponent, ProfileComponent, BoardAdminComponent, BoardModeratorComponent, BoardUserComponent ], imports: [ BrowserModule, AppRoutingModule, ReactiveFormsModule, HttpClientModule ], providers: [authInterceptorProviders], bootstrap: [AppComponent] }) export class AppModule { } App Component 修改 App 元件的程式碼\n// app.component.ts import { Component } from \u0026#39;@angular/core\u0026#39;; import { TokenStorageService } from \u0026#39;./shared/services/token-storage.service\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent { private roles: string[] = []; isLoggedIn = false; //用來記錄是否已登入系統的變數  showAdminBoard = false; //記錄是否有｀管理者｀角色的變數  showModeratorBoard = false;　//記錄是否有｀版主｀角色的變數  username?: string; constructor(private tokenStorageService: TokenStorageService) {} ngOnInit(): void { this.isLoggedIn = !!this.tokenStorageService.getToken(); // 若在 session storage 中有有效的 token 則表示已有正常的登入系統  if (this.isLoggedIn) { const user = this.tokenStorageService.getUser(); this.roles = user.roles; this.showAdminBoard = this.roles.includes(\u0026#39;ADMIN\u0026#39;); //判斷是否有管理者角色  this.showModeratorBoard = this.roles.includes(\u0026#39;MODERATOR\u0026#39;);　//判斷是否有版主角色  this.username = user.username; } } logout(): void { this.tokenStorageService.signOut(); //清除 session storage  location.reload(); } } App 元件的 HTML\n\u0026lt;!-- app.component.html --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;nav class=\u0026#34;navbar navbar-expand navbar-dark bg-dark\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;navbar-brand\u0026#34;\u0026gt;Angular14\u0026lt;/a\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav me-auto\u0026#34; routerLinkActive=\u0026#34;active\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/home\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;home\u0026#34;\u0026gt;首頁\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34; *ngIf=\u0026#34;showAdminBoard\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/admin\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;admin\u0026#34;\u0026gt;管理者\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34; *ngIf=\u0026#34;showModeratorBoard\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/moderator\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;moderator\u0026#34;\u0026gt;版主\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/user\u0026#34; class=\u0026#34;nav-link\u0026#34; *ngIf=\u0026#34;isLoggedIn\u0026#34; routerLink=\u0026#34;user\u0026#34;\u0026gt;使用者\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav ms-auto\u0026#34; *ngIf=\u0026#34;!isLoggedIn\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/register\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;register\u0026#34;\u0026gt;註冊\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/login\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;login\u0026#34;\u0026gt;登入\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav ms-auto\u0026#34; *ngIf=\u0026#34;isLoggedIn\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/profile\u0026#34; class=\u0026#34;nav-link\u0026#34; routerLink=\u0026#34;profile\u0026#34;\u0026gt;{{ username }}\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a href class=\u0026#34;nav-link\u0026#34; (click)=\u0026#34;logout()\u0026#34;\u0026gt;登出\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 執行程式 結行結果：\n Home Page  首頁為預設的 Page，同時它也是一供公開的功能，沒有使用權限的限定，所以即使你未登入，也可以瀏覽。\n一般使用者登入後的畫面  以已註冊的使用者登入系統後，可以發現主頁面上的功能選項多出了“使用者” 與 \u0026ldquo;jack\u0026rdquo; 兩項\n其中 ｀jack｀ 指的是現在已登入者的 username (登入帳號)，同時點進這功能會顯示使用者的明細資料。 而｀使用者｀這個功能項目也是隨著使用者登入成功後才顯示出來的。 管理角色使用者登入後的畫面  下圖是以｀管理者｀角色登入後所顯示的畫面。而因為這個使用者同時角色多重角色（admin \u0026amp; Moderator)，所以功能選項同時出現了 `管理者｀｀版主｀｀使用者｀等項目。 Route Guard 上述 Role-base components 執行時的權限管控是透過 API 端的功能來實現，這樣的方式有其必要性，特別是在保護 Web API 端點的執行權限。\n下圖中是指還沒有登入時刻意的在瀏覽器輸入　“http://localhost:4200/user”，結果以目前程式的流程，這個路由所對應到的程式是有被執行的，只是因為我們在後台的 API 中有啟動了保護措施，所以檢核出目前未登入的狀態不應該可以執行這個特定的功能，所以回傳了“目前未被授權”的錯誤訊息。\n而下面第二個案例，使用者 jack 是一般使用者，所以登入後顯示可執行功能如下圖只有｀使用者｀這項功能。此刻若直接在瀏覽器輸入　http://localhost:4200/admin 會發現雖然畫面上沒有顯示｀管理者｀功能選項，但你還是可以｀執行｀它，也因為後端 API 有檢核，所以回傳了｀Require Admin Role!｀的錯誤內容。\n帳號認證攔截器 接下來要介紹的　路由保護器(攔截器)　是一種 local 端保護機制。透過 Route Guard 的設置可以在使用者端就能效管理各個 route 的執行權限的控管。\nauthGuard 這個路由保護器的功能就是來攔截沒有正常登入系統的使用者不得執行特定的路由。在程式中透過 tokenService.getToken() 功能來讀取 token，若 session storeage 中沒有合法 token，表示目前還沒有正確的登入系統，並將程式指向登入功能。\n// auth.guard.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRouteSnapshot, CanActivate, Router, RouterStateSnapshot, UrlTree } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { TokenStorageService } from \u0026#39;../services/token-storage.service\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class AuthGuard implements CanActivate { constructor(private router: Router, private tokenService: TokenStorageService) {}; canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable\u0026lt;boolean | UrlTree\u0026gt; | Promise\u0026lt;boolean | UrlTree\u0026gt; | boolean | UrlTree { if(this.tokenService.getToken()) return true; this.router.navigate([\u0026#39;/login\u0026#39;]); return true; } } app-routing.module.ts 中的路由設定，將 AuthGurad 加入到要保護的 路由設定　中。如下程式第18行{ path: 'add-todo', canActivate:[AuthGuard], component: AddTodoComponent },，其中的　canActivate:[AuthGuard] 就是幫這個路由設定加入了 ‘AuthGuard’ 這個攔截器來起到保護這個路由的作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { BoardAdminComponent } from \u0026#39;./pages/board-admin/board-admin.component\u0026#39;; import { BoardModeratorComponent } from \u0026#39;./pages/board-moderator/board-moderator.component\u0026#39;; import { BoardUserComponent } from \u0026#39;./pages/board-user/board-user.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { AuthGuard } from \u0026#39;./shared/guard/auth.guard\u0026#39;;  const routes: Routes = [ { path: \u0026#39;home\u0026#39;, component: HomeComponent }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, { path: \u0026#39;register\u0026#39;, component: RegisterComponent }, { path: \u0026#39;profile\u0026#39;, component: ProfileComponent }, { path: \u0026#39;user\u0026#39;, component: BoardUserComponent, canActivate:[AuthGuard] },  { path: \u0026#39;moderator\u0026#39;, component: BoardModeratorComponent, canActivate:[AuthGuard, RoleGuard], data: {roles: [\u0026#39;moderator\u0026#39;]} }, { path: \u0026#39;admin\u0026#39;, component: BoardAdminComponent, canActivate:[AuthGuard, RoleGuard], data: {roles: [\u0026#39;admin\u0026#39;]} }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39;} ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   角色授權攔截器 roleGuard 這個路由保護器的功能就是來攔截現行的使用者是否具備有特定的角色，若沒有指定的角色不得執行特定的路由。並顯示目前使有者所具備的角色有那些。\n// role.guard.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRouteSnapshot, CanActivate, Router, RouterStateSnapshot, UrlTree } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { TokenStorageService } from \u0026#39;../services/token-storage.service\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class RoleGuard implements CanActivate { constructor(private router: Router, private tokenService: TokenStorageService) {}; canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable\u0026lt;boolean | UrlTree\u0026gt; | Promise\u0026lt;boolean | UrlTree\u0026gt; | boolean | UrlTree { const roles = this.tokenService.getUser().roles; const rolesPara = route.data[\u0026#34;roles\u0026#34;] as Array\u0026lt;string\u0026gt;; let searchRole = \u0026#39;USER\u0026#39;; if (rolesPara) { searchRole = rolesPara[0].toUpperCase(); } if (roles) { const rolesArray = roles as Array\u0026lt;string\u0026gt; if (rolesArray.indexOf(searchRole) != -1) return true; }; this.router.navigate([\u0026#39;/login\u0026#39;]); return true; } } app-routing.module.ts 中的路由設定，將 AuthGurad 加入到要保護的 路由設定　中。如下程式第18行{ path: 'add-todo', canActivate:[AuthGuard], component: AddTodoComponent },，其中的　canActivate:[AuthGuard] 就是幫這個路由設定加入了 ‘AuthGuard’ 這個攔截器來起到保護這個路由的作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { BoardAdminComponent } from \u0026#39;./pages/board-admin/board-admin.component\u0026#39;; import { BoardModeratorComponent } from \u0026#39;./pages/board-moderator/board-moderator.component\u0026#39;; import { BoardUserComponent } from \u0026#39;./pages/board-user/board-user.component\u0026#39;; import { HomeComponent } from \u0026#39;./pages/home/home.component\u0026#39;; import { LoginComponent } from \u0026#39;./pages/login/login.component\u0026#39;; import { ProfileComponent } from \u0026#39;./pages/profile/profile.component\u0026#39;; import { RegisterComponent } from \u0026#39;./pages/register/register.component\u0026#39;; import { AuthGuard } from \u0026#39;./shared/guard/auth.guard\u0026#39;; import { RoleGuard } from \u0026#39;./shared/guard/role.guard\u0026#39;;  const routes: Routes = [ { path: \u0026#39;home\u0026#39;, component: HomeComponent }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, { path: \u0026#39;register\u0026#39;, component: RegisterComponent }, { path: \u0026#39;profile\u0026#39;, component: ProfileComponent }, { path: \u0026#39;user\u0026#39;, component: BoardUserComponent, canActivate:[AuthGuard] }, { path: \u0026#39;moderator\u0026#39;, component: BoardModeratorComponent, canActivate:[AuthGuard, RoleGuard], data: {roles: [\u0026#39;moderator\u0026#39;]} },  { path: \u0026#39;admin\u0026#39;, component: BoardAdminComponent, canActivate:[AuthGuard, RoleGuard], data: {roles: [\u0026#39;admin\u0026#39;]} }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;home\u0026#39;, pathMatch: \u0026#39;full\u0026#39;} ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   ","permalink":"https://calvinegs.github.io/posts/angular-auth-jwt/","summary":"github Source code\n本文記錄如何一步步從無到有使用 Angular 14 Reactive Form 表單驗證 與 Bootstrap 5 建立 一個使用者資料註冊、登入的表單功能連結到後端 API (node+postgresSQL)，在這些表單中按下送出時會自動檢核使用者所輸入的資料是否合乎程式中所設定的檢核邏輯，並顯示合適的訊息反應給使用者。其中將會使用到下列技術:\n Angular CLI 14 Bootstrap 5 (UI Framework) Angular  Reactive Form Custome Validator Interceptor JWT Session Storage Router Services Guard \u0026amp; Router Data    安裝 Angular/CLI 檢視目前環境為 node v16.14.0， global 安裝的是 Angular CLI 13.3.6\n$ node --version v16.14.0 $ ng version _ _ ____ _ ___ / \\  _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 13.","title":"使用 Angular 14 建立 Reactive Form 表單驗證範例"},{"content":"github Source code\nTechnology:\n NodeJs 17.6.0 Express 4.17.1 cors 2.8.5 crypto-js 4.1.1 # 加解密套件 jsonwebtoken 8.5.1 # Json Web Token 的功能套件 Sequelize 6.20.1 # ORM 套件 pg 8.7.3 # PostgreSQL client for Node.js pg-hstore 2.3.4 # serializing and deserializing JSON data to hstore format PostgreSQL 14.3 # 使用的資料庫  專案完成後的檔案結構 ./專案目錄 ├── app/ │ ├── config/ │ │ └── db.config.js │ ├── middleware/ │ │ ├── auth.jwt.js │ │ ├── index.js │ │ └── verify.signup.js │ ├── models/ │ │ ├── index.js │ │ ├── role.model.js │ │ └── user.model.js │ ├── routes/ │ │ ├── auth.routes.js │ │ └── user.routes.js │ └── services/ │ ├── auth.service.js │ └── user.service.js ├── node_modules/ ├── .env ├── .gitignore ├── package.json ├── README.md ├── server.js └── yarn-lock 專案完成後所提供的 API 端點    Methods Urls Actions     POST /api/auth/signup 註冊新使用者帳號   POST /api/auth/signin 使用者帳號登入   GET /api/users/test/all 造訪公開內容區   GET /api/users/test/user 造訪｀一般使用者｀內容區   GET /api/users/test/moderator 造訪｀版主｀內容區   GET /api/users/test/admin 造訪一般｀管理者｀內容區    設置專案環境 $ node --version # 檢測環境已裝妥 node.js (若已安裝會顯示目前安裝的版本） v17.6.0 $ mkdir nodejs-webapi-jwt-postgre \u0026amp;\u0026amp; cd nodejs-webapi-jwt-postgre ＃ 建立一個專案目錄 $ npm init\t＃ 産生一專案設定檔 package.json $ touch server.js\t＃ 産生一個新檔案  package.json 預設的內容\n { \u0026#34;name\u0026#34;: \u0026#34;nodejs-webapi-jwt-postgres\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Node.js + exporess + JWT + PostgresSQL\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;server.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;keywords\u0026#34;: [ \u0026#34;node.js\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;jwt\u0026#34;, \u0026#34;postgres\u0026#34; ], \u0026#34;author\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; }  安裝相依套件\n $ yarn add express dotenv sequelize pg pg-hstore # 加入相依套件 $ yarn add --dev nodemon # 加入開發時期相依套件  建立 git 初始版本\n $ git init $ echo 'node_modules/' \u0026gt; .gitignore # 新增 git ignore 設定檔，並設定 node_modules/ 目錄不加入版控 $ echo 'yarn.lock' \u0026gt;\u0026gt; .gitignore $ git add . \u0026amp;\u0026amp; git commit -m \u0026quot;Initial commit\u0026quot; 建立 git 初始版本的資訊  設定專案啟動指令（如第七行的指令設定），當輸入 npm start 時系統自動以 node 來執行 server.js 程式，並即時監測 server.js 檔案有變化存檔時馬上重新啟動 node server.js 來執行該程式。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  { \u0026#34;name\u0026#34;: \u0026#34;nodejs-webapi-jwt-postgres\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Node.js + exporess + JWT + PostgresSQL\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;server.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;nodemon server.js\u0026#34;  }, \u0026#34;keywords\u0026#34;: [ \u0026#34;node.js\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;jwt\u0026#34;, \u0026#34;postgres\u0026#34; ], \u0026#34;author\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;dotenv\u0026#34;: \u0026#34;^16.0.1\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;^4.18.1\u0026#34;, \u0026#34;pg\u0026#34;: \u0026#34;^8.7.3\u0026#34;, \u0026#34;pg-hstore\u0026#34;: \u0026#34;^2.3.4\u0026#34;, \u0026#34;sequelize\u0026#34;: \u0026#34;^6.20.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;nodemon\u0026#34;: \u0026#34;^2.0.16\u0026#34; } }    在 server.js 中加入此行程式，並在 vscode Terminal 中輸入 npm start\n console.log(\u0026#34;Hi NodeJS...\u0026#34;)\t 顯示結果如下\n Hi NodeJS... 建立一個 Express 應用程式  使用以下程式覆蓋 server.js 檔案\n const express = require(\u0026#34;express\u0026#34;); const app = express(); app.get(\u0026#39;/\u0026#39;, function (req, res) { res.send(\u0026#39;Hello World\u0026#39;) }); app.get(\u0026#34;/api/test\u0026#34;, (req, res) =\u0026gt; { console.log(\u0026#34;test is successful\u0026#34;); res.send(\u0026#34;test is successful\u0026#34;); }); const PORT = process.env.PORT || 5000; app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); })  存檔後，開啟 瀏覽器，輸入 localhost:5000/api/test，在 vscode terminal 視窗中會顯示：\n Backend server is running on port 5000 test is successful 使用 Node.js 連結 PostgresSQL 若你還沒有安裝 PostgresSQL 可以參考這筆記先將資料庫管理系統備妥 使用 Docker 執行 PostgresSQL 與 pgAdmin\n在程式中使用了 sequelize 這個套件的功能來連結 Postgres 資料庫，直接透過 Sequelize constructor 來給定連結資料庫的參數，包含 “資料庫名稱“、”User Id\u0026quot;、\u0026ldquo;Password\u0026rdquo;、“Host Name\u0026quot;、\u0026ldquo;資料庫類別“(dialect)等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const express = require(\u0026#34;express\u0026#34;); const app = express(); const { Sequelize } = require(\u0026#39;sequelize\u0026#39;); const sequelize = new Sequelize(\u0026#39;testdb\u0026#39;, \u0026#39;postgres\u0026#39;, \u0026#39;12345\u0026#39;, { host: \u0026#39;localhost\u0026#39;, dialect: \u0026#39;postgres\u0026#39; }); try { sequelize.authenticate(); console.log(\u0026#39;Connection has been established successfully.\u0026#39;); } catch (error) { console.error(\u0026#39;Unable to connect to the database:\u0026#39;, error); } app.get(\u0026#34;/api/test\u0026#34;, (req, res) =\u0026gt; { console.log(\u0026#34;test is successful\u0026#34;); res.send(\u0026#34;test is successful\u0026#34;); }); const PORT = process.env.PORT || 5000; app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); })    存檔後，在 vscode terminal 視窗中會顯示：\n Connection has been established successfully. Backend server is running on port 5000  表示連結成功。\n 專案目錄 接下來要陸續完成相關程式，為使程式架構更顯清晰，專案目錄規劃如下：\n./專案目錄 ├── app/ ＃ 程式目錄 │ ├── config/ ＃ 設置連結 PostgresSQL 資料庫的參數 │ ├── middleware/ │ ├── models/ │ ├── routes/ │ └── services/ ＃ 業務邏輯 ├── node_modules/ ├── .env ＃ 程式中的相關“設定值” ├── .gitignore ├── package-lock.json ├── package.json ├── README.md ├── server.js # 主程式 └── yarn.loc 彈性管理參數值 管理程式中的“資料庫連結設定值” 在 app/config/目錄中新增一支 db.config.js 程式內容如下：\nmodule.exports = { HOST: \u0026#34;localhost\u0026#34;, // Host Name  USER: \u0026#34;postgres\u0026#34;, // User Name  PASSWORD: \u0026#34;12345\u0026#34;, // Password  DB: \u0026#34;testdb\u0026#34;, // Database Name  dialect: \u0026#34;postgres\u0026#34;, // 資料庫類別  pool: { max: 5, //　連結池中最大的 connection 數  min: 0, acquire: 30000, //　連結 Timeout 時間(毫秒)  idle: 10000 //　連結被釋放的 idle 時間(毫秒)  } }; 管理程式中的“設定值”  使用 dotenv 套件的功能來管理程式中相關的設定值\n  首先在專案根目錄下建立一個名為 \u0026ldquo;.env\u0026rdquo; 的檔案  JWT_SEC=Jason-Web-Token-Secret-key-jaslkdjfhjwkej01kd1954  在程式中先匯入 dotenv 套件(第1行），再“啟動它”(第2行），使用時透過 “process.env.JWT_SEC\u0026rdquo; 語法取得 JWT_SEC的設定值 第四行程式碼中的 process.env.PORT 為相同的原則可在 .evn 檔案中加入 PORT 的設定值調整  const dotenv = require(\u0026#34;dotenv\u0026#34;); dotenv.config(); // ... const PORT = process.env.PORT || 5000; // port 預設為 5000 ，並可以在 .env 檔案中進行客製化 （如：PORT＝5001） app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); }) 定義 Sequelize 模型 在 app/models/目錄中新增一支 user.model.js 程式內容如下，這個設定資料可搭合 sequelize.sync() 功能自動在 PostgresSQL 資料庫中建立一個名為 users 的資料表(table)，共有三個皆為 string 型態的欄位，分別為 username、email、password。\nmodule.exports = (sequelize, Sequelize) =\u0026gt; { const User = sequelize.define(\u0026#34;users\u0026#34;, { username: { type: Sequelize.STRING }, email: { type: Sequelize.STRING }, password: { type: Sequelize.STRING } }); return User; }; 同時在 initial Sequelize 後，我們不需要編寫 CRUD 函數，Sequelize 支持所有這些函數\n 建立一個新的 user: create(object) 透過 id 找到一個　user: findByPk(id) 透過 email 找到一個　user: findOne({ where: { email: \u0026hellip; } }) 取得所有使用者: findAll() 透過 username 找到符合的　user: findAll({ where: { username: \u0026hellip; } })  在 app/models/目錄中新增一支 role.model.js 程式內容如下\nmodule.exports = (sequelize, Sequelize) =\u0026gt; { const Role = sequelize.define(\u0026#34;roles\u0026#34;, { id: { type: Sequelize.INTEGER, primaryKey: true }, name: { type: Sequelize.STRING } }); return Role; }; 初始化 Sequelize 在 app/models/目錄中新增一支 index.js 程式內容如下\nconst config = require(\u0026#34;../config/db.config.js\u0026#34;); // 引入資料庫連結設定檔 const Sequelize = require(\u0026#34;sequelize\u0026#34;); const sequelize = new Sequelize( // 由資料庫連結設定檔的設定值來備置 Sequelize  config.DB, config.USER, config.PASSWORD, { host: config.HOST, dialect: config.dialect, operatorsAliases: false, pool: { max: config.pool.max, min: config.pool.min, acquire: config.pool.acquire, idle: config.pool.idle } } ); const db = {}; db.Sequelize = Sequelize; db.sequelize = sequelize; db.user = require(\u0026#34;../models/user.model.js\u0026#34;)(sequelize, Sequelize); db.role = require(\u0026#34;../models/role.model.js\u0026#34;)(sequelize, Sequelize); // 設定兩資料表的對應關係（多對多，所以會多出一個新的表 user_roles） // 一個使用者可能有多個角色 // 一個角色也可能有多個使用者 db.role.belongsToMany(db.user, { through: \u0026#34;user_roles\u0026#34;, foreignKey: \u0026#34;roleId\u0026#34;, otherKey: \u0026#34;userId\u0026#34; }); db.user.belongsToMany(db.role, { through: \u0026#34;user_roles\u0026#34;, foreignKey: \u0026#34;userId\u0026#34;, otherKey: \u0026#34;roleId\u0026#34; }); db.ROLES = [\u0026#34;user\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;moderator\u0026#34;]; module.exports = db; 執行程式産生資料表與資料 在 server.js 主程式中加入以下程式 const db = require(\u0026#34;./app/models\u0026#34;); // 引入 app/models/index.js 匯出的程式碼(即 sequelize model 定義檔) const Role = db.role; // 呼叫 sync function 將會依 model 定義內容産生資料表，force 參數值為 true 將會重建已存在的資料表 db.sequelize.sync({ force: true }).then(() =\u0026gt; { console.log(\u0026#39;Drop and Resync Database with { force: true }\u0026#39;); initial(); // 産生資料表後，呼叫 initial function 為 roles table 新增三筆初始資料 }).catch((err) =\u0026gt; { console.log(err); }); const PORT = process.env.PORT || 5000; // port 預設為 5000 ，並可以在 .env 檔案中進行客製化 （如：PORT＝5001） app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); }) // 為 roles table 新增三筆初始資料 function initial() { Role.create({ id: 1, name: \u0026#34;user\u0026#34; }); Role.create({ id: 2, name: \u0026#34;moderator\u0026#34; }); Role.create({ id: 3, name: \u0026#34;admin\u0026#34; }); } 執行程式産生資料表 程式執行成功後可以查看資料庫已順利産生三個資料表以及 roles table 中的三筆初始資料\n了解 Node.js 路由 建立 user.routes.js router file 新增 routes 目錄，在此目錄下新增 user.routes.js 檔案\n routes/user.routes.js\n const router = require(\u0026#34;express\u0026#34;).Router(); router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); module.exports = router; 在 server.js 程式中先匯入 \u0026ldquo;./app/routes/user.routes\u0026rdquo; 這個 router 設定檔，再透過 app.use 語法來使用這個 router(第9行)。\n1 2 3 4 5 6 7 8 9 10 11 12 13  const express = require(\u0026#34;express\u0026#34;); const app = express(); const dotenv = require(\u0026#34;dotenv\u0026#34;); const userRoute = require(\u0026#34;./app/routes/user.routes\u0026#34;);  dotenv.config(); app.use(\u0026#34;/api/users\u0026#34;, userRoute);  app.listen(process.env.PORT || 5000, ()=\u0026gt;{ console.log(\u0026#34;Backend server is running...\u0026#34;); });   開啟瀏覧器，輸入 http:5000/api/users/usertest，瀏覧器將呈現成功訊息\nuser test is successfull 為 routes/user.routes.js 再新增一個 post method\n1 2 3 4 5 6 7 8 9 10 11  const router = require(\u0026#34;express\u0026#34;).Router(); router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); router.post(\u0026#34;/userposttest\u0026#34;, (req, res) =\u0026gt; { const username = req.body.username; res.send(\u0026#34;your username is: \u0026#34; + username) })  module.exports = router;   使用 postman 來測試 post，結果回傳的是 Server Error，原因是 express 預設是不接受 json 格式的資料。\n在 server.js 程式中加入如第一行的設定\n1 2  app.use(express.json()); app.use(\u0026#34;/api/users\u0026#34;, userRoute);   設定完成後就可正常了\n建立 auth.routes.js router file 將使用者資料註冊和資用者帳號驗證的機制獨立在這個 route file 中，讓程式結構更清晰。內容如下：\n1 2 3 4 5 6 7 8 9 10  // routes/auth.routes.js const router = require(\u0026#34;express\u0026#34;).Router(); const authService = require(\u0026#34;../services/auth.service\u0026#34;);  // 帳號註冊 router.post(\u0026#34;/signup\u0026#34;, authService.signup); // 登入 router.post(\u0026#34;/signin\u0026#34;, authService.signin);  module.exports = router;    在 auth.routes.js route 程式中基於｀關注點分離原則｀把｀商業邏輯｀的部份再分離至 services 中。\n  在 ./app 目錄下新增 services 子目錄，並新增一支 auth.service.js 程式，將使用者註冊及登入邏輯放在這支 service 程式中，內容如下：\n  在這支程式中會使用到額外的套件，必須先進行安裝。$ yarn add crypto-js jsonwebtoken。其中 crypto-js 用來進行使用者密碼加解密(程式第2、15、50、51行)，而 jsonwebtoken 套件則是支援 Json Web Token 功能(程式第55行使用 jwt.sign 産生合法 Token)。\n // auth.service.js const db = require(\u0026quot;../models\u0026quot;); const CryptoJS = require(\u0026quot;crypto-js\u0026quot;); const jwt = require(\u0026quot;jsonwebtoken\u0026quot;); const User = db.user; const Role = db.role; const Op = db.Sequelize.Op; const signup = (req, res) =\u0026gt; { // Save User to Database User.create({ username: req.body.username, email: req.body.email, password: CryptoJS.AES.encrypt(req.body.password, process.env.PASS_SEC).toString(), }).then(user =\u0026gt; { if (req.body.roles) { Role.findAll({ where: { name: { [Op.or]: req.body.roles } } }).then(roles =\u0026gt; { user.setRoles(roles).then(() =\u0026gt; { res.send({ message: \u0026quot;User registered successfully!\u0026quot; }); }); }); } else { // user role = 1 user.setRoles([1]).then(() =\u0026gt; { res.send({ message: \u0026quot;User registered successfully!\u0026quot; }); }); } }).catch(err =\u0026gt; { res.status(500).send({ message: err.message }); }); }; const signin = (req, res) =\u0026gt; { User.findOne({ where: { username: req.body.username } }).then(user =\u0026gt; { if (!user) { return res.status(404).send({ message: \u0026quot;Wrong Credentials.\u0026quot; }); } const hashedPassword = CryptoJS.AES.decrypt(user.password, process.env.PASS_SEC); const orginalPassword = hashedPassword.toString(CryptoJS.enc.Utf8); orginalPassword !== req.body.password \u0026amp;\u0026amp; res.status(401).json(\u0026quot;Wrong Credentials\u0026quot;); const accessToken = jwt.sign( {id: user.id}, process.env.JWT_SEC, { expiresIn: \u0026quot;3d\u0026quot; } ); var authorities = []; user.getRoles().then(roles =\u0026gt; { for (let i = 0; i \u0026lt; roles.length; i++) { authorities.push(\u0026quot;ROLE_\u0026quot; + roles[i].name.toUpperCase()); } res.status(200).send({ id: user.id, username: user.username, email: user.email, roles: authorities, accessToken: accessToken }); }); }).catch(err =\u0026gt; { res.status(500).send({ message: err.message }); }); }; module.exports = { signup, signin };  在 server.js 引用這個新的 router\n 1 2 3 4 5 6 7 8 9 10 11 12  // ... const userRoute = require(\u0026#34;./app/routes/user.routes\u0026#34;); const authRoute = require(\u0026#34;./app/routes/auth.routes\u0026#34;); app.use(express.json()); app.use(\u0026#34;/api/users\u0026#34;, userRoute); app.use(\u0026#34;/api/auth\u0026#34;, authRoute);  const PORT = process.env.PORT || 5000; // port 預設為 5000 ，並可以在 .env 檔案中進行客製化 （如：PORT＝5001） app.listen(PORT, () =\u0026gt; { console.log(`Backend server is running on port ${PORT}`); })   測試使用者註冊及登入功能 使用 postman 進行使用者註冊功能測試\n 註冊成功後，在資料庫中已新增一筆使用者資料\n 使用 postman 進行使用者登入功能測試\n 登入成功後會回傳一個 Token\n 在 Node.js 中使用 JWT 來進行 Token-Based 的使用者授權驗證 使用 jsonwebtoken套件可以實現 Token-base 的身份驗證與授權讓我們的 API 程式更安全\nJWT 實作的過程大致可以分成三個部分:\n 在登入成功後産生合法的 JWT Token 每次收到 request 時驗證是否為合法有效的 JWT Token 在特定 API Endpoint 上驗證是否帶有 “合法有效的 JWT Token”，以達到權限管理的需求  産生合法 JWT 在登入證驗中加入産生 Token 的邏輯，在檢核使用者輸入的密碼正確後，將 User ID (_id這個內部 Key)這個屬性值透過 sign function 來産生 access token，並回傳給前端。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); // 匯入 JsonWebToken套件 //...  const accessToken = jwt.sign({  id: user._id }, process.env.JWT_SEC,  { expiresIn: \u0026#34;3d\u0026#34; } ); var authorities = []; user.getRoles().then(roles =\u0026gt; { for (let i = 0; i \u0026lt; roles.length; i++) { authorities.push(\u0026#34;ROLE_\u0026#34; + roles[i].name.toUpperCase()); } res.status(200).send({ id: user.id, username: user.username, email: user.email, roles: authorities, accessToken: accessToken }); });    encrypt function 參數除了要加密的字串外，需要一個加密 Key，為彈性起見，把它寫在 .env 檔案中 (PASS_SEC)\n 1 2 3  # .env JWT_SEC=Jason-Web-Token-Secret-key-jaslkdjfhjwkej01kd1954 PASS_SEC=cal   使用 JWT 來驗證 Token 在前端取得合法的 JWT Token後，來看看當使用者在呼叫其他 API 時一併回傳的 Token　如何在 server 端來進行驗證。\n首先，我們要在 app/ 目錄下新增一個 middleware/ 的子目錄，並在其中新增一個名為 auth.jwt.js 的 express Middleware，程式內容如下\n在程式第14行中使用 jsonwebtoken 套件的 verify function 就是用來驗證 request 中的 Token 是否為合法 Token。驗證時一樣需要｀加密 Key｀來當參數。\n在這程式中除了驗證 request 中是否有合法的 Token 外，還有其他授權檢核的邏輯：驗證是否為管理者、驗證是否為版主、驗證是否為管理者或是版主等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const db = require(\u0026#34;../models\u0026#34;); const User = db.user; const verifyToken = (req, res, next) =\u0026gt; {  let authHeader = req.headers.authorization; if (!authHeader) { return res.status(403).send({ message: \u0026#34;Your are not authenticated!\u0026#34; }); } const token = authHeader.split(\u0026#34; \u0026#34;)[1]; jwt.verify(token, process.env.JWT_SEC, (err, decoded) =\u0026gt; {  if (err) { return res.status(401).send({ message: \u0026#34;Token is not valid!\u0026#34; }); } req.userId = decoded.id; next(); }); }; isAdmin = (req, res, next) =\u0026gt; {  User.findByPk(req.userId).then(user =\u0026gt; { user.getRoles().then(roles =\u0026gt; { for (let i = 0; i \u0026lt; roles.length; i++) { if (roles[i].name === \u0026#34;admin\u0026#34;) { next(); return; } } res.status(403).send({ message: \u0026#34;Require Admin Role!\u0026#34; }); return; }); }); }; const isModerator = (req, res, next) =\u0026gt; {  User.findByPk(req.userId).then(user =\u0026gt; { user.getRoles().then(roles =\u0026gt; { for (let i = 0; i \u0026lt; roles.length; i++) { if (roles[i].name === \u0026#34;moderator\u0026#34;) { next(); return; } } res.status(403).send({ message: \u0026#34;Require Moderator Role!\u0026#34; }); }); }); }; const isModeratorOrAdmin = (req, res, next) =\u0026gt; {  User.findByPk(req.userId).then(user =\u0026gt; { user.getRoles().then(roles =\u0026gt; { for (let i = 0; i \u0026lt; roles.length; i++) { if (roles[i].name === \u0026#34;moderator\u0026#34;) { next(); return; } if (roles[i].name === \u0026#34;admin\u0026#34;) { next(); return; } } res.status(403).send({ message: \u0026#34;Require Moderator or Admin Role!\u0026#34; }); }); }); }; const authJwt = { verifyToken: verifyToken, isAdmin: isAdmin, isModerator: isModerator, isModeratorOrAdmin: isModeratorOrAdmin }; module.exports = authJwt;   為簡化 middleware 使用時的匯入路徑，我們在　middleware/ 的子目錄，再新增一個名為 index.js 的程式，內容如下\nconst authJwt = require(\u0026#34;./auth.jwt\u0026#34;); module.exports = { authJwt }; 在特定 API Endpoint 上驗證是否帶有 “合法有效的 JWT Token” 在前面完成了驗證 Token 的 Middleware 後，我們來看看如何在 router 中套用這些 middleware， 打開　routers/userroutes.js 程式檔，並將內容修改如下：\n在程式第九行 post 的第二個參數，加入呼叫 authJwt.verifyToken 這個 middleware 驗證 token 的 function。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const router = require(\u0026#34;express\u0026#34;).Router(); const { authJwt } = require(\u0026#34;../middleware\u0026#34;);  router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); router.post(\u0026#34;/userposttest\u0026#34;, authJwt.verifyToken,  (req, res) =\u0026gt; { const username = req.body.username; res.send(\u0026#34;your username is: \u0026#34; + username) } ) module.exports = router;   再次執行前面已執行過的 Postman 的 postusertest 這個 request，結果這次會回傳 ｀未授權｀的警告訊息。\n將登入成功時回傳的 token，加入到 Header 中，再執行一次 postusertest 即可執行成功。\n 若送出 request 中未包含 Token 則會回傳“未被授權執行本功能”。\n  若送出 request 中包含的是不合法的 Token 則會回傳“Token不合法“。\n 使用 middleware 來進行檢核使用者角色 將 app/routes/user.routes.js 內容修改成如下：\nconst router = require(\u0026#34;express\u0026#34;).Router(); const { authJwt } = require(\u0026#34;../middleware\u0026#34;); const userService = require(\u0026#34;../services/user.service\u0026#34;); // router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { // res.send(\u0026#34;user test is successful\u0026#34;); // });  // router.post(\u0026#34;/userposttest\u0026#34;, // authJwt.verifyToken, // (req, res) =\u0026gt; { // const username = req.body.username; // res.send(\u0026#34;your username is: \u0026#34; + username) // } // )  router.get(\u0026#34;/test/all\u0026#34;, userService.allAccess); router.get( \u0026#34;/test/user\u0026#34;, [authJwt.verifyToken], userService.userBoard ); router.get( \u0026#34;/test/moderator\u0026#34;, [authJwt.verifyToken, authJwt.isModerator], userService.moderatorBoard ); router.get( \u0026#34;/test/admin\u0026#34;, [authJwt.verifyToken, authJwt.isAdmin], userService.adminBoard ); module.exports = router;  上述程式中可以看到不同 api 端點由不同角色使用者可以造訪，\u0026ldquo;api/users/test/all\u0026rdquo; 是個開放式的端點所有人皆可造訪、\u0026ldquo;api/users/test/user\u0026rdquo; 是所有已註冊的｀使用者｀可造訪、\u0026ldquo;api/users/test/moderator\u0026rdquo; 是角色為｀版主｀的使用者可造訪、 \u0026ldquo;api/users/test/admin\u0026rdquo; 是角色為｀管理者｀的｀使用皆｀可造訪\n 在 app/services/ 目錄下新增一支 service user.service.js，內容如下\nconst allAccess = (req, res) =\u0026gt; { res.status(200).send(\u0026#34;Public Content.\u0026#34;); }; const userBoard = (req, res) =\u0026gt; { res.status(200).send(\u0026#34;User Content.\u0026#34;); }; const adminBoard = (req, res) =\u0026gt; { res.status(200).send(\u0026#34;Admin Content.\u0026#34;); }; const moderatorBoard = (req, res) =\u0026gt; { res.status(200).send(\u0026#34;Moderator Content.\u0026#34;); }; module.exports = { allAccess, userBoard, adminBoard, moderatorBoard }; 註冊一個新使用者且具備有二個角色：moderator 及 admin\n打開瀏覽器，輸入　http://localhost:5000/api/users/test/all，可以發現這個開放式的端點任何人皆可造訪(未註冊的人也可以)。\n在瀏覽器，重新輸入　http://localhost:5000/api/users/test/user，發現這個端點未註冊的人不能造訪。 打開 Postman 先使用已註冊的使用者帳號登入，取得 token\n再將這個 token (使表使用者是 tom) 加入 request authorization header 中，再次造訪 http://localhost:5000/api/users/test/user，結果是可正常造訪\n再以相同 token (代表使用者是 tom) 造訪 http://localhost:5000/api/users/test/moderator ，結果回傳 \u0026ldquo;須為版主角色者\u0026quot;｀\u0026quot;才能造訪。 改用新註冊的使用者 Jeff 來重新登入，並取得回傳的 token\n改採此 token (代表使用者是 jeff) 造訪 http://localhost:5000/api/users/test/moderator ，結果顯示可正常造訪。\n使用 middleware 來進行其他資料檢核 程式至此已經可以透過 JWT 相關功能查核使用者是否已正確登入系統、是以何種身份（角色）登入的。\n最後要再呈現的是使用 middleware 功能來查核其他資料正確性，如：使用者註冊時是否使用了相同的使用者名稱？是否 email 已經被其他使用者使用過？\n在 app/middleware 目錄下新增 verify.signup.js，內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  const db = require(\u0026#34;../models\u0026#34;); const ROLES = db.ROLES; const User = db.user; checkDuplicateUsernameOrEmail = (req, res, next) =\u0026gt; {  // Username  User.findOne({ where: { username: req.body.username } }).then(user =\u0026gt; { if (user) { res.status(400).send({ message: \u0026#34;Failed! Username is already in use!\u0026#34; }); return; } // Email  User.findOne({ where: { email: req.body.email } }).then(user =\u0026gt; { if (user) { res.status(400).send({ message: \u0026#34;Failed! Email is already in use!\u0026#34; }); return; } next(); }); }); }; checkRolesExisted = (req, res, next) =\u0026gt; {  if (req.body.roles) { for (let i = 0; i \u0026lt; req.body.roles.length; i++) { if (!ROLES.includes(req.body.roles[i])) { res.status(400).send({ message: \u0026#34;Failed! Role does not exist = \u0026#34; + req.body.roles[i] }); return; } } } next(); }; const verifySignUp = { checkDuplicateUsernameOrEmail: checkDuplicateUsernameOrEmail, checkRolesExisted: checkRolesExisted }; module.exports = verifySignUp;   修改 app/middleware/index.js 檔案如下：\n1 2 3 4 5 6 7  const authJwt = require(\u0026#34;./auth.jwt\u0026#34;); const verifySignUp = require(\u0026#34;./verify.signup\u0026#34;);  module.exports = { authJwt, verifySignUp };   將新的 middleware　功能放入到 SignUp 功能中。 打開　app/routes/auth.routes.js 程式檔，修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const router = require(\u0026#34;express\u0026#34;).Router(); const authService = require(\u0026#34;../services/auth.service\u0026#34;); const { verifySignUp } = require(\u0026#34;../middleware\u0026#34;) // 帳號註冊 router.post(\u0026#34;/signup\u0026#34;, [ verifySignUp.checkDuplicateUsernameOrEmail, verifySignUp.checkRolesExisted ], authService.signup); // 登入 router.post(\u0026#34;/signin\u0026#34;, authService.signin); module.exports = router;   先使用已經被註冊過的 EMail來進行測試，結果回傳 EMail 已被使用。\n再使用已被註冊過的 UserName 來進行註冊，結果回傳：\ncors 這個後端專案預計要給前端 Angular 來使用，跨域存取問題就用 cors 設定來解決。\n先安裝 cors 套件\n$ yarn add cors yarn add v1.22.19 [1/4] Resolving packages... [2/4] Fetching packages... [3/4] Linking dependencies... [4/4] Building fresh packages... success Saved lockfile. success Saved 2 new dependencies. info Direct dependencies └─ cors@2.8.5 info All dependencies ├─ cors@2.8.5 └─ object-assign@4.1.1 Done in 0.86s. 打開 server.js，修改如下：\n1 2 3 4 5 6 7 8 9 10 11  const express = require(\u0026#34;express\u0026#34;); const dotenv = require(\u0026#34;dotenv\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); dotenv.config(); const app = express(); var corsOptions = { origin: \u0026#34;http://localhost:4200\u0026#34; }; app.use(cors(corsOptions)); //...   ","permalink":"https://calvinegs.github.io/posts/nodejs-restapi-postgres/","summary":"github Source code\nTechnology:\n NodeJs 17.6.0 Express 4.17.1 cors 2.8.5 crypto-js 4.1.1 # 加解密套件 jsonwebtoken 8.5.1 # Json Web Token 的功能套件 Sequelize 6.20.1 # ORM 套件 pg 8.7.3 # PostgreSQL client for Node.js pg-hstore 2.3.4 # serializing and deserializing JSON data to hstore format PostgreSQL 14.3 # 使用的資料庫  專案完成後的檔案結構 ./專案目錄 ├── app/ │ ├── config/ │ │ └── db.config.js │ ├── middleware/ │ │ ├── auth.jwt.js │ │ ├── index.","title":"使用 Node.js + express + postgres 建立一個後端服務 REST API"},{"content":"github Source code\n在之前的筆記中 使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api 已仔細的紀錄如何使用 .Net 6.0 來建置一個支援 JWT ＆ Identity framework 的 WebApi 網站應用程式，在該篇筆記中所使用的資料庫是 MS SQL 2019，而這篇筆記裡將紀錄如何將它改成支援 PostgresSQL。\n若你還沒有安裝 PostgresSQL 可以參考這筆記先將資料庫管理系統備妥 使用 Docker 執行 PostgresSQL 與 pgAdmin\n專案完成後的檔案結構 ./專案目錄 ├── .config/ │ └── dotnet-tools.json ├── .vscode/ │ ├── launch.js │ └── tasks.json ├── Controller/ │ ├── AuthenticateController.cs │ ├── TodoController.cs │ └── WeatherForecast.cs ├── Data/ │ └── ApiDbContext.cs ├── Migrations/ ├── Models/ │ ├── AuthenticateData.cs │ └── ItemData.cs ├── obj/ ├── Properties/ │ └── launchSettings.json ├── .gitignore ├── appsettings.Development.json ├── appsettings.json ├── dotnet6-webapi-jwt.csproj ├── global.json ├── Program.cs ├── README.md └── WeatherForecast.cs 專案完成後所提供的 API 端點    Methods Urls Actions     POST /api/Authenticate/login 註冊新使用者帳號   POST /api/Authenticate/register 使用者帳號登入   POST /api/Authenticate/register-admin 管理者帳號登入   GET /api/Todos get all Todos   POST /api/Todos add New Todo   GET /api/Todos/:id get Todo by id   PUT /api/todos/:id update Todo by id   DELETE /api/todos/:id remove Todo by id    git clone Example Code 先 git clone ｀使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api。並使用 Microsoft Identity 框架來存儲使用者和角色等資料｀ 這篇筆記的 Source code\n$ git clone https://github.com/calvinegs/dotnet6-webapi-jwt.git dotnet6-webapi-postgress restore 相依的套件 $ cd dotnet6-webapi-postgress $ dotnet restore 正在判斷要還原的專案... 已還原 /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj (1.12 sec 內)。 安裝及使用 Postgres 相關套件 $ dotnet remove package Microsoft.EntityFrameworkCore.SqlServer info : 正在從專案 \u0026#39;/home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj\u0026#39; 中移除套件 \u0026#39;Microsoft.EntityFrameworkCore.SqlServer\u0026#39; 的 PackageReference。 $ dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL 正在判斷要還原的專案... Writing /tmp/tmpU1vZfj.tmp info : 正在將套件 \u0026#39;Npgsql.EntityFrameworkCore.PostgreSQL\u0026#39; 的 PackageReference 新增至專案 \u0026#39;/home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj\u0026#39;。 info : GET https://api.nuget.org/v3/registration5-gz-semver2/npgsql.entityframeworkcore.postgresql/index.json info : OK https://api.nuget.org/v3/registration5-gz-semver2/npgsql.entityframeworkcore.postgresql/index.json 858 毫秒 info : 正在還原 /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj 的封裝... info : 套件 \u0026#39;Npgsql.EntityFrameworkCore.PostgreSQL\u0026#39; 與專案 \u0026#39;/home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj\u0026#39; 中的所有架構相容。 info : 已將套件 \u0026#39;Npgsql.EntityFrameworkCore.PostgreSQL\u0026#39; 版本 \u0026#39;6.0.4\u0026#39; 的 PackageReference 新增至檔案 \u0026#39;/home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj\u0026#39;。 info : 正在將資產檔案寫入磁碟。路徑: /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/obj/project.assets.json log : 已還原 /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj (371 ms 內)。 使用 VSCode 開啟專案 $ code . 開啟 dotnet6-webapi-jwt.csproj 專案檔可發現已採用 ｀Npgsql.EntityFrameworkCore.PostgreSQL｀套件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;RootNamespace\u0026gt;dotnet6_webapi_jwt\u0026lt;/RootNamespace\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Identity.EntityFrameworkCore\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Design\u0026#34; Version=\u0026#34;6.0.5\u0026#34;\u0026gt; \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;6.0.5\u0026#34;\u0026gt; \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Npgsql.EntityFrameworkCore.PostgreSQL\u0026#34; Version=\u0026#34;6.0.4\u0026#34; /\u0026gt;  \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;6.2.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;   修改 DbContext 參數 修改 Program.cs 中 DbContext 的參數設定\nbuilder.Services.AddDbContext\u0026lt;ApiDbContext\u0026gt;( options =\u0026gt; options.UseSqlServer( _configuration.GetConnectionString(\u0026#34;ConnStr\u0026#34;) ) ); 改成\nbuilder.Services.AddDbContext\u0026lt;ApiDbContext\u0026gt;( options =\u0026gt; options.UseNpgsql( _configuration.GetConnectionString(\u0026#34;ConnStr\u0026#34;) ) ); 修改 appsettings.json 中的 Conection String \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34; }, 改成\n\u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;User ID =docker;Password=docker;Server=localhost;Port=5432;Database=pg_testdb; Integrated Security=true;Pooling=true\u0026#34; }, 將原有專案的 Migrations 子目錄移除 $ rm -f ./Migrations $ dotnet build # 重新建置程式 Microsoft (R) Build Engine for .NET 17.2.0+41abc5629 版 Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。 正在判斷要還原的專案... 所有專案都在最新狀態，可進行還原。 dotnet6-webapi-jwt -\u0026gt; /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/bin/Debug/net6.0/dotnet6-webapi-jwt.dll 建置成功。 0 個警告 0 個錯誤 經過時間 00:00:02.21 新增一個資料遷移 $ dotnet ef Migrations add \u0026#34;Initial Migrations\u0026#34; Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 6.0.5 initialized \u0026#39;ApiDbContext\u0026#39; using provider \u0026#39;Npgsql.EntityFrameworkCore.PostgreSQL:6.0.4+6cb649128e3e7aa8eddd77dfa75b34bad51e6e94\u0026#39; with options: None Done. To undo this action, use \u0026#39;ef migrations remove\u0026#39; 將資料遷移更新至資料庫 $ dotnet ef database update ![2022-06-02 18-07-55](https://user-images.githubusercontent.com/21993717/171607590-cd6e06ad-7ae7-47d2-bfba-afe9aab0d11e.png) 資料遷移成功後會在資料庫中自動産生 Identity Framework 所使用的資料表，而自定的 Model 也會一併産生新資料表\n執行結果 ","permalink":"https://calvinegs.github.io/posts/dotnet6-webapi-jwt-postgres/","summary":"github Source code\n在之前的筆記中 使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api 已仔細的紀錄如何使用 .Net 6.0 來建置一個支援 JWT ＆ Identity framework 的 WebApi 網站應用程式，在該篇筆記中所使用的資料庫是 MS SQL 2019，而這篇筆記裡將紀錄如何將它改成支援 PostgresSQL。\n若你還沒有安裝 PostgresSQL 可以參考這筆記先將資料庫管理系統備妥 使用 Docker 執行 PostgresSQL 與 pgAdmin\n專案完成後的檔案結構 ./專案目錄 ├── .config/ │ └── dotnet-tools.json ├── .vscode/ │ ├── launch.js │ └── tasks.json ├── Controller/ │ ├── AuthenticateController.cs │ ├── TodoController.cs │ └── WeatherForecast.cs ├── Data/ │ └── ApiDbContext.cs ├── Migrations/ ├── Models/ │ ├── AuthenticateData.","title":"使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api。並使用 Microsoft Identity 框架來存儲使用者和角色等資料（使用 PostgresSQL）"},{"content":"github Source code\n使用 Docker 執行 PostgresSQL 與 pgAdmin 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 postgresSQL 及其管理工具 pgAdmin。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.16 API version: 1.41 Go version: go1.17.10 Git commit: aa7e414 Built: Thu May 12 09:17:23 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.16 API version: 1.41 (minimum version 1.12) Go version: go1.17.10 Git commit: f756502 Built: Thu May 12 09:15:28 2022 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.4 GitCommit: 212e8b6fa2f44b9c21b2798135fc6fb7c53efc16 runc: Version: 1.1.1 GitCommit: v1.1.1-0-g52de29d docker-init: Version: 0.19.0 GitCommit: de40ad0 檢查是否已安裝了 docker compose $ docker compose version Docker Compose version v2.5.0 建置專案 目錄結構 $ mkdir postgres-pgadmin \u0026amp;\u0026amp; cd postgres-pgadmin $ touch docker-compose.yml README.md $ mkdir pgadmin pgdbdata sql $ touch ./pgadmin/pgdb_servers.json $ touch ./sql/initdb.sql ./postgres-pgadmin ├── docker-compose.yml ├── README.md ├── pgadmin │ └── pgdb_servers.json ├── pgdbdata └── sql └── initdb.sql 建立 docker-compose.yml 在這個 compse command file 中分別建立了二個 services，用來啟動 postgres 與 pgadmin。指令與說明如下\nversion: \u0026#39;3\u0026#39; services: postgres: container_name: pg_server # 自定 container 名稱 image: postgres:14.3  # 使用 postgres@14.3 docker image 檔 restart: always ports: - \u0026#34;5432:5432\u0026#34; environment: - POSTGRES_USER=docker  # 建立一個 postgres user  - POSTGRES_PASSWORD=docker # 這個 user 的密碼 volumes: # 將 local 的 ./sql/initdb.sql 掛載到 postgres docker /docker-entrypoint-initdb.d/init.sql，目的是建立一個名為 pg_testdb 資料庫 - ./sql/initdb.sql:/docker-entrypoint-initdb.d/init.sql  healthcheck: test: [\u0026#34;CMD-SHELL\u0026#34;, \u0026#34;pg_isready -U docker\u0026#34;] interval: 10s timeout: 5s retries: 5 pgadmin: container_name: pg_admin  # 自定 container 名稱 image: dpage/pgadmin4:6.9  # 使用 pgadmin4＠6.9 docker image 檔 depends_on: postgres: condition: service_healthy environment: PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL:-user@domain.org} PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD:-docker} PGADMIN_CONFIG_SERVER_MODE: \u0026#39;False\u0026#39; PGADMIN_SERVER_JSON_FILE: \u0026#39;/config/pgdb_servers.json\u0026#39; # 使用這個 Json 檔案來設定 pgadmin  volumes: - ./pgadmin:/config  # 將 local 的 ./pgadmin 目錄掛載到 pgadmin4 docker 中 ports: - \u0026#34;5431:80\u0026#34; # 將 pgadmin4 docker 中的 80 Port 映射到 local 端的 5431 Port restart: always 建立 pgdb_servers.json 這用檔案的用途是給 pgAdmin docker 啟動時設置環境用。\n{ \u0026#34;Servers\u0026#34;: { \u0026#34;1\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;pg-test\u0026#34;, \u0026#34;Group\u0026#34;: \u0026#34;Servers\u0026#34;, \u0026#34;Port\u0026#34;: 5432, \u0026#34;Username\u0026#34;: \u0026#34;docker\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;postgres\u0026#34;, \u0026#34;SSLMode\u0026#34;: \u0026#34;prefer\u0026#34;, \u0026#34;MaintenanceDB\u0026#34;: \u0026#34;postgres\u0026#34; } } } 建立 initdb.sql 這用檔案的用途是給 postgres docker 啟動時透過 volumn 指令掛戴將此 SQL 檔案映射到 docker 內的 /docker-entrypoint-initdb.d/init.sql 檔，使得 docker initial 時會自動建立一個名為 pg_testdb 的資料庫。\nCREATE DATABASE pg_testdb; 執行 docker compose 上述的目錄與檔案內容準備完成後，在與 docker-compose.yml 的相同目錄中執行 docker compose up來啟動這個二 Services，啟動成功後開啟另一個 terminal 使用 ｀$ docker ps｀ 指令查看容器啟動狀況\n$ docker compose up # ... pg_server | 2022-06-01 13:39:11.333 UTC [1] LOG: listening on IPv4 address \u0026#34;0.0.0.0\u0026#34;, port 5432 pg_server | 2022-06-01 13:39:11.333 UTC [1] LOG: listening on IPv6 address \u0026#34;::\u0026#34;, port 5432 pg_server | 2022-06-01 13:39:11.335 UTC [1] LOG: listening on Unix socket \u0026#34;/var/run/postgresql/.s.PGSQL.5432\u0026#34; pg_server | 2022-06-01 13:39:11.340 UTC [64] LOG: database system was shut down at 2022-06-01 13:39:11 UTC pg_server | 2022-06-01 13:39:11.346 UTC [1] LOG: database system is ready to accept connections pg_admin | NOTE: Configuring authentication for DESKTOP mode. pg_admin | ---------- pg_admin | Loading servers with: pg_admin | User: pgadmin4@pgadmin.org pg_admin | SQLite pgAdmin config: /var/lib/pgadmin/pgadmin4.db pg_admin | ---------- pg_admin | Added 0 Server Group(s) and 1 Server(s). pg_admin | [2022-06-01 13:39:48 +0000] [1] [INFO] Starting gunicorn 20.1.0 pg_admin | [2022-06-01 13:39:48 +0000] [1] [INFO] Listening at: http://[::]:80 (1) pg_admin | [2022-06-01 13:39:48 +0000] [1] [INFO] Using worker: gthread pg_admin | [2022-06-01 13:39:48 +0000] [91] [INFO] Booting worker with pid: 91  查看 docker 執行的情況\n $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 11bb5b91463c dpage/pgadmin4:6.9 \u0026#34;/entrypoint.sh\u0026#34; 17 seconds ago Up 5 seconds 443/tcp, 0.0.0.0:5431-\u0026gt;80/tcp, :::5431-\u0026gt;80/tcp pg_admin 1dbca769db67 postgres:14.3 \u0026#34;docker-entrypoint.s…\u0026#34; 17 seconds ago Up 16 seconds (healthy) 0.0.0.0:5432-\u0026gt;5432/tcp, :::5432-\u0026gt;5432/tcp pg_serve 使用 PgAdmin 連結到 Postgres DB 打開瀏覧器輸入： localhost:5431\n第一次開啟時要先設定 pgAdmin 的密碼，輸入 pgAdmin 的密碼後按下 OK 按鈕。\n接下來會顯示要連結到 pg-test 資料庫的使用者(本例中是 docker)的密碼輸入畫面，輸入密碼後按下 OK 按鈕。\n輸入密碼完成後，即可顯示資料庫的相關資訊：\n有關 pgadmin 更詳細資訊請 打開\n使用 dbeaver-cd 連結到 Postgres DB 開啟 dbeaver-cd 程式，按下 ｀New Database Connection` 按鈕\n開始設置連線資料設定，選擇資料庫 - PostgreSQL 按下 ｀Next`\n輸入相關資訊，如 Database name、Username、Password\u0026hellip;等，按下｀Test Connectiono\u0026hellip;｀來測試設定是否成功。\n設定無誤會顯示 ｀已連結的訊息視窗｀。按下｀OK｀回到設置畫面，再按下 \u0026ldquo;Finish\u0026rdquo; 即可進入 DBeaver 資料庫管理功能中。\n資料庫的實際檔案存放在 Local 的 ./pgdbdata 目錄中 使用作業系統管理者權限來查看此目錄\n$ sudo ls -al ./pgdbdata/ [sudo] egs 的密碼： 總用量 132 drwx------ 19 systemd-coredump egs 4096 六 2 11:26 . drwxrwxr-x 6 egs egs 4096 六 2 10:23 .. drwx------ 7 systemd-coredump systemd-coredump 4096 六 2 10:27 base drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:28 global drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_commit_ts drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_dynshmem -rw------- 1 systemd-coredump systemd-coredump 4821 六 2 10:27 pg_hba.conf -rw------- 1 systemd-coredump systemd-coredump 1636 六 2 10:27 pg_ident.conf drwx------ 4 systemd-coredump systemd-coredump 4096 六 2 11:26 pg_logical drwx------ 4 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_multixact drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_notify drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_replslot drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_serial drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_snapshots drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 11:26 pg_stat drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 11:26 pg_stat_tmp drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_subtrans drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_tblspc drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_twophase -rw------- 1 systemd-coredump systemd-coredump 3 六 2 10:27 PG_VERSION drwx------ 3 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_wal drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_xact -rw------- 1 systemd-coredump systemd-coredump 88 六 2 10:27 postgresql.auto.conf -rw------- 1 systemd-coredump systemd-coredump 28835 六 2 10:27 postgresql.conf -rw------- 1 systemd-coredump systemd-coredump 36 六 2 10:27 postmaster.opts ","permalink":"https://calvinegs.github.io/posts/docker-postgres-pgadmin/","summary":"github Source code\n使用 Docker 執行 PostgresSQL 與 pgAdmin 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 postgresSQL 及其管理工具 pgAdmin。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.16 API version: 1.41 Go version: go1.17.10 Git commit: aa7e414 Built: Thu May 12 09:17:23 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.16 API version: 1.41 (minimum version 1.12) Go version: go1.","title":"使用 Docker 執行 PostgresSQL 與 pgAdmin"},{"content":"github Source code\n本文將記錄如何一步步從無到有使用 Angular 13 Reactive Form 表單驗證 與 Bootstrap 建立 一個使用者資料註冊的表單　功能，在這個表單中當按下送出時會自動檢核使用者所輸入的資料是否合乎程式中所設定的檢核邏輯，並顯示合適的訊息反應給使用者。其中將會使用到下列技術:\n Angular CLI Bootstrap 4 \u0026amp; 5 (UI Framework) Angular Reactive Form Custome Validator  建立新專案 $ ng version Angular CLI: 13.3.6 Node: 16.14.0 Package Manager: npm 8.3.1 OS: linux x64 Angular: 13.3.9 ... animations, common, compiler, compiler-cli, core, forms ... platform-browser, platform-browser-dynamic, router Package Version --------------------------------------------------------- @angular-devkit/architect 0.1303.6 @angular-devkit/build-angular 13.3.6 @angular-devkit/core 13.3.6 @angular-devkit/schematics 13.3.6 @angular/cli 13.3.6 @schematics/angular 13.3.6 rxjs 7.5.5 typescript 4.6.4 $ ng new form-validation # 使用 ng cli 來建立專案 ? Would you like to add Angular routing? (y/N) N # 選擇 N 不使用 routing 功能 ? Which stylesheet format would you like to use? # 選擇 SCSS  CSS ❯ SCSS [ https://sass-lang.com/documentation/syntax#scss ] Sass [ https://sass-lang.com/documentation/syntax#the-indented-syntax ] Less [ http://lesscss.org ] ... Packages installed successfully. Successfully initialized git. $ cd form-validation/ $ ls -al 總用量 844 drwxrwxr-x 6 egs egs 4096 五 28 15:08 . drwxrwxr-x 3 egs egs 4096 五 28 15:07 .. -rw-rw-r-- 1 egs egs 3261 五 28 15:07 angular.json -rw-rw-r-- 1 egs egs 600 五 28 15:07 .browserslistrc -rw-rw-r-- 1 egs egs 274 五 28 15:07 .editorconfig drwxrwxr-x 8 egs egs 4096 五 28 15:08 .git -rw-rw-r-- 1 egs egs 548 五 28 15:07 .gitignore -rw-rw-r-- 1 egs egs 1432 五 28 15:07 karma.conf.js drwxrwxr-x 599 egs egs 20480 五 28 15:08 node_modules -rw-rw-r-- 1 egs egs 1078 五 28 15:07 package.json -rw-rw-r-- 1 egs egs 778846 五 28 15:08 package-lock.json -rw-rw-r-- 1 egs egs 1068 五 28 15:07 README.md drwxrwxr-x 5 egs egs 4096 五 28 15:07 src -rw-rw-r-- 1 egs egs 287 五 28 15:07 tsconfig.app.json -rw-rw-r-- 1 egs egs 863 五 28 15:07 tsconfig.json -rw-rw-r-- 1 egs egs 333 五 28 15:07 tsconfig.spec.json drwxrwxr-x 2 egs egs 4096 五 28 15:07 .vscode $ code .　# 打開 vscode 設置專案 匯入 ReactiveFormModule 模組 開啟 src/app/app.module.ts 並由 @angular/forms 匯入 ReactiveFormModule\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, ReactiveFormsModule  ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }   使用 Bootstrap 方法一: 開啟 src/index.html 在  加入 link tag\n 使用 bootstrap 4 時使用第 9 行匯入語法 使用 bootstrap 5 時使用第 10 行匯入語法　上述語法二擇一  由於 bootstrap 4 \u0026amp; 5 兩個版本語法有相異處，在範例中將展示不同的寫法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;FormValidation\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-zCbKRCUGaJDkqS1kPbPd7TveP5iyJE0EjAuZQTgFLD2ylzuqKfdKlfG/eSrtxUkn\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   方法二: 使用 npm install 來進行安裝\n1.1 先使用 npm install 將 bootstrap 安裝到專案的 node_modules 目錄下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # 上述版本二擇一 $ npm install bootstarp@4.6.1 npm WARN deprecated popper.js@1.16.1: You can find the new Popper v2 at @popperjs/core, this package is dedicated to the legacy v1 added 3 packages, and audited 928 packages in 1s 108 packages are looking for funding run `npm fund` for details found 0 vulnerabilities  $ npm install bootstrap@5.1.3 added 2 packages, and audited 927 packages in 2s 108 packages are looking for funding run `npm fund` for details found 0 vulnerabilities   npm install 成功後，可以在 package.json 中查看到已裝 bootstrap 的資訊\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;bootstrap\u0026#34;: \u0026#34;^4.6.1\u0026#34;,  \u0026#34;rxjs\u0026#34;: \u0026#34;~7.5.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^2.3.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.11.4\u0026#34; },   1.2 npm install 成功後，還必須在 angular.json architect/build/options/styles 中匯入已安裝的 bootstrap\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  { \u0026#34;$schema\u0026#34;: \u0026#34;./node_modules/@angular/cli/lib/config/schema.json\u0026#34;, \u0026#34;version\u0026#34;: 1, \u0026#34;newProjectRoot\u0026#34;: \u0026#34;projects\u0026#34;, \u0026#34;projects\u0026#34;: { \u0026#34;form-validation\u0026#34;: { \u0026#34;projectType\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;schematics\u0026#34;: { \u0026#34;@schematics/angular:component\u0026#34;: { \u0026#34;style\u0026#34;: \u0026#34;css\u0026#34; } }, \u0026#34;root\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;sourceRoot\u0026#34;: \u0026#34;src\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;app\u0026#34;, \u0026#34;architect\u0026#34;: { \u0026#34;build\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-devkit/build-angular:browser\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;outputPath\u0026#34;: \u0026#34;dist/form-validation\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;src/index.html\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;src/main.ts\u0026#34;, \u0026#34;polyfills\u0026#34;: \u0026#34;src/polyfills.ts\u0026#34;, \u0026#34;tsConfig\u0026#34;: \u0026#34;tsconfig.app.json\u0026#34;, \u0026#34;assets\u0026#34;: [ \u0026#34;src/favicon.ico\u0026#34;, \u0026#34;src/assets\u0026#34; ], \u0026#34;styles\u0026#34;: [ \u0026#34;src/styles.scss\u0026#34;, \u0026#34;node_modules/bootstrap/scss/bootstrap.scss\u0026#34;  ], \u0026#34;scripts\u0026#34;: [] ... }, } } } } }   開始撰寫程式 開啟 app.component.ts 程式檔案，並先 import @angular/form module 中的　AbstractControl, FormBuilder, FormGroup, Validators。我們會使用 Angular FormBuilder 建立一個 FormGroup 物件（表單屬性），然後綁定到模板\u0026lt;form\u0026gt;元素（稍後使用 [formGroup]指令）。 Validators 提供了一組內置的驗證器（required、minLength、maxLength…），可供表單控件(control)所使用。\n1 2  import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;;   完成後程式如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormControl, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent implements OnInit { form: FormGroup = new FormGroup({ fullname: new FormControl(\u0026#39;\u0026#39;), username: new FormControl(\u0026#39;\u0026#39;), email: new FormControl(\u0026#39;\u0026#39;), password: new FormControl(\u0026#39;\u0026#39;), confirmPassword: new FormControl(\u0026#39;\u0026#39;), acceptTerms: new FormControl(false),  }); submitted = false;  constructor(private formBuilder: FormBuilder) {} ngOnInit(): void { this.form = this.formBuilder.group( { fullname: [\u0026#39;\u0026#39;, Validators.required], username: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(20) ] ], email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]], password: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(40) ] ], confirmPassword: [\u0026#39;\u0026#39;,Validators.required], acceptTerms: [false, Validators.requiredTrue] }, { validators: [Validation.match(\u0026#39;password\u0026#39;, \u0026#39;confirmPassword\u0026#39;)] } )  } get f(): { [key: string]: AbstractControl } { return this.form.controls; }  onSubmit(): void { this.submitted = true; if (this.form.invalid) { return; } console.log(JSON.stringify(this.form.value, null, 2)); } onReset(): void { this.submitted = false; this.form.reset(); } }   在上述程式裡，我們所建立的 this.form (程式 24-50 行)這個 FormGroup 物件中使用到了許多內建的表單驗證器，如：Validators.required（必填）、Validators.minLength（最小長度）、Validators.maxLength（最大長度）、Validators.requiredTrue（必須為 true）等，同時在程式第 48 行也會使用到｀自定驗證器｀(稍後會進行如何撰寫一個自定驗證器)\n在程式第51行我們定義了一個 getter 以方便我們在 template 中存取 form 中的控件（contol）。透過這個 getter function 你可以使用｀f.username｀ 來取代 ｀form.controls.username｀，使 template（表單樣版） 看起簡潔些。\n自定 CSS 設定 為控制整張 form 的寬度，我們在 app.component.scss 中定義了一個 class - register-form，定義它最大寬度，並套用在 html 檔案中。\n.register-form { max-width: 350px; margin: auto; } 自定表單驗證器 在前述 reactive 表單定義中我們希望在 “Confirm Password” 欄位除了“必填”的檢核邏輯外，還要有一個驗證的機制是｀比對 “Password” 與 “Confirm Password” 這兩個欄位值必須一致\u0026quot;，這個邏輯在內建的表單欄位驗證器中並沒有提供，所以我們要自行撰寫這個驗證器。\n自定驗證器就像我們在日常程式中經常使用的函數一樣。你可以為任何給定場景創立自定驗證器。在 Angular 中建立自定驗證非常簡單，就像建立其他函數一樣。自定驗證器將 AbstractControl 作為參數，如果驗證失敗，則以 key: value 對的形式回傳一個物件。\n先建立一個子目錄 utils，新增一個 validation.ts 程式檔，主要的邏輯有\n 首先，若檢查有任何誤則回傳 null 再則，若兩個被檢核的欄位值不相同，則回傳  import { AbstractControl, ValidatorFn } from \u0026#34;@angular/forms\u0026#34;; export default class Validation { static match(controlName: string, checkControlName: string): ValidatorFn { return (controls: AbstractControl) =\u0026gt; { const control = controls.get(controlName); const checkControl = controls.get(checkControlName); if (checkControl?.errors \u0026amp;\u0026amp; !checkControl.errors[\u0026#39;matching\u0026#39;]) { return null; } if (control?.value !== checkControl?.value) { controls.get(checkControlName)?.setErrors({ matching: true }); return { match: true }; } else { return null; } } } } 完成後的驗證器會被使用在 app.component.ts form 的定義中，見下程式第26行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  ngOnInit(): void { this.form = this.formBuilder.group( { fullname: [\u0026#39;\u0026#39;, Validators.required], username: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(20) ] ], email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]], password: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(40) ] ], confirmPassword: [\u0026#39;\u0026#39;,Validators.required], acceptTerms: [false, Validators.requiredTrue] }, { validators: [Validation.match(\u0026#39;password\u0026#39;, \u0026#39;confirmPassword\u0026#39;)]  } ) }   執行程式 結行結果：\n按下｀送出｀按鈕將所有檢核不合可訊息顯示在欄位下方\nemail 格式不符的驗證\npassword 長度的驗證\nconfirm password 自定驗證喌右的檢核\n檢核完成\n套用 bootstrap 5 的 html index.html 中 link 到 bootstrp@5.1.3 的版本\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;FormValidation\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-zCbKRCUGaJDkqS1kPbPd7TveP5iyJE0EjAuZQTgFLD2ylzuqKfdKlfG/eSrtxUkn\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; app.component.html 套用的 bootstrp class 需要微調\n\u0026lt;div class=\u0026#34;container-fluid register-form\u0026#34;\u0026gt; \u0026lt;form needs-validation [formGroup]=\u0026#34;form\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; 使用者資料註冊 \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;fullname\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Full Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;fullname\u0026#34; id=\u0026#34;fullname\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;fullname\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;fullname\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; Full Name 為必填 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;username\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Username 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;minlength\u0026#39;]\u0026#34;\u0026gt; Username 必須至少為六個字元 \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;maxlength\u0026#39;]\u0026#34;\u0026gt; Username 必須至多為二十個字元 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;email\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;email\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;email\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;email\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Email 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;email\u0026#39;].errors[\u0026#39;email\u0026#39;]\u0026#34;\u0026gt;Email 格式不符\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;password\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Password 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;minlength\u0026#39;]\u0026#34;\u0026gt; Password 必須至少為六個字元 \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;maxlength\u0026#39;]\u0026#34;\u0026gt; Password 必須至多為四十個字元 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;confirmPassword\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Confirm Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;confirmPassword\u0026#34; id=\u0026#34;confirmPassword\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;confirmPassword\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;confirmPassword\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;confirmPassword\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;confirmPassword\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Confirm Password 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;confirmPassword\u0026#39;].errors[\u0026#39;matching\u0026#39;]\u0026#34;\u0026gt; Confirm Password 不符 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4 form-check\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; formControlName=\u0026#34;acceptTerms\u0026#34; id=\u0026#34;acceptTerms\u0026#34; class=\u0026#34;form-check-input\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;acceptTerms\u0026#39;].errors }\u0026#34;/\u0026gt; \u0026lt;label for=\u0026#34;acceptTerms\u0026#34; class=\u0026#34;form-check-label\u0026#34;\u0026gt; 我已閱讀並同意條款 \u0026lt;/label\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;acceptTerms\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; 同意條款 為必填 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;送出\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;onReset()\u0026#34; class=\u0026#34;btn btn-warning float-end\u0026#34;\u0026gt; 重置 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; ","permalink":"https://calvinegs.github.io/posts/angular-formvalidate/","summary":"github Source code\n本文將記錄如何一步步從無到有使用 Angular 13 Reactive Form 表單驗證 與 Bootstrap 建立 一個使用者資料註冊的表單　功能，在這個表單中當按下送出時會自動檢核使用者所輸入的資料是否合乎程式中所設定的檢核邏輯，並顯示合適的訊息反應給使用者。其中將會使用到下列技術:\n Angular CLI Bootstrap 4 \u0026amp; 5 (UI Framework) Angular Reactive Form Custome Validator  建立新專案 $ ng version Angular CLI: 13.3.6 Node: 16.14.0 Package Manager: npm 8.3.1 OS: linux x64 Angular: 13.3.9 ... animations, common, compiler, compiler-cli, core, forms ... platform-browser, platform-browser-dynamic, router Package Version --------------------------------------------------------- @angular-devkit/architect 0.1303.6 @angular-devkit/build-angular 13.3.6 @angular-devkit/core 13.3.6 @angular-devkit/schematics 13.3.6 @angular/cli 13.","title":"使用 Angular 13 建立 Reactive Form 表單驗證範例"},{"content":"github Source code\n本文將記錄如何一步步從無到有使用 Dotnet Core 6.0 建立 ASP.NET Core Web API，其中將會使用到下列技術:\n Dotnet CLI Entity Framework Json Web Token SQL Server (Docker Version) ASP.NET Core Generator  專案完成後的檔案結構 ./專案目錄 ├── .config/ │ └── dotnet-tools.json ├── .vscode/ │ ├── launch.js │ └── tasks.json ├── Controller/ │ ├── AuthenticateController.cs │ ├── TodoController.cs │ └── WeatherForecast.cs ├── Data/ │ └── ApiDbContext.cs ├── Migrations/ ├── Models/ │ ├── AuthenticateData.cs │ └── ItemData.cs ├── obj/ ├── Properties/ │ └── launchSettings.json ├── .gitignore ├── appsettings.Development.json ├── appsettings.json ├── dotnet6-webapi-jwt.csproj ├── global.json ├── Program.cs ├── README.md └── WeatherForecast.cs 專案完成後所提供的 API 端點    Methods Urls Actions     POST /api/Authenticate/login 註冊新使用者帳號   POST /api/Authenticate/register 使用者帳號登入   POST /api/Authenticate/register-admin 管理者帳號登入   GET /api/Todos get all Todos   POST /api/Todos add New Todo   GET /api/Todos/:id get Todo by id   PUT /api/Todos/:id update Todo by id   DELETE /api/Todos/:id remove Todo by id    建置新專案 $ dotnet new webapi -o dotnet6-webapi-jwt 範本「ASP.NET Core Web API」已成功建立。 正在處理建立後的動作... 正在 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/dotnet6-webapi-jwt.csproj 上執行 \u0026#39;dotnet restore\u0026#39;... 正在判斷要還原的專案... 已還原 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/dotnet6-webapi-jwt.csproj (238 ms 內)。 還原成功。 $ cd dotnet6-webapi-jwt $ ls -al 總用量 40 drwxrwxr-x 5 egs egs 4096 五 20 09:38 . drwxrwxr-x 12 egs egs 4096 五 20 09:38 .. -rw-rw-r-- 1 egs egs 127 五 20 09:38 appsettings.Development.json -rw-rw-r-- 1 egs egs 151 五 20 09:38 appsettings.json drwxrwxr-x 2 egs egs 4096 五 20 09:38 Controllers -rw-rw-r-- 1 egs egs 382 五 20 09:38 dotnet6-webapi-jwt.csproj drwxrwxr-x 2 egs egs 4096 五 20 09:38 obj -rw-rw-r-- 1 egs egs 557 五 20 09:38 Program.cs drwxrwxr-x 2 egs egs 4096 五 20 09:38 Properties -rw-rw-r-- 1 egs egs 267 五 20 09:38 WeatherForecast.cs dotnet 版本管理\n$ dotnet --list-sdks # 顯示已安裝的 sdk 版本資訊 5.0.408 [/usr/share/dotnet/sdk] 6.0.300 [/usr/share/dotnet/sdk] $ dotnet --version # 顯示目前所使用的版本 6.0.300 # 預設是最新的版本 由於 dotnet 版本演化滿快的，所以會建議在專案目錄中要指定使用 SDK 的版本，以免當你又安裝了更新版本（如7.0）後程式執行出問題。\n$ dotnet new globaljson --sdk-version 6.0.300 範本「global.json 檔案」已成功建立。 $ cat global.json { \u0026#34;sdk\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;6.0.300\u0026#34; } } 使用 dotnet cli 來產生預設的 git ignore 檔案\n$ dotnet new gitignore 建立 git 初始版本\n$ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝本機工具 此方式安裝的工具，僅限本機存取(只針對目前的目錄和子目錄)， 首先透過 dotnet new tool-manifest 命令來產生工具資訊清單檔，再使用 dotnet tool install 來安裝各式工具程式。這樣的方式好處是在專案若多人協助方式時，則可利用 dotnet tool restore 命令將紀錄在 .config/dotnet-tools.json 的工具資訊清單檔重建在不同協助人員的電腦中。\n$ dotnet new tool-manifest #會產生 .config/dotnet-tools.json 檔案 $ dotnet tool install --local dotnet-ef #使用 local 安裝方式來安裝 Entity Framework 工具 您可使用下列命令，從此目錄叫用工具: \u0026#39;dotnet tool run dotnet-ef\u0026#39; 或 \u0026#39;dotnet dotnet-ef\u0026#39;。 已成功安裝工具 \u0026#39;dotnet-ef\u0026#39; (版本 \u0026#39;6.0.5\u0026#39;)。項目已新增至資訊清單檔 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/.config/dotnet-tools.json。 $ dotnet tool install --local dotnet-aspnet-codegenerator #使用 local 安裝方式來安裝 Code Generator 工具 您可使用下列命令，從此目錄叫用工具: \u0026#39;dotnet tool run dotnet-aspnet-codegenerator\u0026#39; 或 \u0026#39;dotnet dotnet-aspnet-codegenerator\u0026#39;。 已成功安裝工具 \u0026#39;dotnet-aspnet-codegenerator\u0026#39; (版本 \u0026#39;6.0.5\u0026#39;)。項目已新增至資訊清單檔 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/.config/dotnet-tools.json。 $ cat .\\.config\\dotnet-tools.json # 查看安裝上述二項工具後的設定資訊 1 2 3 4 5 6 7 8 9 10 11 12 13 14  { \u0026#34;version\u0026#34;: 1, \u0026#34;isRoot\u0026#34;: true, \u0026#34;tools\u0026#34;: { \u0026#34;dotnet-ef\u0026#34;: {  \u0026#34;version\u0026#34;: \u0026#34;6.0.5\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-ef\u0026#34;] }, \u0026#34;dotnet-aspnet-codegenerator\u0026#34;: {  \u0026#34;version\u0026#34;: \u0026#34;6.0.5\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-aspnet-codegenerator\u0026#34;] } } }   安裝程式使用的相關套件 $ dotnet add package Microsoft.EntityFrameworkCore.Tools #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.Design #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.SqlServer #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore #使用 Identity Framework時必須安裝此套件 $ dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer # $ dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design #搭配 dotnet-aspnet-codegenerator 使用 $ dotnet add package System.Configuration.ConfigurationManager #搭配 dotnet-aspnet-codegenerator 使用 安裝的程式套件資訊紀錄在 \u0026ldquo;專案\u0026rdquo;.csproj 檔案中\n$ cat dotnet6-webapi-jwt.csproj #查看 安裝套件的相關設定值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;RootNamespace\u0026gt;dotnet6_webapi_jwt\u0026lt;/RootNamespace\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Identity.EntityFrameworkCore\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Design\u0026#34; Version=\u0026#34;6.0.5\u0026#34;\u0026gt;  \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.SqlServer\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;6.0.5\u0026#34;\u0026gt;  \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;6.2.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;   建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add EFCore NuGet packages\u0026#34; 執行程式 $ dotnet watch 打開 VS Code\n$ code . 目前産生的程式架構\n設置使用 Entity Framework相關設定 新增 database context (自動產生) 使用 dotnet ef 工具在專案目錄 ./Data 子目錄下新建立一個 ApiDbContext.cs 的 DB Context file\n註：在使用前先把 SQL Server 環境傋妥，安裝 SQL Server 可參考此篇筆紀　Run SQL Server container images with Docker\n$ dotnet ef dbcontext scaffold \u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34; Microsoft.EntityFrameworkCore.SqlServer -c ApiDbContext -o Data Build started... Build succeeded. To protect potentially sensitive information in your connection string, you should move it out of source code. You can avoid scaffolding the connection string by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148. For more guidance on storing connection strings, see http://go.microsoft.com/fwlink/?LinkId=723263. using System; using System.Collections.Generic; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata; namespace dotnet6_webapi_jwt.Data { public partial class ApiDbContext : DbContext { public ApiDbContext() { } public ApiDbContext(DbContextOptions\u0026lt;ApiDbContext\u0026gt; options) : base(options) { } public virtual DbSet\u0026lt;Inventory\u0026gt; Inventories { get; set; } = null!; protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { if (!optionsBuilder.IsConfigured) { // optionsBuilder.UseSqlServer(\u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34;);  } } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity\u0026lt;Inventory\u0026gt;(entity =\u0026gt; { entity.HasNoKey(); entity.ToTable(\u0026#34;Inventory\u0026#34;); entity.Property(e =\u0026gt; e.Id).HasColumnName(\u0026#34;id\u0026#34;); entity.Property(e =\u0026gt; e.Name) .HasMaxLength(50) .HasColumnName(\u0026#34;name\u0026#34;); entity.Property(e =\u0026gt; e.Quantity).HasColumnName(\u0026#34;quantity\u0026#34;); }); OnModelCreatingPartial(modelBuilder); } partial void OnModelCreatingPartial(ModelBuilder modelBuilder); } } 在 appsettings.json 檔案中加入 Connection String\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34; } } 使用 Asp.Net Core Identity framework 來管理使用者使用權限 ASP.NET Core Identity:\n 支援使用者介面 (UI) 登入功能的 API。 管理使用者、密碼、設定檔資料、角色、宣告、權杖、電子郵件確認等。  ASP.Net Core Identity Framework 是一個方便且還完善的使用權限管理架構。\n將相關 Asp.Net Core Identity framework 功能注入到 container 中 除了安裝相關套件外，還要調整相關程式:\n 在 Program.cs 檔案中將加入以下程式碼 (before services.AddControllers())  ConfigurationManager _configuration = builder.Configuration; // Add services to the container. builder.Services.AddDbContext\u0026lt;ApiDbContext\u0026gt;( options =\u0026gt; options.UseSqlServer( _configuration.GetConnectionString(\u0026#34;ConnStr\u0026#34;) ) ); builder.Services.AddIdentity\u0026lt;IdentityUser, IdentityRole\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApiDbContext\u0026gt;() .AddDefaultTokenProviders();  使用 AspNetCore Identity，則 DataContext (ApiDbContext.cs 中) 必須要繼承 IdentityDbContext， 同時 Model creationg 時要改成呼叫 base.OnModelCreation  1 2 3 4 5 6 7 8 9 10 11 12 13 14  public partial class ApiDbContext : IdentityDbContext\u0026lt;IdentityUser\u0026gt; { public ApiDbContext() { } // ...  protected override void OnModelCreating(ModelBuilder modelBuilder) { // OnModelCreatingPartial(modelBuilder);  base.OnModelCreating(modelBuilder);  } }   新增一個 entity framework 遷移 並 更新資料庫 完成上述程式調整後，來執行資料庫遷移(migrations)\n$ dotnet build $ dotnet ef migrations add \u0026#34;Add Identity Framework\u0026#34; Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 6.0.5 initialized \u0026#39;ApiDbContext\u0026#39; using provider \u0026#39;Microsoft.EntityFrameworkCore.SqlServer:6.0.5\u0026#39; with options: None Done. To undo this action, use \u0026#39;ef migrations remove\u0026#39; $ dotnet ef database update 在　dotnet ef migrations add \u0026ldquo;Add Identity Framework\u0026rdquo; 指令完成後，可以在專案目錄下發生産生新的子目錄 Migrations，並有三個新檔案\n在 dotnet ef database update 指令完成後，SQL Server TestDB 資料庫中產生 Identity Framework 會使用到的資料表\n建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;新增一個 entity framework 遷移 並 更新資料庫\u0026#34; 使用 Jason Web Token 在 appsettings.json 中自定JWT實作會使用到的設定值 { // ...  \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34; }, \u0026#34;JwtSettings\u0026#34;: { \u0026#34;ValidIssuer\u0026#34;: \u0026#34;Dotnet6WebApiDemo\u0026#34;, \u0026#34;ValidAudience\u0026#34;: \u0026#34;Dotnet6WebApiDemo\u0026#34;, \u0026#34;Secret\u0026#34;: \u0026#34;Dotnet6 WebApi Demo. Using Json Web Token Technology to keep user info.\u0026#34; } } 新增 使用者註冊和登入時使用的 Data model class (Models/AuthenticateData.cs) using System.ComponentModel.DataAnnotations; namespace dotnet6_webapi_jwt.Models; public class Response { public string? Status { get; set; } public string? Message { get; set; } } public class LoginModel { [EmailAddress] [Required(ErrorMessage = \u0026#34;Eamil Address is required\u0026#34;)] public string? Email { get; set; } [Required(ErrorMessage = \u0026#34;Password is required\u0026#34;)] public string? Password { get; set; } } public class RegisterModel { [Required(ErrorMessage = \u0026#34;User Name is required\u0026#34;)] public string? Username { get; set; } [EmailAddress] [Required(ErrorMessage = \u0026#34;Email Address is required\u0026#34;)] public string? Email { get; set; } [Required(ErrorMessage = \u0026#34;Password is required\u0026#34;)] public string? Password { get; set; } } public static class UserRoles { public const string Admin = \u0026#34;Admin\u0026#34;; public const string User = \u0026#34;User\u0026#34;; } 新增 註冊和登入邏輯 (Controllers/AuthenticateControll.cs) using System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using System.Text; using dotnet6_webapi_jwt.Models; using Microsoft.AspNetCore.Identity; using Microsoft.AspNetCore.Mvc; using Microsoft.IdentityModel.Tokens; namespace dotnet6_webapi_jwt.Controllers; [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class AuthenticateController : ControllerBase { private readonly UserManager\u0026lt;IdentityUser\u0026gt; _userManager; private readonly RoleManager\u0026lt;IdentityRole\u0026gt; _roleManager; private readonly IConfiguration _configuration; public AuthenticateController( UserManager\u0026lt;IdentityUser\u0026gt; userManager, RoleManager\u0026lt;IdentityRole\u0026gt; roleManager, IConfiguration configuration) { _userManager = userManager; _roleManager = roleManager; _configuration = configuration; } [HttpPost] [Route(\u0026#34;login\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Login([FromBody] LoginModel userModel) { var user = await _userManager.FindByEmailAsync(userModel.Email); if (user != null \u0026amp;\u0026amp; await _userManager.CheckPasswordAsync(user, userModel.Password)) { var userRoles = await _userManager.GetRolesAsync(user); var claims = new List\u0026lt;Claim\u0026gt; { new Claim(ClaimTypes.Name, user.UserName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()), }; foreach (var userRole in userRoles) { claims.Add(new Claim(ClaimTypes.Role, userRole)); } var token = CreateToken(claims); return Ok(new { token = new JwtSecurityTokenHandler().WriteToken(token), expiration = token.ValidTo }); } return Unauthorized(); } [HttpPost] [Route(\u0026#34;register\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Register([FromBody] RegisterModel model) { var userExists = await _userManager.FindByEmailAsync(model.Email); if (userExists != null) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User already exists!\u0026#34; }); IdentityUser user = new() { Email = model.Email, SecurityStamp = Guid.NewGuid().ToString(), UserName = model.Username }; var result = await _userManager.CreateAsync(user, model.Password); if (!result.Succeeded) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User creation failed! Please check user details and try again.\u0026#34; }); return Ok(new Response { Status = \u0026#34;Success\u0026#34;, Message = \u0026#34;User created successfully!\u0026#34; }); } [HttpPost] [Route(\u0026#34;register-admin\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; RegisterAdmin([FromBody] RegisterModel model) { var userExists = await _userManager.FindByEmailAsync(model.Email); if (userExists != null) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User already exists!\u0026#34; }); IdentityUser user = new() { Email = model.Email, SecurityStamp = Guid.NewGuid().ToString(), UserName = model.Username }; var result = await _userManager.CreateAsync(user, model.Password); if (!result.Succeeded) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User creation failed! Please check user details and try again.\u0026#34; }); if (!await _roleManager.RoleExistsAsync(UserRoles.Admin)) await _roleManager.CreateAsync(new IdentityRole(UserRoles.Admin)); if (!await _roleManager.RoleExistsAsync(UserRoles.User)) await _roleManager.CreateAsync(new IdentityRole(UserRoles.User)); if (await _roleManager.RoleExistsAsync(UserRoles.Admin)) { await _userManager.AddToRoleAsync(user, UserRoles.Admin); } if (await _roleManager.RoleExistsAsync(UserRoles.Admin)) { await _userManager.AddToRoleAsync(user, UserRoles.User); } return Ok(new Response { Status = \u0026#34;Success\u0026#34;, Message = \u0026#34;User created successfully!\u0026#34; }); } private JwtSecurityToken CreateToken(List\u0026lt;Claim\u0026gt; claims) { var secretkey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes( _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;))); // _configuration.GetSection(\u0026#34;JwtSettings:Secret\u0026#34;).Value)  var credentials = new SigningCredentials(secretkey, SecurityAlgorithms.HmacSha512Signature); var token = new JwtSecurityToken( // 亦可使用　SecurityTokenDescriptor　來産生 Token  issuer: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidIssuer\u0026#34;), audience: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidAudience\u0026#34;), expires: DateTime.Now.AddDays(1), claims: claims, signingCredentials: credentials); return token; } } 有關實作 JWT 的流程 透過 JWT 的實作可以讓你的專案實現 Token-base 的身份驗證與授權。 （Json Web Token) 實作的過程大致可以分成三個部分:\n 在登入成功後産生合法的 JWT Token 每次收到 request 時驗證是否為合法有效的 JWT Token 在特定 API Endpoint 上驗證是否帶有 “合法有效的 JWT Token”，以達到權限管理的需求  産生合法的 Jason Web Token 在上述 AuthenticateController.cs 程式中，我們建立一個 CreateToken() 的 function，並在登入檢核成功時産生一個 token 回傳。\n設置驗證是否為合法有效的 JWT Token 第一步，透過 DI 將 JWT 相關設定設置好\nbuilder.Services.AddAuthentication(options =\u0026gt; { options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; }) .AddJwtBearer(options =\u0026gt; { // 當驗證失敗時，回應標頭會包含 WWW-Authenticate 標頭，這裡會顯示失敗的詳細錯誤原因  options.IncludeErrorDetails = true; // 預設值為 true，有時會特別關閉  options.TokenValidationParameters = new TokenValidationParameters { // 透過這項宣告，就可以從 \u0026#34;NAME\u0026#34; 取值  NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, // 透過這項宣告，就可以從 \u0026#34;Role\u0026#34; 取值，並可讓 [Authorize] 判斷角色  RoleClaimType = \u0026#34;http://schemas.microsoft.com/ws/2008/06/identity/claims/role\u0026#34;, // 驗證 Issuer (一般都會)  ValidateIssuer = true, ValidIssuer = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidIssuer\u0026#34;), // 驗證 Audience (通常不太需要)  ValidateAudience = false, //ValidAudience = = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidAudience\u0026#34;),  // 驗證 Token 的有效期間 (一般都會)  ValidateLifetime = true, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已  ValidateIssuerSigningKey = false, // 應該從 IConfiguration 取得  IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)) }; }); 第二步，要啟動 request pipeline 中的 Middleware (UseAuthentication \u0026amp; UseAuthorization 都需要)\napp.UseAuthentication(); app.UseAuthorization(); 在特定 API EndPoint 上驗證是否帶有合法有效的 JWT Token 在 WeatherForecastController.cs Get() function 上加入[Authorize] 即可\n1 2 3 4 5 6 7 8 9 10 11 12  [Authorize] [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); }   如上程式加入[Authorize]後，再重新瀏覽 weatherforecast endpoint，會回傳 Status: 401 Unauthorized 的錯誤訊息。\n先登入取得 Token\n先加入 Authorization Header，並將登入成功後回傳的 Token 加到 Authorization Header 中。再次送出就可正常的取得所有天氣預測資料了。\n使用 OpenApi Swagger 來測試 API OpenApi Swagger 來測試 API時, 因為　Swagger 測試網頁預設是沒有設定 Token 的功能,必須將程式碼中的 builder.Services.AddSwaggerGen();改成以下內容\nbuilder.Services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;JwtDemo\u0026#34;, Version = \u0026#34;v1\u0026#34; }); c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { In = ParameterLocation.Header, Description = \u0026#34;Please enter JWT with Bearer into field\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, Type = SecuritySchemeType.ApiKey }); c.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} }, new string[] {} } }); }); 有了上述的程式設定，當再次 dotnet run 啟動程式後，瀏覽器呈現的 Swagger 畫面右上角會多出了｀Authorize｀ 的按鈕。按下按鈕就是讓你填入登入成功後回傳的 Token\n在 Value: 文字框內填入 \u0026ldquo;Bearer yJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTUxMiIsInR5cCI6IkpXVCJ9\u0026hellip;..\u0026quot;，再按下 Authorize 按鈕即表下在接下來的 Request 中都會自動帶入 Token 傳給 WebApi Server。 （請注意 Bearer後再先接著一個空白字元再加上 Token值）\n再次執行　\u0026ldquo;WeatherForecast\u0026rdquo; 的測試(Execute)　就可正常的取得回傳值了\n 　若要使用 \u0026ldquo;角色\u0026rdquo; 的授權檢核，只須將｀[Authorize]｀改成｀[Authorize(Roles = UserRoles.Admin)]｀即可\n 1 2 3 4 5 6 7 8 9 10 11 12  [Authorize(Roles = UserRoles.Admin)] [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); }   加入 git 版本控制 $ git commit -m \u0026#34;finished JWT function\u0026#34; -a 使用　aspnet-codegenerator　工具來自動産生程式碼 最後我們來看看如何使用工具來自動産生程式去維護一個新的資料表\n在 Models 目錄下新增一個 model(模型) class - ItemData Models/ItemData.cs\nnamespace dotnet6_webapi_jwt.Models; public class ItemData { public int Id { get; set; } public string? Title { get; set; } public string? Details { get; set; } public bool Done { get; set; } } 在 ApiDbContext.cs 中宣告一個 ItemData table public DbSet\u0026lt;ItemData\u0026gt;? ItemData { get; set; } 新增一個遷移與更新資料庫 $ dotnet build $ dotnet ef migrations add \u0026#34;Add New Table - ItemData\u0026#34; $ dotnet ef database update 使用 ASPNET Codegenerator 自動產生 Todo Controller $ dotnet aspnet-codegenerator controller -name TodoController -async -api -m ItemData -dc ApiDbContext -outDir Controllers Building project ... Finding the generator \u0026#39;controller\u0026#39;... Running the generator \u0026#39;controller\u0026#39;... Minimal hosting scenario! Attempting to compile the application in memory with the modified DbContext. Attempting to figure out the EntityFramework metadata for the model and DbContext: \u0026#39;ItemData\u0026#39; info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 6.0.5 initialized \u0026#39;ApiDbContext\u0026#39; using provider \u0026#39;Microsoft.EntityFrameworkCore.SqlServer:6.0.5\u0026#39; with options: None Added Controller : \u0026#39;/Controllers/TodoController.cs\u0026#39;. RunTime 00:00:10.90 TodoController.cs\nusing System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; using Microsoft.EntityFrameworkCore; using dotnet6_webapi_jwt.Data; using dotnet6_webapi_jwt.Models; namespace dotnet6_webapi_jwt.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class TodoController : ControllerBase { private readonly ApiDbContext _context; public TodoController(ApiDbContext context) { _context = context; } // GET: api/Todo [HttpGet] public async Task\u0026lt;ActionResult\u0026lt;IEnumerable\u0026lt;ItemData\u0026gt;\u0026gt;\u0026gt; GetItemData() { if (_context.ItemData == null) { return NotFound(); } return await _context.ItemData.ToListAsync(); } // GET: api/Todo/5 [HttpGet(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;ItemData\u0026gt;\u0026gt; GetItemData(int id) { if (_context.ItemData == null) { return NotFound(); } var itemData = await _context.ItemData.FindAsync(id); if (itemData == null) { return NotFound(); } return itemData; } // PUT: api/Todo/5  // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754 [HttpPut(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; PutItemData(int id, ItemData itemData) { if (id != itemData.Id) { return BadRequest(); } _context.Entry(itemData).State = EntityState.Modified; try { await _context.SaveChangesAsync(); } catch (DbUpdateConcurrencyException) { if (!ItemDataExists(id)) { return NotFound(); } else { throw; } } return NoContent(); } // POST: api/Todo  // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754 [HttpPost] public async Task\u0026lt;ActionResult\u0026lt;ItemData\u0026gt;\u0026gt; PostItemData(ItemData itemData) { if (_context.ItemData == null) { return Problem(\u0026#34;Entity set \u0026#39;ApiDbContext.ItemData\u0026#39; is null.\u0026#34;); } _context.ItemData.Add(itemData); await _context.SaveChangesAsync(); return CreatedAtAction(\u0026#34;GetItemData\u0026#34;, new { id = itemData.Id }, itemData); } // DELETE: api/Todo/5 [HttpDelete(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; DeleteItemData(int id) { if (_context.ItemData == null) { return NotFound(); } var itemData = await _context.ItemData.FindAsync(id); if (itemData == null) { return NotFound(); } _context.ItemData.Remove(itemData); await _context.SaveChangesAsync(); return NoContent(); } private bool ItemDataExists(int id) { return (_context.ItemData?.Any(e =\u0026gt; e.Id == id)).GetValueOrDefault(); } } } 測試新功能 在 open api - swagger 網頁上透過 POST 的 EndPoint 新增一筆 Toto list\n送出新增的資料，回覆新增成功\n由資料庫中可以查詢到新建立的 record\n透過 GET 的 EndPoint 也可以查詢到新增 Toto list\n以上可以發現使用 ASPNET Codegenerator 自動産生的程式就可簡單的完成資料表格的新增、查詢、修改、刪除等日常功能，真是方便呢！\nCORS 議題 Web App 與 Web Api Server 若處於“不同源”時，當 App 使用 http request 呼叫 Web Api Server 上端點時就會有“同源策略“的問題，這個狀況在測試環境中尤為明顯。 要解決這個問題就必須透過 CORS (Cross-Origin Resource Sharing) 相關設定來應對。在 DotNet Core 中設定相關簡易，僅須在 Program.cs 中加入以下二段程式碼即可：\nvar MyAllOrigins = \u0026#34;allowAll\u0026#34;; builder.Services.AddCors(option =\u0026gt; option.AddPolicy(name: MyAllOrigins, policy =\u0026gt; { policy.WithOrigins(\u0026#34;http://localhost:4200\u0026#34;).AllowAnyMethod().AllowAnyHeader(); } ) ); 以及\napp.UseCors(MyAllOrigins); 完成後，當前端 Web App (如： angular 在測試環境下預設是使用 localhost:4200) 使用 http request 呼叫後端 Web Api (本例中 Web Api 使用的是 localhost:7087) 時就可避到同源策略的要求。\nProgram.cs 完整程式碼\nusing System.Text; using dotnet6_webapi_jwt.Data; using Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.AspNetCore.Identity; using Microsoft.EntityFrameworkCore; using Microsoft.IdentityModel.Tokens; using Microsoft.OpenApi.Models; var builder = WebApplication.CreateBuilder(args); ConfigurationManager _configuration = builder.Configuration; var secret = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;); // Add services to the container. builder.Services.AddDbContext\u0026lt;ApiDbContext\u0026gt;( options =\u0026gt; options.UseSqlServer( _configuration.GetConnectionString(\u0026#34;ConnStr\u0026#34;) ) ); builder.Services.AddIdentity\u0026lt;IdentityUser, IdentityRole\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApiDbContext\u0026gt;() .AddDefaultTokenProviders(); builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; }) .AddJwtBearer(options =\u0026gt; { // 當驗證失敗時，回應標頭會包含 WWW-Authenticate 標頭，這裡會顯示失敗的詳細錯誤原因  options.IncludeErrorDetails = true; // 預設值為 true，有時會特別關閉  options.TokenValidationParameters = new TokenValidationParameters { // 透過這項宣告，就可以從 \u0026#34;NAME\u0026#34; 取值  NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, // 透過這項宣告，就可以從 \u0026#34;Role\u0026#34; 取值，並可讓 [Authorize] 判斷角色  RoleClaimType = \u0026#34;http://schemas.microsoft.com/ws/2008/06/identity/claims/role\u0026#34;, // 驗證 Issuer (一般都會)  ValidateIssuer = true, ValidIssuer = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidIssuer\u0026#34;), // 驗證 Audience (通常不太需要)  ValidateAudience = false, //ValidAudience = = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidAudience\u0026#34;),  // 驗證 Token 的有效期間 (一般都會)  ValidateLifetime = true, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已  ValidateIssuerSigningKey = false, // 應該從 IConfiguration 取得  IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)) }; }); var MyAllOrigins = \u0026#34;allowAll\u0026#34;; builder.Services.AddCors(option =\u0026gt; option.AddPolicy(name: MyAllOrigins, policy =\u0026gt; { policy.WithOrigins(\u0026#34;http://localhost:4200\u0026#34;).AllowAnyMethod().AllowAnyHeader(); } ) ); // builder.Services.AddAuthorization(); builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;JwtDemo\u0026#34;, Version = \u0026#34;v1\u0026#34; }); c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { In = ParameterLocation.Header, Description = \u0026#34;Please enter JWT with Bearer into field\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, Type = SecuritySchemeType.ApiKey }); c.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} }, new string[] {} } }); }); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseCors(MyAllOrigins); app.UseAuthentication(); app.UseAuthorization(); app.MapControllers(); app.Run(); ``","permalink":"https://calvinegs.github.io/posts/dotnet6-webapi-jwt/","summary":"github Source code\n本文將記錄如何一步步從無到有使用 Dotnet Core 6.0 建立 ASP.NET Core Web API，其中將會使用到下列技術:\n Dotnet CLI Entity Framework Json Web Token SQL Server (Docker Version) ASP.NET Core Generator  專案完成後的檔案結構 ./專案目錄 ├── .config/ │ └── dotnet-tools.json ├── .vscode/ │ ├── launch.js │ └── tasks.json ├── Controller/ │ ├── AuthenticateController.cs │ ├── TodoController.cs │ └── WeatherForecast.cs ├── Data/ │ └── ApiDbContext.cs ├── Migrations/ ├── Models/ │ ├── AuthenticateData.cs │ └── ItemData.cs ├── obj/ ├── Properties/ │ └── launchSettings.","title":"使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api。並使用 Microsoft Identity 框架來存儲使用者和角色等資料"},{"content":"如何在 Ubuntu 中使用 Docker 啟動 MS SQL Server 2019  參考資料：　https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15\u0026amp;pivots=cs1-bash\n 首先當然在你的作業系統中必須先安裝好 Docker 下載　SQL Server Image file $ sudo docker pull mcr.microsoft.com/mssql/server:2019-latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mcr.microsoft.com/mssql/server 2019-latest f554c0722914 4 weeks ago 1.64GB 使用 Docker 把 SQL Server image file 啟動 $ docker run -e \u0026quot;ACCEPT_EULA=Y\u0026quot; -e \u0026quot;SA_PASSWORD=Sql@1234\u0026quot; \\ -p 1433:1433 --name sql1 -h sql1 \\ -v sqlvolume:/var/opt/mssql \\ # 將資料映射到 local 的 volume 上 -d mcr.microsoft.com/mssql/server:2019-latest $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 36c9fe84ea3e mcr.microsoft.com/mssql/server:2019-latest \u0026quot;/opt/mssql/bin/perm…\u0026quot; 42 hours ago Up 40 minutes 0.0.0.0:1433-\u0026gt;1433/tcp, :::1433-\u0026gt;1433/tcp sql1 修改 SA Password $ docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd \\  -S localhost -U SA -P \u0026#34;Sql@1234\u0026#34; \\  -Q \u0026#39;ALTER LOGIN SA WITH PASSWORD=\u0026#34;Sql@12345\u0026#34;\u0026#39; 查看 Volume $ docker volume ls local sqlvolume $ docker volume inspect sqlvolume [ { \u0026quot;CreatedAt\u0026quot;: \u0026quot;2022-07-09T12:53:39+08:00\u0026quot;, \u0026quot;Driver\u0026quot;: \u0026quot;local\u0026quot;, \u0026quot;Labels\u0026quot;: null, \u0026quot;Mountpoint\u0026quot;: \u0026quot;/var/lib/docker/volumes/sqlvolume/_data\u0026quot;, \u0026quot;Name\u0026quot;: \u0026quot;sqlvolume\u0026quot;, \u0026quot;Options\u0026quot;: null, \u0026quot;Scope\u0026quot;: \u0026quot;local\u0026quot; } ] $ sudo ls -al /var/lib/docker/volumes/sqlvolume/_data/data 總用量 146956 drwxr-xr-x 2 10001 root 4096 七 9 13:08 . drwxrwx--- 6 root root 4096 七 9 12:53 .. -rw-r----- 1 10001 root 256 七 9 12:53 Entropy.bin -rw-r----- 1 10001 root 4653056 七 10 12:25 master.mdf -rw-r----- 1 10001 root 2097152 七 10 12:25 mastlog.ldf -rw-r----- 1 10001 root 8388608 七 10 12:25 modellog.ldf -rw-r----- 1 10001 root 8388608 七 10 12:25 model.mdf -rw-r----- 1 10001 root 14090240 七 10 12:21 model_msdbdata.mdf -rw-r----- 1 10001 root 524288 七 10 12:21 model_msdblog.ldf -rw-r----- 1 10001 root 524288 七 10 12:21 model_replicatedmaster.ldf -rw-r----- 1 10001 root 4653056 七 10 12:21 model_replicatedmaster.mdf -rw-r----- 1 10001 root 14090240 七 10 12:25 msdbdata.mdf -rw-r----- 1 10001 root 786432 七 10 12:25 msdblog.ldf -rw-r----- 1 10001 root 8388608 七 10 12:21 tempdb2.ndf -rw-r----- 1 10001 root 8388608 七 10 12:21 tempdb3.ndf -rw-r----- 1 10001 root 8388608 七 10 12:21 tempdb4.ndf -rw-r----- 1 10001 root 8388608 七 10 12:21 tempdb5.ndf -rw-r----- 1 10001 root 8388608 七 10 12:21 tempdb6.ndf -rw-r----- 1 10001 root 8388608 七 10 12:21 tempdb7.ndf -rw-r----- 1 10001 root 8388608 七 10 12:21 tempdb8.ndf -rw-r----- 1 10001 root 8388608 七 10 12:21 tempdb.mdf -rw-r----- 1 10001 root 8388608 七 10 12:25 templog.ldf -rw-r----- 1 10001 root 8388608 七 10 12:25 TestDB_log.ldf -rw-r----- 1 10001 root 8388608 七 10 12:25 TestDB.mdf 連接上 Docker 中的 SQL Server $ docker exec -it sql1 \u0026#34;bash\u0026#34; 執行 SQL Commander 工具來操作 SQL Server mssql@sql1:/$ /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P \u0026#34;Sql@12345\u0026#34; 查看 SQL Server 版本 1\u0026gt; select @@version 2\u0026gt; go Microsoft SQL Server 2019 (RTM-CU16) (KB5011644) - 15.0.4223.1 (X64) Apr 11 2022 16:24:07 Copyright (C) 2019 Microsoft Corporation Developer Edition (64-bit) on Linux (Ubuntu 20.04.4 LTS) \u0026lt;X64\u0026gt; (1 rows affected) 建立 TestDB 資料庫 1\u0026gt; CREATE DATABASE TestDB 2\u0026gt; Select name from sys.databases 3\u0026gt; go 在 TestDB 資料庫中建立 Inventory 資料表 並 寫入資料 1\u0026gt; USE TestDB 2\u0026gt; CREATE TABLE Inventory (id INT, name NVARCHAR(50), quantity INT) 3\u0026gt; INSERT INTO Inventory VALUES (1, \u0026#39;banana\u0026#39;, 150); INSERT INTO Inventory VALUES (2, \u0026#39;orange\u0026#39;, 154); 4\u0026gt; go 查詢 Inventory 資料表 1\u0026gt; SELECT * FROM Inventory WHERE quantity \u0026gt; 152; 2\u0026gt; go 離開 SQL Commder 工具 1\u0026gt; quit 離開 Docker 環境 mssql@sql1:/$ exit 安裝 dbeaver-ce 有了資料後，通常你會需要一個管理工具來連結上該資料庫來做一些日常的資料管理。由於工作關係，會常使用到各式資料庫，若你的管理工具只適用某類資料，那勢必要安裝好幾個工具了。在此建議可使用 bdeaver-cd (https://dbeaver.io/download/)\n$ wget https://dbeaver.io/files/dbeaver-ce_latest_amd64.deb $ sudo dpkg -i dbeaver-ce_latest_amd64.deb 安裝完成後啟動它，進行連結資料庫設定\n連結 SQL Server 資料庫\n管理資料庫 - 查詢資料表資料、結構、修改資料表資料、結構\u0026hellip;\n","permalink":"https://calvinegs.github.io/posts/sqlserver2019-docker/","summary":"如何在 Ubuntu 中使用 Docker 啟動 MS SQL Server 2019  參考資料：　https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15\u0026amp;pivots=cs1-bash\n 首先當然在你的作業系統中必須先安裝好 Docker 下載　SQL Server Image file $ sudo docker pull mcr.microsoft.com/mssql/server:2019-latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mcr.microsoft.com/mssql/server 2019-latest f554c0722914 4 weeks ago 1.64GB 使用 Docker 把 SQL Server image file 啟動 $ docker run -e \u0026quot;ACCEPT_EULA=Y\u0026quot; -e \u0026quot;SA_PASSWORD=Sql@1234\u0026quot; \\ -p 1433:1433 --name sql1 -h sql1 \\ -v sqlvolume:/var/opt/mssql \\ # 將資料映射到 local 的 volume 上 -d mcr.","title":"Run SQL Server container images with Docker"},{"content":"github Source code\n本篇筆記中將紀錄如何使用 ASP.NET Core 6 提供的 Minimal APIs 新框架建置一個使用 Token-base 身份驗證的 Web API 網站。\n建立新專案 $ dotnet new webapi -o JwtAuthDemo -minimal 範本「ASP.NET Core Web API」已成功建立。 正在處理建立後的動作... 正在 /home/egs/cal-data/tech-test/webapi/Minimal/JwtAuthDemo/JwtAuthDemo.csproj 上執行 \u0026#39;dotnet restore\u0026#39;... 正在判斷要還原的專案... 已還原 /home/egs/cal-data/tech-test/webapi/Minimal/JwtAuthDemo/JwtAuthDemo.csproj (214 ms 內)。 還原成功。 $ cd JwtAuthDemo $ ls -al 總用量 32 drwxrwxr-x 4 egs egs 4096 五 13 18:36 . drwxrwxr-x 7 egs egs 4096 五 13 18:36 .. -rw-rw-r-- 1 egs egs 127 五 13 18:36 appsettings.Development.json -rw-rw-r-- 1 egs egs 151 五 13 18:36 appsettings.json -rw-rw-r-- 1 egs egs 327 五 13 18:36 JwtAuthDemo.csproj drwxrwxr-x 2 egs egs 4096 五 13 18:36 obj -rw-rw-r-- 1 egs egs 1131 五 13 18:36 Program.cs drwxrwxr-x 2 egs egs 4096 五 13 18:36 Properties dotnet code 版本安裝與管理\n$ dotnet --list-sdks # 顯示已安裝的 sdk 版本資訊 5.0.408 [/usr/share/dotnet/sdk] 6.0.300 [/usr/share/dotnet/sdk] $ dotnet --version # 顯示目前所使用的版本 6.0.300 # 預設是最新的版本 由於 dotnet 版本演化滿快的，所以會建議在專案目錄中要指定使用 SDK 的版本，以免當你又安裝了更新版本（如7.0）後程式執行出問題。\n$ dotnet new globaljson --sdk-version 6.0.300 範本「global.json 檔案」已成功建立。 $ cat global.json { \u0026#34;sdk\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;6.0.300\u0026#34; } } 使用 dotnet cli 來產生預設的 git ignore 檔案\n$ dotnet new gitignore 建立 git 初始版本\n$ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝 Microsoft.AspNetCore.Authentication.JwtBearer 套件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  $ dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer  $ cat JwtAuthDemo.csproj \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt;  \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;6.2.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;   加入 Git 新版本\n$ git commit -m \u0026#34;Add new package Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; -a $ code . # 打開 VS Code 目前産生的程式架構\n執行程式\n$ dotnet watch 實作 JWT 的流程 上圖中可以看到，由系統自動産生的 sample code 已經可以正常執行。\n接下來將在程式中實作JWT功能， 透過 JWT　的實作可以讓你的專案實現 Token-base 的身份驗證與授權。 （Json Web Token) 實作的過程大致可以分成三個部分:\n 在登入成功後産生合法的 JWT Token 每次收到 request 時驗證是否為合法有效的 JWT Token 在特定 API Endpoint 上驗證是否帶有 “合法有效的 JWT Token”，以達到權限管理的需求  産生合法的 Jason Web Token 在 Program.cs 中新一個建立 Token 的 function\nstring CreateToken(LoginViewModel user) { List\u0026lt;Claim\u0026gt; claims = new List\u0026lt;Claim\u0026gt; { new Claim(ClaimTypes.Name, user.Username), new Claim(ClaimTypes.Role, \u0026#34;Admin\u0026#34;) }; ConfigurationManager _configuration = builder.Configuration; var secretkey = new SymmetricSecurityKey(System.Text.Encoding.UTF8.GetBytes( _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;))); // _configuration.GetSection(\u0026#34;JwtSettings:Secret\u0026#34;).Value)  var credentials = new SigningCredentials(secretkey, SecurityAlgorithms.HmacSha512Signature); var token = new JwtSecurityToken( // 亦可使用　SecurityTokenDescriptor　來産生 Token  issuer: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), audience: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Audience\u0026#34;), claims: claims, expires: DateTime.Now.AddDays(1), signingCredentials: credentials); var jwt = new JwtSecurityTokenHandler().WriteToken(token); return jwt; } 建立一個 登入 的 Endpoint\napp.MapPost(\u0026#34;/signin\u0026#34;, (LoginViewModel login) =\u0026gt; { if (ValidateUser(login)) // 驗證登入的帳號是否合法  { var token = CreateToken(login); // 若為合法使用者，則産生一個使用 Token  return Results.Ok(new { token }); // 將登入狀態與Token一併回傳前端  } else { return Results.BadRequest(); // 驗證失敗時回傳 status: 400 Bad Request  } } ).WithName(\u0026#34;SignIn\u0026#34;).AllowAnonymous(); bool ValidateUser(LoginViewModel login) { return login.Username == \u0026#34;cal\u0026#34; ? true : false; } 建立一個 model 來接收 login 資料\nrecord LoginViewModel(string Username, string Password); 驗證是否為合法有效的 JWT Token 第一步，透過 DI 將 JWT 相關設定設置好\nbuilder.Services .AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { // 當驗證失敗時，回應標頭會包含 WWW-Authenticate 標頭，這裡會顯示失敗的詳細錯誤原因  options.IncludeErrorDetails = true; // 預設值為 true，有時會特別關閉  options.TokenValidationParameters = new TokenValidationParameters { // 透過這項宣告，就可以從 \u0026#34;NAME\u0026#34; 取值  NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, // 透過這項宣告，就可以從 \u0026#34;Role\u0026#34; 取值，並可讓 [Authorize] 判斷角色  RoleClaimType = \u0026#34;http://schemas.microsoft.com/ws/2008/06/identity/claims/role\u0026#34;, // 驗證 Issuer (一般都會)  ValidateIssuer = true, ValidIssuer = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), // 驗證 Audience (通常不太需要)  ValidateAudience = false, //ValidAudience = \u0026#34;JwtAuthDemo\u0026#34;, // 不驗證就不需要填寫  // 驗證 Token 的有效期間 (一般都會)  ValidateLifetime = true, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已  ValidateIssuerSigningKey = false, // 應該從 IConfiguration 取得  IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)) }; }); builder.Services.AddAuthorization(); 第二步，要記得也要啟動 request pipeline 中的 Middleware (UseAuthentication \u0026amp; UseAuthorization 都需要)\napp.UseAuthentication(); app.UseAuthorization(); 在特定 API EndPoint 上驗證是否帶有合法有效的 JWT Token 加入.RequireAuthorization() 即可\n1 2 3 4 5 6 7 8 9 10 11 12 13  app.MapGet(\u0026#34;/weatherforecast\u0026#34;, () =\u0026gt; { var forecast = Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast ( DateTime.Now.AddDays(index), Random.Shared.Next(-20, 55), summaries[Random.Shared.Next(summaries.Length)] )) .ToArray(); return forecast; }) .WithName(\u0026#34;GetWeatherForecast\u0026#34;).RequireAuthorization();   如上程式加入.RequireAuthorization()後，再重新瀏覽 weatherforecast endpoint，會回傳 Status: 401 Unauthorized 的錯誤訊息。\n使用 Postman，先加入 Authorization Header，並將登入成功後回傳的 Token 加到 Authorization Header 中。再次送出就可正常的取得所有天氣預測資料了。\n加入 git 版本控制\n$ git commit -m \u0026#34;finished JWT function\u0026#34; -a 完整程式如下(Program.cs)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166  using System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using System.Text; using Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.IdentityModel.Tokens; var builder = WebApplication.CreateBuilder(args); ConfigurationManager _configuration = builder.Configuration; var secret = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;); // Add services to the container. // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); builder.Services .AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { // 當驗證失敗時，回應標頭會包含 WWW-Authenticate 標頭，這裡會顯示失敗的詳細錯誤原因  options.IncludeErrorDetails = true; // 預設值為 true，有時會特別關閉  options.TokenValidationParameters = new TokenValidationParameters { // 透過這項宣告，就可以從 \u0026#34;NAME\u0026#34; 取值  NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, // 透過這項宣告，就可以從 \u0026#34;Role\u0026#34; 取值，並可讓 [Authorize] 判斷角色  RoleClaimType = \u0026#34;http://schemas.microsoft.com/ws/2008/06/identity/claims/role\u0026#34;, // 驗證 Issuer (一般都會)  ValidateIssuer = true, ValidIssuer = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), // 驗證 Audience (通常不太需要)  ValidateAudience = false, //ValidAudience = \u0026#34;JwtAuthDemo\u0026#34;, // 不驗證就不需要填寫  // 驗證 Token 的有效期間 (一般都會)  ValidateLifetime = true, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已  ValidateIssuerSigningKey = false, // 應該從 IConfiguration 取得  IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)) }; }); builder.Services.AddAuthorization(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthentication(); app.UseAuthorization(); var summaries = new[] { \u0026#34;Freezing\u0026#34;, \u0026#34;Bracing\u0026#34;, \u0026#34;Chilly\u0026#34;, \u0026#34;Cool\u0026#34;, \u0026#34;Mild\u0026#34;, \u0026#34;Warm\u0026#34;, \u0026#34;Balmy\u0026#34;, \u0026#34;Hot\u0026#34;, \u0026#34;Sweltering\u0026#34;, \u0026#34;Scorching\u0026#34; }; app.MapGet(\u0026#34;/weatherforecast\u0026#34;, () =\u0026gt; { var forecast = Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast ( DateTime.Now.AddDays(index), Random.Shared.Next(-20, 55), summaries[Random.Shared.Next(summaries.Length)] )) .ToArray(); return forecast; }) .WithName(\u0026#34;GetWeatherForecast\u0026#34;).RequireAuthorization(); app.MapPost(\u0026#34;/signin\u0026#34;, (LoginViewModel login) =\u0026gt; { if (ValidateUser(login)) { var token = CreateToken(login); return Results.Ok(new { token }); } else { return Results.BadRequest(); } } ).WithName(\u0026#34;SignIn\u0026#34;).AllowAnonymous(); string CreateToken(LoginViewModel user) { List\u0026lt;Claim\u0026gt; claims = new List\u0026lt;Claim\u0026gt; { new Claim(ClaimTypes.Name, user.Username), new Claim(ClaimTypes.Role, \u0026#34;Admin\u0026#34;), new Claim(ClaimTypes.Role, \u0026#34;Users\u0026#34;), new Claim(\u0026#34;ProjectType\u0026#34;, \u0026#34;TTG\u0026#34;), }; var secretkey = new SymmetricSecurityKey(System.Text.Encoding.UTF8.GetBytes(secret)); // _configuration.GetSection(\u0026#34;JwtSettings:Secret\u0026#34;).Value)  var credentials = new SigningCredentials(secretkey, SecurityAlgorithms.HmacSha512Signature); var token = new JwtSecurityToken( // 亦可使用　SecurityTokenDescriptor　來産生 Token  issuer: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), audience: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Audience\u0026#34;), claims: claims, expires: DateTime.Now.AddDays(1), signingCredentials: credentials); var jwt = new JwtSecurityTokenHandler().WriteToken(token); return jwt; } bool ValidateUser(LoginViewModel login) { return login.Username == \u0026#34;cal\u0026#34; ? true : false; } app.MapGet(\u0026#34;/claims\u0026#34;, (ClaimsPrincipal user) =\u0026gt; { return Results.Ok(user.Claims.Select(p =\u0026gt; new { p.Type, p.Value })); }) .WithName(\u0026#34;Claims\u0026#34;) .RequireAuthorization(); app.MapGet(\u0026#34;/username\u0026#34;, (ClaimsPrincipal user) =\u0026gt; { return Results.Ok(user.Claims.FirstOrDefault(p =\u0026gt; p.Type == ClaimTypes.Name)?.Value); }) .WithName(\u0026#34;Username\u0026#34;) .RequireAuthorization(); app.MapGet(\u0026#34;/roles\u0026#34;, (ClaimsPrincipal user) =\u0026gt; { return Results.Ok(user.Claims.Select(p =\u0026gt; new { p.Type, p.Value }).Where( c=\u0026gt; c.Type == ClaimTypes.Role)); }) .WithName(\u0026#34;Userrole\u0026#34;) .RequireAuthorization(); app.MapGet(\u0026#34;/issuer\u0026#34;, (ClaimsPrincipal user) =\u0026gt; { return Results.Ok(user.Claims.FirstOrDefault(p =\u0026gt; p.Type == \u0026#34;iss\u0026#34;)?.Value); }) .WithName(\u0026#34;Issuer\u0026#34;) .RequireAuthorization(); await app.RunAsync(); record WeatherForecast(DateTime Date, int TemperatureC, string? Summary) { public int TemperatureF =\u0026gt; 32 + (int)(TemperatureC / 0.5556); } record LoginViewModel(string Username, string Password);   使用 OpenApi Swagger 來測試 API 將程式碼中的 builder.Services.AddSwaggerGen();改成以下內容\nbuilder.Services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;JwtDemo\u0026#34;, Version = \u0026#34;v1\u0026#34; }); c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { In = ParameterLocation.Header, Description = \u0026#34;Please enter JWT with Bearer into field\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, Type = SecuritySchemeType.ApiKey }); c.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} }, new string[] {} } }); }); 有了上述的程式設定，當再次 dotnet run 啟動程式後，瀏覽器呈現的 Swagger 畫面右上角會多出了｀Authorize｀ 的按鈕。按下按鈕就是讓你填入登入成功後回傳的 Token\n在 Value: 文字框內填入 \u0026ldquo;Bearer yJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTUxMiIsInR5cCI6IkpXVCJ9\u0026hellip;..\u0026quot;，再按下 Authorize 按鈕即表下在接下來的 Request 中都會自動帶入 Token 傳給 WebApi Server。 （請注意 Bearer後再先接著一個空白字元再加上 Token值）\n","permalink":"https://calvinegs.github.io/posts/dotnet6-minimalapi-jwt/","summary":"github Source code\n本篇筆記中將紀錄如何使用 ASP.NET Core 6 提供的 Minimal APIs 新框架建置一個使用 Token-base 身份驗證的 Web API 網站。\n建立新專案 $ dotnet new webapi -o JwtAuthDemo -minimal 範本「ASP.NET Core Web API」已成功建立。 正在處理建立後的動作... 正在 /home/egs/cal-data/tech-test/webapi/Minimal/JwtAuthDemo/JwtAuthDemo.csproj 上執行 \u0026#39;dotnet restore\u0026#39;... 正在判斷要還原的專案... 已還原 /home/egs/cal-data/tech-test/webapi/Minimal/JwtAuthDemo/JwtAuthDemo.csproj (214 ms 內)。 還原成功。 $ cd JwtAuthDemo $ ls -al 總用量 32 drwxrwxr-x 4 egs egs 4096 五 13 18:36 . drwxrwxr-x 7 egs egs 4096 五 13 18:36 .. -rw-rw-r-- 1 egs egs 127 五 13 18:36 appsettings.","title":"使用 ASP.NET Core 6 提供的 Minimal APIs 新框架建置一個極簡的 Web API 服務"},{"content":"Snowpack 號稱是更快速的前端建構工具，在開發 Web 應用程式的工作流程中，它可以替代更重、更複雜的打包工具，如 webpack 或 Parcel。\n在此不會討論 Snowpack 的設計細節，只紀錄如可快速的使用 Snowpack 來建置一個由 Typescript 支援網頁程式。由撰寫 Typescript 的過程中了解到強型別（及與搭配 vscode 編輯器）所帶來的好處。\n使用 create-snowpack-app 建立專案 $ mkdir doto-list \u0026amp;\u0026amp; cd todo-list $ $ npx create-snowpack-app . --template @snowpack/app-template-blank-typescript --force $ npm install $ code . 産生的程式結構如下：\npackage.json 的內容：\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;snowpack dev\u0026#34;,  \u0026#34;build\u0026#34;: \u0026#34;snowpack build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;This template does not include a test runner by default.\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;prettier --write \\\u0026#34;src/**/*.{ts,js}\\\u0026#34;\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;prettier --check \\\u0026#34;src/**/*.{ts,js}\\\u0026#34;\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;canvas-confetti\u0026#34;: \u0026#34;^1.2.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@snowpack/plugin-typescript\u0026#34;: \u0026#34;^1.2.1\u0026#34;, \u0026#34;@types/canvas-confetti\u0026#34;: \u0026#34;^1.0.0\u0026#34;, \u0026#34;@types/snowpack-env\u0026#34;: \u0026#34;^2.3.3\u0026#34;, \u0026#34;prettier\u0026#34;: \u0026#34;^2.2.1\u0026#34;, \u0026#34;snowpack\u0026#34;: \u0026#34;^3.3.7\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.2.4\u0026#34;  } } 執行程式 $ npm start\n開始建置 Todo List 網頁 調整 index.html 首先將 public/index.html 內容修改如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Web site created using create-snowpack-app\u0026#34; /\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/dist/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;Snowpack App\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #list { list-style: none; padding: 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; id=\u0026#34;new-task-form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;new-task-title\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 安裝額外的 module $ npm install uuid $ npm install types@uuid --save-dev # uuid moduel 不是 Typescript 所撰寫，要將 uuid 使用在 Typescript 中必須搭配額外的宣告檔，透過這個宣告檔，我們就能享受強型別的好處 { \u0026#34;dependencies\u0026#34;: { \u0026#34;canvas-confetti\u0026#34;: \u0026#34;^1.2.0\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;^8.3.2\u0026#34;  }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@snowpack/plugin-typescript\u0026#34;: \u0026#34;^1.2.1\u0026#34;, \u0026#34;@types/canvas-confetti\u0026#34;: \u0026#34;^1.0.0\u0026#34;, \u0026#34;@types/snowpack-env\u0026#34;: \u0026#34;^2.3.3\u0026#34;, \u0026#34;@types/uuid\u0026#34;: \u0026#34;^8.3.4\u0026#34;,  \u0026#34;prettier\u0026#34;: \u0026#34;^2.2.1\u0026#34;, \u0026#34;snowpack\u0026#34;: \u0026#34;^3.3.7\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.2.4\u0026#34; } } 使用 uuid 修改 src/index.ts 內容\nimport {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; console.log(uuidV4()); 存檔後由瀏覽器 Console 視窗中可以看到由 uuid module 提供的功能所産生的 ID： ｀637fd7c4-1bc3-444a-9335-4b355617edbd｀\nimport {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; //console.log(uuidV4());  const list = document.querySelector(\u0026#39;#list\u0026#39;); 開始撰寫程式 import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  const list = document.querySelector(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); 將滑鼠移至 list 變數，可以發現目前 list 的型別是 \u0026ldquo;Element 或 null\u0026rdquo;。\n透過 index.html 我們可以知道 #list 其實是 ul list，在透過 TypeScript 來撰寫程式時我們可以多利用它的型別檢核，來更方便、更正確的使用程式中的變數。\nimport {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; //console.log(uuidV4());  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); 透過上述程式，使用 泛型 指定querySelector 回傳的是｀HTMLUListElement｀，再將滑鼠移至 list 變數，可以發現目前 list 的型別已經變成是 \u0026ldquo;HTMLUListElement 或 null\u0026rdquo;。這樣的好處是在接下去的程式中可以更精準的使用 list 這個物件。當使用了不是 HTMLUlistElement的屬性時，編輯器就會給你警告，讓程式錯誤在編輯時期就能即時發現。這就是 Typescript 強型別的好處。\n將 index.ts 程式修改如下：\nimport {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); 要注意的是 document.getElementById 的語法必不支援泛型，必須改成強制轉型的方式來限制回傳的型別\n繼續完成 index.ts 程式，當你輸入form.addEventListener 按下 tab 時，VSCode 編輯器會自動將你輸入的程式改成 form?.addEventListener。原因是編輯器知道 form 變數的型別是 HTMLFormElement | null 而自動幫你調整合適的語法。 一樣的道理，在你輸入 input.value 後編輯器也會幫忙調成 input?.value。\nimport {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); form?.addEventListener(\u0026#34;submit\u0026#34;, e =\u0026gt; { e.preventDefault(); if (input?.value == \u0026#34;\u0026#34; || input?.value == null) return; input.value }) 在上圖程式第 11 行，可發現此時的 input 變數的型別是 HTMLInputElement | null，但在本行程式後，由於已排除 null 的可能性，所在在程式第 13 行的 input 變數的型別已成為 HTMLInputElement(如下圖)\n繼續完成當按下 \u0026ldquo;Sumit\u0026rdquo; 按鈕時要將新的 Task 加入到 Doto list 清單中\nimport {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); form?.addEventListener(\u0026#34;submit\u0026#34;, e =\u0026gt; { e.preventDefault(); if (input?.value == \u0026#34;\u0026#34; || input?.value == null) return; // 取得一個新的 Task  const newTask = { id: uuidV4(), title: input.value, completed: false, createdAt: new Date() }; // 透過 addListItem 這個 Function 來新增一個 Todo List  addListItem(newTask); }) function addListItem(task) { } 完成上述程式後，發現在 VSCode 編輯器中給了一個警告，告訴我們參數的型別不符，在 function 宣告中應該為參數設定適當的型別\n透過編輯器我們可以知道 newTask 的型別\n將 function 中參數型別設定成如下圖，編輯器不再有警告訊息\nfunction addListItem(task : { id: string, title: string, completed: boolean, createdAt: Date }) { } 但這樣的寫法顯然的不是好方式，改寫成如下，將 Task 的型別定義成一個叫 Task custom type，並將這個新的型別分別套用在 NewTask 宣告的地方以及 addListItem function 宣告的地方\nimport {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  type Task = { id: string; title: string; completed: boolean; createdAt: Date; }  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); form?.addEventListener(\u0026#34;submit\u0026#34;, e =\u0026gt; { e.preventDefault(); if (input?.value == \u0026#34;\u0026#34; || input?.value == null) return; // 取得一個新的 Task  const newTask: Task = {  id: uuidV4(), title: input.value, completed: false, createdAt: new Date() }; // 透過 addListItem 這個 Function 來新增一個 Todo List  addListItem(newTask); }) function addListItem(task : Task) { } 經過強型別的設計可以很方便的在程式撰寫時就找出可能有問題的程式碼，如下圖：當傳給 addListItem 的參數型別不正確時，編輯器立即會顯示警告訊息。\n繼續完成 addListItem function 的處理邏輯：\nfunction addListItem(task : Task) { const item = document.createElement(\u0026#34;li\u0026#34;); const lable = document.createElement(\u0026#34;label\u0026#34;); const checkbox = document.createElement(\u0026#34;input\u0026#34;); checkbox.type=\u0026#34;checkbox\u0026#34;; checkbox.checked = task.completed; lable.append(checkbox, task.title); item.append(lable); list?.append(item); } 執行結果\n程式至此已經可以加入新 Task 也可以設定（勾選）是否已完成，但當按下 瀏覧器的 ｀重新載入此頁｀ 功能時會發現所有新增的 Tasks 都會不見，接下來我們將加 Local Storeage 的功能將新增的 Tasks 不僅顯示在畫面上也會寫入到 Local Storeage 中，在重新載入時會將紀錄在 Local Storeage 的 Tasks 再重新顯示在畫面中。\n完成後程式 import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; type Task = { id: string; title: string; completed: boolean; createdAt: Date; } const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); const tasks: Task[] = LoadTasks(); // TasK[] 預設由 Local Storeage 中載入所有已新增的 Task tasks.forEach(addListItem); //將 Task[] 中的 Task 顯示到畫面上  form?.addEventListener(\u0026#34;submit\u0026#34;, e =\u0026gt; { e.preventDefault(); if (input?.value == \u0026#34;\u0026#34; || input?.value == null) return; // 取得一個新的 Task  const newTask: Task = { id: uuidV4(), title: input.value, completed: false, createdAt: new Date() }; tasks.push(newTask); // 透過 addListItem 這個 Function 來新增一個 Todo List  addListItem(newTask); input.value = \u0026#34;\u0026#34;; // 將 input 清空  input.focus(); // 將焦點重新定位在 input element 上  }) function addListItem(task : Task) { const item = document.createElement(\u0026#34;li\u0026#34;); const lable = document.createElement(\u0026#34;label\u0026#34;); const checkbox = document.createElement(\u0026#34;input\u0026#34;); checkbox.addEventListener(\u0026#34;change\u0026#34;, () =\u0026gt; { task.completed = checkbox.checked; saveTasks(); // checkbox 有變化時，將 Tasks 寫入 Local Storeage  }) checkbox.type=\u0026#34;checkbox\u0026#34;; checkbox.checked = task.completed; saveTasks(); // 新增 Task 時，將 Tasks 寫入 Local Storeage  lable.append(checkbox, task.title); item.append(lable); list?.append(item); } function saveTasks() { localStorage.setItem(\u0026#34;TASKS\u0026#34;, JSON.stringify(tasks)); }  function LoadTasks(): Task[] { const taskJSON = localStorage.getItem(\u0026#34;TASKS\u0026#34;); if (taskJSON == null) return []; return JSON.parse(taskJSON); } 在瀏覧器的 “開發人員工具” 的 “Application\u0026quot; 功能中透過 Clear All 可將 Local Storage 資料清除。清除後再按下 “重新載入這個網頁” 畫面會回到初始狀態。\n新增 Task、改變 Task 完成否，再 “重新載入這個網頁”，畫面如我們希望的保留了我們已新增/修改的狀態。\n","permalink":"https://calvinegs.github.io/posts/snowpack-typescript/","summary":"Snowpack 號稱是更快速的前端建構工具，在開發 Web 應用程式的工作流程中，它可以替代更重、更複雜的打包工具，如 webpack 或 Parcel。\n在此不會討論 Snowpack 的設計細節，只紀錄如可快速的使用 Snowpack 來建置一個由 Typescript 支援網頁程式。由撰寫 Typescript 的過程中了解到強型別（及與搭配 vscode 編輯器）所帶來的好處。\n使用 create-snowpack-app 建立專案 $ mkdir doto-list \u0026amp;\u0026amp; cd todo-list $ $ npx create-snowpack-app . --template @snowpack/app-template-blank-typescript --force $ npm install $ code . 産生的程式結構如下：\npackage.json 的內容：\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;snowpack dev\u0026#34;,  \u0026#34;build\u0026#34;: \u0026#34;snowpack build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;This template does not include a test runner by default.\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;prettier --write \\\u0026#34;src/**/*.","title":"使用 Snowpack + Typescript 來建置一個 Web App"},{"content":"github Source code #tag: restapi_nodejs\nKEYWORD： MongoDB Cloud Services、Node.js、REST API、JWT、加解密、MongoDB Compass、Postman、express、cryptojs、dotenv、jsonwebtoken、mongoose\n設置專案環境 $ node --version # 檢測環境已裝妥 node.js (若已安裝會顯示目前安裝的版本） $ mkdir ecommerceapi \u0026amp;\u0026amp; cd ecommerceapi ＃ 建立一個專案目錄 $ npm init -y\t＃ 産一專案設定檔 package.json $ touch index.js\t＃ 産生一個新檔案 $ yarn add express mongoose dotenv\t# 加入相依套件 $ yarn add --dev nodemon # 加入開發時期相依套件 $ git init $ echo \u0026#39;node_modules/\u0026#39; \u0026gt; .gitignore # 新增 git ignore 設定檔，並設定 node_modules/ 目錄不加入版控 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 建立第一版本的資訊  設定專案啟動指令（如第七行的指令設定），當輸入 npm start 時系統自動以 node 來執行 index.js 程式，並即時監測 index.js 檔案有變化存檔時馬上重新啟動 node index.js 來執行該程式。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  { \u0026#34;name\u0026#34;: \u0026#34;ecom\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;nodemon index.js\u0026#34;  }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;dotenv\u0026#34;: \u0026#34;^16.0.0\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;^4.17.3\u0026#34;, \u0026#34;mongoose\u0026#34;: \u0026#34;^6.3.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;nodemon\u0026#34;: \u0026#34;^2.0.15\u0026#34; } }    在 index.js 中加入此行程式，並在 vscode Terminal 中輸入 npm start\n console.log(\u0026#34;Hi NodeJS...\u0026#34;)\t 顯示結果如下\n Hi NodeJS... 建立一個 Express 應用程式  使用以下程式覆蓋 index.js 檔案\n const express = require(\u0026#34;express\u0026#34;); const app = express(); app.get(\u0026#34;api/test\u0026#34;, () =\u0026gt; { console.log(\u0026#34;test is successful\u0026#34;); }); app.listen(5000, () =\u0026gt; { console.log(\u0026#34;Backend server is running...\u0026#34;); })  存檔後，開啟 瀏覽器，輸入 localhost:5000/api/test，在 vscode terminal 視窗中會顯示：\n Backend server is running... test is successful 使用 Node.js 連結 MongoDB 在使用 MongoDB 除了在 local 端安裝的方式外，也可以使用 Docker 的方式來啟用 MongoDB，而更方便的是直接使用 https://cloud.mongodb.com/ 線上的免費服務。\n在註冊完成後，可认在 Database / Connect / Connect your application 中找到連結字串  在程式中使用了 mongoose 這個套件的功能來連結 MongoDB 資料庫（第三行），並在程式第6行，connect function 中放入“連結字串”\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const express = require(\u0026#34;express\u0026#34;); const app = express(); const mongoose = require(\u0026#34;mongoose\u0026#34;);  mongoose .connect(\u0026#34;mongodb+srv://calv______ @cluster0.6f8ky.mongodb.net/myFirstDatabase?retryWrites=true\u0026amp;w=majority\u0026#34;)  .then(()=\u0026gt;console.log(\u0026#34;DB Connection successful\u0026#34;)) .catch((err)=\u0026gt; { console.log(err) } ); app.listen(5000, () =\u0026gt; { console.log(\u0026#34;Backend server is running...\u0026#34;); })    存檔後，在 vscode terminal 視窗中會顯示：\n Backend server is running... DB Connection successful  表示連結成功。\n 彈性管理程式中的“設定值”  使用 dotenv 套件的功能來管理程式中相關的設定值\n  首先在專案根目錄下建立一個名為 \u0026ldquo;.env\u0026rdquo; 的檔案  MONGO_URL=mongodb+srv://cal...............  在程式中先匯入 dotenv 套件(第1行），再“啟動它”(第2行），使用時透過 “process.env.MONGO_URL\u0026quot; 語法(第4行） 第十行程式碼中的 process.env.PORT 為相同的原則可在 .evn 檔案中加入 PORT 的設定值調整  const dotenv = require(\u0026#34;dotenv\u0026#34;); dotenv.config(); mongoose .connect(process.env.MONGO_URL) .then(()=\u0026gt;console.log(\u0026#34;DB Connection successful\u0026#34;)) .catch((err)=\u0026gt; { console.log(err) } ); app.listen(process.env.PORT || 5000, ()=\u0026gt;{ # port 預設為 5000 ，並可以在 .env 檔案中進行客製化 （如：PORT＝5001） console.log(\u0026#34;Backend server is running...\u0026#34;); }) 了解 Node.js 路由  新增 routes 目錄，在此目錄下新增 user.js 檔案\n  routes/user.js\n const router = require(\u0026#34;express\u0026#34;).Router(); router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); module.exports = router;  在 index.js 程式中先匯入 \u0026ldquo;./routes/user\u0026rdquo; 這個 router 設定檔，再透過 app.use 語法來使用這個 router(第18行)。完整的 route 為 http://localhost:5000/api/user/usertest\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const express = require(\u0026#34;express\u0026#34;); const app = express(); const mongoose = require(\u0026#34;mongoose\u0026#34;); const dotenv = require(\u0026#34;dotenv\u0026#34;); const userRoute = require(\u0026#34;./routes/user\u0026#34;);  dotenv.config(); mongoose .connect(process.env.MONGO_URL) .then(()=\u0026gt;console.log(\u0026#34;DB Connection successful\u0026#34;)) .catch((err)=\u0026gt; { console.log(err) } ); app.use(\u0026#34;/api/users\u0026#34;, userRoute);  app.listen(process.env.PORT || 5000, ()=\u0026gt;{ console.log(\u0026#34;Backend server is running...\u0026#34;); });    開啟瀏覧器，輸入 http:5000/api/users/usertest，瀏覧器將呈現成功訊息\n user test is successfull  為 routes/user.js 再新增一個 post method\n 1 2 3 4 5 6 7 8 9 10 11  const router = require(\u0026#34;express\u0026#34;).Router(); router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); router.post(\u0026#34;/userposttest\u0026#34;, (req, res) =\u0026gt; { const username = req.body.username; res.send(\u0026#34;your username is: \u0026#34; + username) })  module.exports = router;    使用 postman 來測試 post，結果回傳的是 Server Error，原因是 express 預設是不接受 json 格式的資料。\n  在 index.js 程式中加入如第一行的設定\n 1 2  app.use(express.json()); app.use(\u0026#34;/api/users\u0026#34;, userRoute);    設定完成後就可正常了\n 使用 Node.js MongoDB 模型  接下來我們將資料寫入 MongoDB 資料庫中，首先要先建立 model file(模型檔案），在這個檔案中使用了 mongoose 的 Schema 的語法，只要在新增資料時套用這個這個模型檔，則會自動在 MongoDB 中建立相對應的 collection，將資料存入資料庫中。\n 新增 User 模型檔 (models/User.js)  先新增一個 models 目錄，在目錄下新增一個 User.js，內容如下\n const mongoose = require(\u0026#34;mongoose\u0026#34;); const UserSchema = new mongoose.Schema({ username: { type: String, required: true, unique: true }, email: { type: String, required: true, unique: true }, password: { type: String, required: true }, isAdmin: { type: Boolean, default: false }, }, { timestamps: true } // 透過這個屬性設定，會自動在collection中新增二個屬性: createdAt、updateedAt。 ); module.exports = mongoose.model(\u0026#34;User\u0026#34;, UserSchema); 建立 auth.js router file (routes/auth.js) 將使用者資料註冊和資用者帳號驗證的機制獨立在這個 route file 中，讓程式結構更清晰。內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const router = require(\u0026#34;express\u0026#34;).Router(); const User = require(\u0026#34;../models/User\u0026#34;); // 帳號註冊 router.post(\u0026#34;/register\u0026#34;, async (req, res) =\u0026gt; { const newUser = new User({  username: req.body.username, email: req.body.email, password: req.body.password, }); try { const savedUser = await newUser.save();  res.status(201).json(savedUser); } catch (err) { res.status(500).json(err); } }); module.exports = router;    在 index.js 引用這個新的 router\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const express = require(\u0026#34;express\u0026#34;); const app = express(); const mongoose = require(\u0026#34;mongoose\u0026#34;); const dotenv = require(\u0026#34;dotenv\u0026#34;); const userRoute = require(\u0026#34;./routes/user\u0026#34;); const authRoute = require(\u0026#34;./routes/auth\u0026#34;);  dotenv.config(); mongoose .connect(process.env.MONGO_URL) .then(()=\u0026gt;console.log(\u0026#34;DB Connection successful\u0026#34;)) .catch((err)=\u0026gt; { console.log(err) } ); app.use(express.json()); app.use(\u0026#34;/api/users\u0026#34;, userRoute); app.use(\u0026#34;/api/auth\u0026#34;, authRoute); app.listen(process.env.PORT || 5000, ()=\u0026gt;{ console.log(\u0026#34;Backend server is running...\u0026#34;); });    執行成功後，查看 MongoDB 資料庫的結果：\n 使用 crypto.js 來為敏感資料加密 由上述的查詢畫面可以得知 Password 欄位是以明碼儲存，此類敏感資料可以透過加密技術來加強它的安全性。\ncryptojs 是一個 javascript 的加解密函數庫，使用前先安裝套件： $ yarn add crypto-js\nconst CryptoJS = require(\u0026#34;crypto-js\u0026#34;); password: CryptoJS.AES.encrypt(req.body.password, process.env.PASS_SEC), encrypt function 參數除了要加密的字串外，需要一個加密 Key，為彈性起見，把它寫在 .env 檔案中\n1 2  MONGO_URL=mongodb+srv://cal......... PASS_SEC=cal   加密後的 password 如下：\n1 2 3 4 5 6 7 8 9 10  { \u0026#34;username\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;U2FsdGVkX19F5ULehTVaQfCzw3B0xIefomDIZTTop7g=\u0026#34;,  \u0026#34;isAdmin\u0026#34;: false, \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 }   login function (解密) 繼續完成 auth.js 中的 LOGIN 功能，\n// 帳號登錄 router.post(\u0026#34;/login\u0026#34;, async (req, res) =\u0026gt; { try { const user = await User.findOne({ username: req.body.username }); !user \u0026amp;\u0026amp; res.status(401).json(\u0026#34;Wrong Credentials!\u0026#34;); const hashedPassword = CryptoJS.AES.decrypt(user.password, process.env.PASS_SEC); const orginalPassword = hashedPassword.toString(CryptoJS.enc.Utf8); orginalPassword !== req.body.password \u0026amp;\u0026amp; res.status(401).json(\u0026#34;Wrong Credentials!\u0026#34;); res.status(200).json(user); } catch(err) { res.status(500).json(err) } })  使用 postman 來執行 Login\n  上圖的 User 回傳資料中為安全起見，應該把 password 欄位隱蔵起來。透過javascript 解構語法很容易就可完成這個需求。\n // 帳號登錄 router.post(\u0026#34;/login\u0026#34;, async (req, res) =\u0026gt; { try { const user = await User.findOne({ username: req.body.username }); !user \u0026amp;\u0026amp; res.status(401).json(\u0026#34;Wrong Credentials!\u0026#34;); const hashedPassword = CryptoJS.AES.decrypt(user.password, process.env.PASS_SEC); const orginalPassword = hashedPassword.toString(CryptoJS.enc.Utf8); orginalPassword !== req.body.password \u0026amp;\u0026amp; res.status(401).json(\u0026#34;Wrong Credentials!\u0026#34;); const { password, ...others } = user._doc; res.status(200).json(others); } catch(err) { res.status(500).json(err) } }) { \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;, \u0026#34;isAdmin\u0026#34;: false, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 } 在 Node.js 中使用 JWT 來進行 Token-Based 的使用者授權驗證 為使我們的應用程式更安全 Token-Based 的授權驗證方式來設計 API\n安裝套件：$ yarn add jsonwebtoken\n産生 JWT 在登入證驗中加入産生 Token 的邏輯，在檢核使用者輸入的密碼正確後，將 User ID (_id這個內部 Key)及 isAdmin這兩個屬性值透過 sign function 來産生 access token，並回傳給前端。\nconst jwt = require(\u0026#34;jsonwebtoken\u0026#34;); // 匯入 JsonWebToken套件 ... const accessToken = jwt.sign( { id: user._id, isAdmin: user.isAdmin }, process.env.JWT_SEC, { expiresIn: \u0026#34;3d\u0026#34; } ); ... res.status(200).json({ ...others, accessToken });  依照貫例將 Json web token 的 key 值放在 .env 檔案中\n 1 2 3  MONGO_URL=mongodb+srv://cal....... PASS_SEC=cal JWT_SEC=cal    使用 postman 再 Login 一次，會發現回傳的資料中已經包含一個合法的 JWT Token了\n 使用 JWT 在前端取得合法的 JWT Token後，來看看當使用者在呼叫其他 API 時一併回傳的 Token　如何在 server 端來進行驗證。\n首先我們要在 routes 目錄中新增一個名為 verifyToken.js 的 express Middleware\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  const jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const verifyToken = (req, res, next) =\u0026gt; {  const authHeader = req.headers.token; if (authHeader) { const token = authHeader.split(\u0026#34; \u0026#34;)[1]; jwt.verify(token, process.env.JWT_SEC, (err, user) =\u0026gt; { if (err) res.status(403).json(\u0026#34;Token 不合法！\u0026#34;); req.user = user; next(); }) } else { return res.status(401).json(\u0026#34;未被授權執行本功能！\u0026#34;); } }; const verifyTokenAndAuthorization = (req, res, next) =\u0026gt; {  verifyToken(req, res, () =\u0026gt; { if (req.user.id === req.params.id || req.user.isAdmin) { next(); } else { res.status(403).json(\u0026#34;不允許執行本功能！\u0026#34;); } }) }; const verifyTokenAndAdmin = (req, res, next) =\u0026gt; {  verifyToken(req, res, () =\u0026gt; { if (req.user.isAdmin) { next(); } else { res.status(403).json(\u0026#34;非管理者不允許執行本功能！\u0026#34;); } }) }; module.exports = { verifyToken, verifyTokenAndAuthorization，　verifyTokenAndAdmin };    在 user.js　Route file 中加入 update username 的功能\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  const router = require(\u0026#34;express\u0026#34;).Router(); const User = require(\u0026#34;../models/User\u0026#34;); const { verifyToken, verifyTokenAndAuthorization } = require(\u0026#34;./verifyToken\u0026#34;);  router.put(\u0026#34;/:id\u0026#34;, verifyTokenAndAuthorization, async (req, res) =\u0026gt; {  if (req.user.id === req.params.id || req.user.isAdmin) { if (req.body.password) { req.body.password = CryptoJS.AES.encrypt( req.body.password, process.env.PASS_SEC ).toString(); } }; try { const updatedUser = await User.findByIdAndUpdate(  req.params.id, { $set: req.body, }, { new: true } ); res.status(200).json(updatedUser); } catch(err) { res.status(403).json(err); } }); module.exports = router;    先取得 user collection 第一個 document 的 key id\n  在 postman 新增一個 put 的 request，URL = localhost:5000/api/users/6269f53be0bd74d778bb8934，其中的“6269f53be0bd74d778bb8934”　指的是要變更的 document 的ID。同時在Headers中新加入一個 token 的 header\n  其內容值 = \u0026ldquo;Bearer token_value\u0026rdquo;，注意 \u0026ldquo;Bearer\u0026rdquo; 後要有一個“空白字元”\n  這個 request 的 body 存放的是一個 json 格式的資料，也就是要變更的 username\n  送出 request 成功後回傳值的是修改後的 user document\n 1 2 3 4 5 6 7 8 9 10  { \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;calUpdate\u0026#34;,  \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;U2FsdGVkX19F5ULehTVaQfCzw3B0xIefomDIZTTop7g=\u0026#34;, \u0026#34;isAdmin\u0026#34;: false, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-28T09:59:33.456Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 }    若送出 request 中未包含 Token 則會回傳“未被授權執行本功能”。\n  若送出 request 中包含的是不合法的 Token 則會回傳“Token不合法“。\n  緊接著在 user.js　Route file 中再加入 delete user 資料的功能\n 1 2 3 4 5 6 7 8  router.delete(\u0026#34;/:id\u0026#34;, verifyTokenAndAuthorization, async (req, res) =\u0026gt; { try { await User.findByIdAndDelete(req.params.id);  res.status(200).json(updatedUser); } catch(err) { res.status(403).json(err); } });    另外在 user.js　Route file 中再加入 get user 的功能，而執行本功能的授權檢核邏輯改成 verifyTokenAndAdmin，也就是必須是具有 admin 身份的使用者才能執行本功能。\n 1 2 3 4 5 6 7 8 9  router.get(\u0026#34;/find/:id\u0026#34;, verifyTokenAndAdmin, async (req, res) =\u0026gt; { try { const user = await User.findById(req.params.id);  const { password, ...others } = user._doc; res.status(200).json(other); } catch(err) { res.status(500).json(err); } });    若你使用的 token 所代表的 user isAdmin=false 的話，將回傳\u0026quot;非管理者不允許執行本功能！\u0026ldquo;的警告訊息。\n  我們再新註冊一個新的使用者：\n  並在 MongoDB 中把這個新使用者的isAdmin修改成true\n  使用這個帳號來登入並取後 token 值。\n  使用這個 token 值來呼叫 GET USER 功能就可以正常的取得要查詢的使用者資料了\n 1 2 3 4 5 6 7 8 9  {  \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;, \u0026#34;isAdmin\u0026#34;: false, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-29T02:56:33.670Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 }   如何處理 URL 中的 query string  在　user.js Route file 中再加入 get all users 的功能。\n 1 2 3 4 5 6 7 8  router.get(\u0026#34;/\u0026#34;, verifyTokenAndAdmin, async (req, res) =\u0026gt; { try { const users = await User.find(); res.status(200).json(users);  } catch(err) { res.status(500).json(err); } });    在 url 中輸入：localhost:5000/api/users/，將回傳所有的 users 資料\n [ { \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;U2FsdGVkX19F5ULehTVaQfCzw3B0xIefomDIZTTop7g=\u0026#34;, \u0026#34;isAdmin\u0026#34;: false, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-29T02:56:33.670Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 }, { \u0026#34;_id\u0026#34;: \u0026#34;626b55f9af6c24eb6c911f40\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;admin@gmail.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;U2FsdGVkX190QQrScanCS64GYHup956hNIQ5ALKbjS4=\u0026#34;, \u0026#34;isAdmin\u0026#34;: true, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-29T03:05:29.788Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-29T03:05:29.788Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 } ]  如果想要由 url 中加入額外的 query string 來達到動態執行不同的邏輯，應該怎麼做呢？如：localhost:5000/api/users?new=true 來看看程式中要如何來處理 url 所傳入的 query string\n 1 2 3 4 5 6 7 8 9 10 11 12  // GET ALL USERS router.get(\u0026#34;/\u0026#34;, verifyTokenAndAdmin, async (req, res) =\u0026gt; {  const query = req.query.new; // 透過 req.query.new 來取得 new 這個 query string 的值  try {  const users = query ? await User.find().sort({ _id: -1 }).limit(5) : await User.find(); res.status(200).json(users); } catch(err) { res.status(500).json(err); } });    上述的程式中 User.find().sort({ _id: -1 }).limit(5) 表示的是找出至多五筆的 User 資料並以 _id 來進行‘反’排序，-1表反排序。整個處理還輯表示若在 url 中輸入 localhost:5000/api/users 的話，會回傳所有 User 的資料。若於 url 中輸入 localhost:5000/api/users?new=true，則會回傳 最多五筆並以 _id 來進行‘反’排序的 User 資料。\n ","permalink":"https://calvinegs.github.io/posts/nodejs-restapi-example/","summary":"github Source code #tag: restapi_nodejs\nKEYWORD： MongoDB Cloud Services、Node.js、REST API、JWT、加解密、MongoDB Compass、Postman、express、cryptojs、dotenv、jsonwebtoken、mongoose\n設置專案環境 $ node --version # 檢測環境已裝妥 node.js (若已安裝會顯示目前安裝的版本） $ mkdir ecommerceapi \u0026amp;\u0026amp; cd ecommerceapi ＃ 建立一個專案目錄 $ npm init -y\t＃ 産一專案設定檔 package.json $ touch index.js\t＃ 産生一個新檔案 $ yarn add express mongoose dotenv\t# 加入相依套件 $ yarn add --dev nodemon # 加入開發時期相依套件 $ git init $ echo \u0026#39;node_modules/\u0026#39; \u0026gt; .gitignore # 新增 git ignore 設定檔，並設定 node_modules/ 目錄不加入版控 $ git add .","title":"使用 Node.js + express 建立一個電子商務後端服務的 REST API"},{"content":"rest 和 spread 之間的主要區別在於，rest 運算符將使用者提供的特定的值的“其餘”部分放入 JavaScript 陣列中。但是擴展語法將可疊代物件擴展為各別的元素。\nrest 的範例 // 將使用者提供的某些值放入陣列中 function myBio(firstName, lastName, ...otherInfo) {  return otherInfo; } // 呼叫 myBio 功能時傳入五個參數值: myBio(\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;); // 回傳以下陣列: [\u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;] // 宣告二個一般變數及一個 rest 變數，再使用 destructruing 方式給值: const [firstName, lastName, ...otherInfo] = [  \u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34; ]; console.log(otherInfo); // 結果: [\u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;] // ES7+的物件屬性其餘運算符 const {a, b, ...rest} = {a:1, b:2, c:3, d:4} //a=1, b=2, rest={c:3, d:4}  let options = { title: \u0026#34;Menu\u0026#34;, height: 200, width: 100 }; // title = property named title // rest = object with the rest of properties let {title, ...rest} = options; // now title=\u0026#34;Menu\u0026#34;, rest={height: 200, width: 100} alert(rest.height); // 200 alert(rest.width); // 100 function sum(...numbers) { let result = 0 result = numbers.reduce((orgValue, value) =\u0026gt; orgValue += value) return result } console.log(sum(1)); // 1 console.log(sum(1, 2, 3, 4, 5)); // 15 spread 的範例 // 定義一個有三個參數傳入值的功能 function myBio(firstName, lastName, company) { return `${firstName} ${lastName} runs ${company}`; } // 使用擴展運算符將陣列中的值展開至各別的參數中: myBio(...[\u0026quot;Oluwatobi\u0026quot;, \u0026quot;Sofela\u0026quot;, \u0026quot;CodeSweetly\u0026quot;]); // 上述程式的結果: “Oluwatobi Sofela runs CodeSweetly” let first = [1,3,5]; let second = [2,4,6]; second = [ ...first, ...second]; console.log(\u0026quot;second : \u0026quot;, second); // second [ 1, 3, 5, 2, 4, 6 ] const myName = \u0026#34;Oluwatobi Sofela\u0026#34;; console.log([...myName]); // The invocation above will return: [ \u0026#34;O\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;a\u0026#34; ] const numbers = [1, 3, 5, 7, 10, 200, 90, 59]; function addNumbers(a, b, c, d) { return a + b + c + d; } console.log(addNumbers(...numbers)); // The invocation above will return: 16 // 將擴展運算符運用在物件上 const myNames = [\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;]; const bio = { ...myNames, runs: \u0026#34;codesweetly.com\u0026#34; }; console.log(bio); // The invocation above will return: { 0: \u0026#34;Oluwatobi\u0026#34;, 1: \u0026#34;Sofela\u0026#34;, runs: \u0026#34;codesweetly.com\u0026#34; } // 相同屬性會被覆蓋 const myName = { firstName: \u0026#34;Tobi\u0026#34;, lastName: \u0026#34;Sofela\u0026#34; }; const bio = { ...myName, firstName: \u0026#34;Oluwatobi\u0026#34;, website: \u0026#34;codesweetly.com\u0026#34; }; console.log(bio); // The invocation above will return: { firstName: \u0026#34;Oluwatobi\u0026#34;, lastName: \u0026#34;Sofela\u0026#34;, website: \u0026#34;codesweetly.com\u0026#34; }; // myName 陣列的值都是 Primitive value, 所以 myName 陣列的變化不會反應到 aboutMe 陣列中 const myName = [\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;]; const aboutMe = [\u0026#34;Oluwatobi\u0026#34;, ...myName, \u0026#34;name.\u0026#34;]; console.log(aboutMe); // The invocation above will return: [\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;name.\u0026#34;]  myName.push(\u0026#34;real\u0026#34;);  console.log(myName); // [\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;real\u0026#34;] console.log(aboutMe); // [\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;name.\u0026#34;] // myName 陣列的值包含了 non-primitive value, 所以 myName 陣列的變化會影響 aboutMe 陣列 const myName = [[\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;]]; const aboutMe = [\u0026#34;Oluwatobi\u0026#34;, ...myName, \u0026#34;name.\u0026#34;]; console.log(aboutMe); // The invocation above will return: [ \u0026#34;Oluwatobi\u0026#34;, [\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;], \u0026#34;name.\u0026#34; ]  myName[0].push(\u0026#34;real\u0026#34;);  console.log(myName); // [[\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;real\u0026#34;]] console.log(aboutMe); // [\u0026#34;Oluwatobi\u0026#34;, [\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;real\u0026#34;], \u0026#34;name.\u0026#34;] ","permalink":"https://calvinegs.github.io/posts/rest-spread-js/","summary":"rest 和 spread 之間的主要區別在於，rest 運算符將使用者提供的特定的值的“其餘”部分放入 JavaScript 陣列中。但是擴展語法將可疊代物件擴展為各別的元素。\nrest 的範例 // 將使用者提供的某些值放入陣列中 function myBio(firstName, lastName, ...otherInfo) {  return otherInfo; } // 呼叫 myBio 功能時傳入五個參數值: myBio(\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;); // 回傳以下陣列: [\u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;] // 宣告二個一般變數及一個 rest 變數，再使用 destructruing 方式給值: const [firstName, lastName, ...otherInfo] = [  \u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34; ]; console.log(otherInfo); // 結果: [\u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;] // ES7+的物件屬性其餘運算符 const {a, b, ...rest} = {a:1, b:2, c:3, d:4} //a=1, b=2, rest={c:3, d:4}  let options = { title: \u0026#34;Menu\u0026#34;, height: 200, width: 100 }; // title = property named title // rest = object with the rest of properties let {title, .","title":"透過範例了解 Javascript Rest ＆ Spread 運算符有何不同"},{"content":"物件解構 指定值給已存在的變數 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, color : \u0026#34;red\u0026#34; }; const { name, power, color } = superHero; console.log(\u0026#34;name:\u0026#34;, name); // Spiderman console.log(\u0026#34;color:\u0026#34;, color); // red console.log(\u0026#34;power:\u0026#34;, power); // Spider Sense 重新指定值的用法 const superMan = { name : \u0026#34;Superman\u0026#34;, power : \u0026#34;Super Sense\u0026#34;, color : \u0026#34;blue\u0026#34; }; ({ name, power, color } = superMan); console.log(\u0026#34;name:\u0026#34;, name); console.log(\u0026#34;color:\u0026#34;, color); console.log(\u0026#34;power:\u0026#34;, power); 指定值給新的變數 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, color : \u0026#34;red\u0026#34; }; const { name : n, power : p, color : c } = superHero; console.log(\u0026#34;color:\u0026#34;, c); // red console.log(\u0026#34;power:\u0026#34;, p); // Spider Sense console.log(\u0026#34;name:\u0026#34;, n); // Spiderman 預設值 const person = { name: \u0026#39;Skay\u0026#39;, age: 38 }; // Assign default value of Canada to country if undefined const { name, age, country = \u0026#39;Canada\u0026#39; } = person; console.log(`I am ${name}from ${country}and I am ${age}years old.`); // Output -\u0026gt; I am Skay from Canada and I am 38 years old.\u0026#39; 解構回傳值 const data = () =\u0026gt; ({ name: \u0026#39;George\u0026#39;, role: \u0026#39;SA\u0026#39; }); const { name, role } = data(); 槽狀的解構 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, \u0026#34;character\u0026#34; : { \u0026#34;realName\u0026#34; : \u0026#34;Tom Holland\u0026#34;, \u0026#34;citizenship\u0026#34; : \u0026#34;British\u0026#34;, \u0026#34;appearances\u0026#34; : { \u0026#34;movie\u0026#34; : \u0026#34;captain america civil war\u0026#34;, \u0026#34;releaseDate\u0026#34; : \u0026#34;6 May 2016\u0026#34; } } }; const { character } = superHero; console.log(character); { realName: \u0026#39;Tom Holland\u0026#39;, citizenship: \u0026#39;British\u0026#39;, appearances: { movie: \u0026#39;captain america civil war\u0026#39;, releaseDate: \u0026#39;6 May 2016\u0026#39; } } const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, \u0026#34;character\u0026#34; : { \u0026#34;realName\u0026#34; : \u0026#34;Tom Holland\u0026#34;, \u0026#34;citizenship\u0026#34; : \u0026#34;British\u0026#34;, \u0026#34;appearances\u0026#34; : { \u0026#34;movie\u0026#34; : \u0026#34;captain america civil war\u0026#34;, \u0026#34;releaseDate\u0026#34; : \u0026#34;6 May 2016\u0026#34; } } }; const { character : {appearances : { movie }} } = superHero; console.log(movie); captain america civil war 陣列解構 // we have an array with the name and surname let arr = [\u0026#34;John\u0026#34;, \u0026#34;Smith\u0026#34;] // destructuring assignment // sets firstName = arr[0] // and surname = arr[1] let [firstName, surname] = arr;  console.log(firstName); // John console.log(surname); // Smith let [firstName, surname] = \u0026#34;John Smith\u0026#34;.split(\u0026#39; \u0026#39;); alert(firstName); // John alert(surname); // Smith // 變數值互換 const a = 1, b = 2; [b, a] = [a, b] //a=2, b=1 const [a, [b, [c, d]]] = [1, [2, [[[3, 4], 5], 6]]]; console.log(c); //[ [ 3, 4 ], 5 ] 乎略某些值 // second element is not needed let [firstName, , title] = [\u0026#34;Julius\u0026#34;, \u0026#34;Caesar\u0026#34;, \u0026#34;Consul\u0026#34;, \u0026#34;of the Roman Republic\u0026#34;]; console.log(title); // Consul 支援任何可疊代的值 let [a, b, c] = \u0026#34;abc\u0026#34;; // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] let [one, two, three] = new Set([1, 2, 3]); 預設值 let [a, b, c] = \u0026#34;abc\u0026#34;; // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] let [one, two, three] = new Set([1, 2, 3]); ","permalink":"https://calvinegs.github.io/posts/destructuring-js/","summary":"物件解構 指定值給已存在的變數 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, color : \u0026#34;red\u0026#34; }; const { name, power, color } = superHero; console.log(\u0026#34;name:\u0026#34;, name); // Spiderman console.log(\u0026#34;color:\u0026#34;, color); // red console.log(\u0026#34;power:\u0026#34;, power); // Spider Sense 重新指定值的用法 const superMan = { name : \u0026#34;Superman\u0026#34;, power : \u0026#34;Super Sense\u0026#34;, color : \u0026#34;blue\u0026#34; }; ({ name, power, color } = superMan); console.log(\u0026#34;name:\u0026#34;, name); console.log(\u0026#34;color:\u0026#34;, color); console.log(\u0026#34;power:\u0026#34;, power); 指定值給新的變數 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, color : \u0026#34;red\u0026#34; }; const { name : n, power : p, color : c } = superHero; console.","title":"透過範例了解 Javascript Destructuring (解構指定值)"},{"content":"Keyboard Shortcuts For Ubuntu Terminal 基本操作  Ctrl+Alt+T: 開啟新終端機\nCtrl+Shift+W：關閉終端機 (關閉 Tab）\nCtrl+D：關閉未輸入任何指令終端機 (關閉 Tab）\nCtrl+C：取消正在執行中的指令\nCtrl+L： 清除終端機畫面\nCtrl+Shift+T： 開啟新的 Tab\nALT+［數字鍵］： 移到第幾個 Tab\nCtrl+PgUp/PgDn： 切換 Tab\nCtrl+Shift+'+': Zoom In\nCtrl+'-': Zoom Out\n 在終端機中移動  Ctrl+A: 游標移動到一行開頭\nCtrl+E: 游標移動到一行結尾\nCtrl+F: 游標往前移動一個字元\nCtrl+B: 游標往後移動一個字元\nAlt+F: 游標往前移動一個字 (同 Alt+l)\nAlt+B: 游標往後移動一個字\n 修改文字的操作  Ctrl+D: 刪除游標所在的字元\nCtrl+H: 刪除游標所在的前一個字元\nCtrl+U: 刪除游標所在位置之前的所有字元\nCtrl+K: 刪除游標所在位置之後的所有字元（含游標所在的字元)\nCtrl+W: 刪除游標所在的這個一個字（除游標所在的字元外)\nCtrl+T: 交換游標所在的字元與前一個字元位置\nAlt+T: 交換游標所在的字與前一個字位置\nAlt+U: 將游標所在的字從游標開始的字元起轉換成大寫\n History  Ctrl+R: 以Key word方式反向搜尋 History 指令\nCtrl+P: 前一個 History 中的指令\nCtrl+N: 下一個 History 中的指令\n  $ HISTTIMEFORMAT=\u0026quot;%Y-%m-%d %T \u0026quot;\n ","permalink":"https://calvinegs.github.io/posts/terminal-shortcuts/","summary":"Keyboard Shortcuts For Ubuntu Terminal 基本操作  Ctrl+Alt+T: 開啟新終端機\nCtrl+Shift+W：關閉終端機 (關閉 Tab）\nCtrl+D：關閉未輸入任何指令終端機 (關閉 Tab）\nCtrl+C：取消正在執行中的指令\nCtrl+L： 清除終端機畫面\nCtrl+Shift+T： 開啟新的 Tab\nALT+［數字鍵］： 移到第幾個 Tab\nCtrl+PgUp/PgDn： 切換 Tab\nCtrl+Shift+'+': Zoom In\nCtrl+'-': Zoom Out\n 在終端機中移動  Ctrl+A: 游標移動到一行開頭\nCtrl+E: 游標移動到一行結尾\nCtrl+F: 游標往前移動一個字元\nCtrl+B: 游標往後移動一個字元\nAlt+F: 游標往前移動一個字 (同 Alt+l)\nAlt+B: 游標往後移動一個字\n 修改文字的操作  Ctrl+D: 刪除游標所在的字元\nCtrl+H: 刪除游標所在的前一個字元\nCtrl+U: 刪除游標所在位置之前的所有字元\nCtrl+K: 刪除游標所在位置之後的所有字元（含游標所在的字元)\nCtrl+W: 刪除游標所在的這個一個字（除游標所在的字元外)\nCtrl+T: 交換游標所在的字元與前一個字元位置\nAlt+T: 交換游標所在的字與前一個字位置\nAlt+U: 將游標所在的字從游標開始的字元起轉換成大寫\n History  Ctrl+R: 以Key word方式反向搜尋 History 指令","title":"Ubuntu 終端機常用快速鍵"},{"content":"網頁製作時，手刻 HTML/CSS 即傷神又容易出錯，讓我們來看看 Emmet 如何快速又便捷的協助我們進行 HTML/CSS 的輸入。\nElements 輸入 div 按下 Enter 或 Tab 鍵，輸入 innerHtml - abc 再按下 Ctrl+Enter 鍵\n\u0026lt;div\u0026gt;abc\u0026lt;/div\u0026gt; 輸入 p 按下 Enter 或 Tab 鍵，輸入 innerHtml -abc 再按下 Ctrl+Enter 鍵\n\u0026lt;p\u0026gt;abc\u0026lt;/p\u0026gt; Nesting operators Child: \u0026gt; div\u0026gt;ul\u0026gt;li\n\u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; Sibling: + div+p+bq\n\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; Climb-up: ^ div+div\u0026gt;p\u0026gt;span+em\ndiv+div\u0026gt;p\u0026gt;span+em^bq\ndiv+div\u0026gt;p\u0026gt;span+em^^^bq\n\u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em^bq --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em^^^bq --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; Multiplication: * ul\u0026gt;li*5\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Grouping: () div\u0026gt;(header\u0026gt;ul\u0026gt;li*2\u0026gt;a)+footer\u0026gt;p\n\u0026lt;div\u0026gt; \u0026lt;header\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; (div\u0026gt;dl\u0026gt;(dt+dd)*3)+footer\u0026gt;p\n\u0026lt;div\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; Attribute operators abbr#anId.aClass[style=color:blue; title=\u0026lsquo;Hypertext Markup Language\u0026rsquo;]{HTML}\n\u0026lt;abbr title=\u0026quot;Hypertext Markup Language\u0026quot; id=\u0026quot;anId\u0026quot; class=\u0026quot;aClass\u0026quot; style=\u0026quot;color:blue;\u0026quot; \u0026gt;HTML\u0026lt;/abbr \u0026gt; ID and CLASS div#header+div.page+div#footer.class1.class2.class3\n\u0026lt;div id=\u0026quot;header\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;page\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;footer\u0026quot; class=\u0026quot;class1 class2 class3\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; div.class1\n\u0026lt;div class=\u0026quot;class1\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; (header\u0026gt;ul.nav\u0026gt;li*5)+footer\n\u0026lt;header\u0026gt; \u0026lt;ul class=\u0026quot;nav\u0026quot;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;footer\u0026gt;\u0026lt;/footer\u0026gt; Custome attributes td[title=\u0026ldquo;Hello world!\u0026rdquo; colspan=3]\n\u0026lt;td title=\u0026quot;Hello world!\u0026quot; colspan=\u0026quot;3\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; a:blank\n\u0026lt;a href=\u0026quot;http://\u0026quot; target=\u0026quot;_blank\u0026quot; rel=\u0026quot;noopener noreferrer\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; Item numbering: $ ul\u0026gt;li.item$*5\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item1\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item2\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item$$$*5\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item001\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item002\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item003\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item004\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item005\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item$@-*5\n註: @-: 表示反向排序\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item2\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item1\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item$@3*5\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item6\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item7\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item$@-3*5\n\" data-lang=\"\" \u0026lt;li class=\u0026quot;item7\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item6\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item${Item $@3}*5\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item1\u0026quot;\u0026gt;Item 3\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item2\u0026quot;\u0026gt;Item 4\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;Item 5\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;Item 6\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;Item 7\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul.my-list\u0026gt;(li.my-list-item#id-$$)*6\n\u0026lt;ul class=\u0026quot;my-list\u0026quot;\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-01\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-02\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-03\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-04\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-05\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-06\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Text: a{Click me}\n\u0026lt;!-- a{click}+b{here} --\u0026gt; \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;click\u0026lt;/a\u0026gt;\u0026lt;b\u0026gt;here\u0026lt;/b\u0026gt; \u0026lt;!-- a\u0026gt;{click}+b{here} --\u0026gt; \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;click\u0026lt;b\u0026gt;here\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;!-- p\u0026gt;{Click }+a{here}+{ to continue} --\u0026gt; \u0026lt;p\u0026gt;Click \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; to continue\u0026lt;/p\u0026gt; \u0026lt;!-- p{Click }+a{here}+{ to continue} --\u0026gt; \u0026lt;p\u0026gt;Click\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; to continue Implicit .class1\n\u0026lt;div class=\u0026quot;class1\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; em\u0026gt;.class1\n\u0026lt;em\u0026gt;\u0026lt;span class=\u0026quot;class1\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/em\u0026gt; ul\u0026gt;.class1\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;class1\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; table\u0026gt;.row\u0026gt;.col\n\u0026lt;table\u0026gt; \u0026lt;tr class=\u0026quot;row\u0026quot;\u0026gt; \u0026lt;td class=\u0026quot;col\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Forms \u0026amp; Inputs form:get\n\u0026lt;form action=\u0026quot;\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt;\u0026lt;/form\u0026gt; form:post\n\u0026lt;form action=\u0026quot;\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt;\u0026lt;/form\u0026gt; Lorem lpsum lorem\nlorem20\nul.mylist\u0026gt;lorem4.item*5\n\u0026lt;ul class=\u0026quot;mylist\u0026quot;\u0026gt; \u0026lt;li\u0026gt;Lorem ipsum dolor sit.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Repellendus iusto debitis vel.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Aperiam similique architecto odio!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Exercitationem iusto nesciunt maxime.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Minus reiciendis eaque nemo?\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; p*4\u0026gt;lorem4\n\u0026lt;p\u0026gt;Lorem ipsum dolor sit.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Accusantium odit nostrum modi.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Consequatur soluta voluptatibus amet.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Molestiae quo a asperiores!\u0026lt;/p\u0026gt; Advanced Structures p\u0026gt;{Click }+a{here}+{ to continue}\n\u0026lt;p\u0026gt;Click \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; to continue\u0026lt;/p\u0026gt; CSS Abbreviations body { /* c#000 */ color: #000; /* c#f */ color: #fff; /* c#f4 */ color: #f4f4f4; /* p10 */ padding: 10px; /* default pixel */ /* p10% or p10p */ padding: 10%; /* p10r */ padding: 10rem; /* pr10 */ padding-right: 10px; /* pl10 pt10 pb10 */ padding-left: 10px; padding-top: 10px; padding-bottom: 10px; /* m20 ml20 mt20 mb20*/ margin: 20px; margin-left: 20px; margin-top: 20px; margin-bottom: 2%; /* t10 b10 db di dib */ top: 10px; bottom: 10px; display: block; display: inline; display: inline-block; /* w300 taj dn df*/ width: 300px; text-align: justify; display: none; display: flex; /* ff ffa fft ffv*/ font-family: serif; /* default font: serif */ font-family: Arial, \u0026#34;Helvetica Neue\u0026#34;, Helvetica, sans-serif; font-family: \u0026#34;Times New Roman\u0026#34;, Times, Baskerville, Georgia, serif; font-family: Verdana, Geneva, sans-serif; /* fwb fw700 fsi fsn fso */ font-weight: bold; font-weight: 700; font-style: italic; font-style: normal; font-style: oblique; /* fz2e */ font-size: 2em; /* pr15+ml10 */ padding-right: 15px; margin-left: 10px; } Custom Snippets 先設定 Emmet Snippets 要存放的目錄 (如: f:\\emmet )\n在該目錄下建立一個名為 snippets.json 檔案，內容如下\n{ \u0026#34;html\u0026#34;: { \u0026#34;snippets\u0026#34;: { \u0026#34;nl\u0026#34;: \u0026#34;nav.main-nav\u0026gt;ul\u0026gt;li.item$*4\u0026#34;, \u0026#34;ull\u0026#34;: \u0026#34;ul\u0026gt;li[id=${1} class=${2}]*2\u0026#34; } }, \u0026#34;css\u0026#34;: { \u0026#34;snippets\u0026#34;: { \u0026#34;cb\u0026#34;: \u0026#34;color: black\u0026#34;, \u0026#34;bsd\u0026#34;: \u0026#34;border: 1px solid ${1:red}\u0026#34; } } } 註:\n ${1} 表示為第一個游標停駐的地方，可直接進行 id 輸入, 當按下 Tab 鍵後，游標會自動停駐在 ${2} 的地方，方便輸入 class name。 ${1:red} 其中的 red 表示是預設值。  存檔後重新啟動 VS Code\n\u0026lt;!-- 在 html 樘中輪入 nl 按下 Tab 鍵 --\u0026gt; \u0026lt;nav class=\u0026quot;main-nav\u0026quot;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item1\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item2\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;!-- ull --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li id=\u0026quot;\u0026quot; class=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026quot;\u0026quot; class=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; /* cb */ color: black; /* bsd */ border: 1px solid red; ","permalink":"https://calvinegs.github.io/posts/emmet-syntax/","summary":"網頁製作時，手刻 HTML/CSS 即傷神又容易出錯，讓我們來看看 Emmet 如何快速又便捷的協助我們進行 HTML/CSS 的輸入。\nElements 輸入 div 按下 Enter 或 Tab 鍵，輸入 innerHtml - abc 再按下 Ctrl+Enter 鍵\n\u0026lt;div\u0026gt;abc\u0026lt;/div\u0026gt; 輸入 p 按下 Enter 或 Tab 鍵，輸入 innerHtml -abc 再按下 Ctrl+Enter 鍵\n\u0026lt;p\u0026gt;abc\u0026lt;/p\u0026gt; Nesting operators Child: \u0026gt; div\u0026gt;ul\u0026gt;li\n\u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; Sibling: + div+p+bq\n\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; Climb-up: ^ div+div\u0026gt;p\u0026gt;span+em\ndiv+div\u0026gt;p\u0026gt;span+em^bq\ndiv+div\u0026gt;p\u0026gt;span+em^^^bq\n\u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em^bq --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!","title":"透過範例學習 Emmet 語法"},{"content":"使用 Typescript 來開發前端應用程式已是一個趨勢，這篇筆記是用來紀錄如何用 Parcel.js 來建置一個簡潔又有彈性的開發環境用來學習 Typescript。\n使用的工具 \u0026amp; 作業系統  git vscode Mint 20.2 (作業系統)  專案初始化 $ mkdir parcel_ts \u0026amp;\u0026amp; cd parcel_ts # 建立專案目錄 $ npm init -y # 初始化專案目錄 $ touch Startup.ts Employee.ts index.html # 新增三個空白程式檔 $ npm install --save-dev parcel parcel-bundler # 安裝 parcel \u0026amp; parcel-bundler $ code . # 開啟 vs code 在 package.json 中建立執行程式的 script \u0026#34;script\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;parcel index.html\u0026#34; } 使用 Typescript 撰寫程式  Employee.ts\n export class Employee { constructor( private name: string = \u0026#34;no name\u0026#34;, private department: string = \u0026#34;no department\u0026#34; ) {} displayInfo(): string { return `${this.name}department is ${this.department}`; } }  Startup.ts\n import { Employee } from \u0026#34;./Employee\u0026#34;; window.onload = () =\u0026gt; { let information = document.querySelector(\u0026#34;#info\u0026#34;); const employee = new Employee(\u0026#34;Dany Green\u0026#34;, \u0026#34;Market\u0026#34;); if (employee) information.innerHTML = employee.displayInfo(); };  index.html\n \u0026lt;!-- ! : 輸入 \u0026#34;!\u0026#34; 按下 Tab 或 Enter鍵，Emmet 將自動建立 html5 樣版檔案--\u0026gt; \u0026lt;!-- 透過 Tab 鍵可快速跳至 \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;What\u0026#39;s up\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 直接輸入以下 Emmet 語法: div[name=\u0026#34;container\u0026#34;]\u0026gt;h2#info, 即可産生以下 Html div 內容--\u0026gt; \u0026lt;div name=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2 id=\u0026#34;info\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 直接輸入以下 Emmet 語法: script[type=\u0026#34;module\u0026#34; src=\u0026#34;Startup.ts\u0026#34;] , 即可産生以下 Html script 內容--\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;Startup.ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 註: 可參考另一編筆記是紀錄如何使用 Emmet 語法 透過範例學習 Emmet 語法\n執行程式 $ npm run dev \u0026gt; parcel_ts@1.0.0 dev \u0026gt; parcel index.html Server running at http://localhost:1234 ✨ Built in 22ms Typescript 轉譯成 Javascript  程式執行後，可發現在 dist 目錄下，Parcel.js 已經自動的 Typescript 程式轉譯成 Javascript 了。  同時也把 HTML 檔案中的 .ts 自動的轉成 .js 除錯  按下快速鍵 Ctrl+Shift+D 叫出 \u0026ldquo;Run and Debug\u0026rdquo; 功能，點選 create a launch.sjon file   點選 \u0026ldquo;Edge: Launch\u0026rdquo;   自動産生 launch.sjon\n { // Use IntelliSense to learn about possible attributes.  // Hover to view descriptions of existing attributes.  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387  \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;pwa-msedge\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Launch Edge against localhost\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://localhost:8080\u0026#34;, // 8080 改成 1234  \u0026#34;webRoot\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; } ] }  先將 \u0026ldquo;url\u0026rdquo;: \u0026ldquo;http://localhost:8080\u0026rdquo; Port 改成1234,，並在檔案尾部加入以下設定，並存檔。\n \u0026#34;breakOnLoad\u0026#34;: true, \u0026#34;sourceMapPathOverrides\u0026#34;: { \u0026#34;../*\u0026#34;: \u0026#34;${webRoot}/*\u0026#34; }  再次按下快速鍵 Ctrl+Shift+D 叫出 \u0026ldquo;Run and Debug\u0026rdquo; 功能， 下拉選單中選擇 “Launch Edge against localhost\u0026quot;。在 Source code 中設定中斷點，再以滑鼠點選右邊的綠色三角型按鍵，開始進行除錯。VSCode 會自動啟動 edge 瀏覽器，同時程式會暫停在中斷點處。  結論  你會發現透過 Parcel 的幫助，當使用 Typescript 來撰寫 網站程式即方便又快速。\n ","permalink":"https://calvinegs.github.io/posts/parcel-typescript/","summary":"使用 Typescript 來開發前端應用程式已是一個趨勢，這篇筆記是用來紀錄如何用 Parcel.js 來建置一個簡潔又有彈性的開發環境用來學習 Typescript。\n使用的工具 \u0026amp; 作業系統  git vscode Mint 20.2 (作業系統)  專案初始化 $ mkdir parcel_ts \u0026amp;\u0026amp; cd parcel_ts # 建立專案目錄 $ npm init -y # 初始化專案目錄 $ touch Startup.ts Employee.ts index.html # 新增三個空白程式檔 $ npm install --save-dev parcel parcel-bundler # 安裝 parcel \u0026amp; parcel-bundler $ code . # 開啟 vs code 在 package.json 中建立執行程式的 script \u0026#34;script\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;parcel index.html\u0026#34; } 使用 Typescript 撰寫程式  Employee.","title":"使用 Parcel.js + Typescript 來建置一個 Web App"},{"content":"github Source code #tag: dapper_oracle\n當已有現存的資料庫(此以 Oracle 為例)並且存在有歷史資料，或與其他系統共用資料庫，在這前題下，通常無法隨意的去更改資料庫結構，這時若要採用 Entity Framework 架構就容易遇到資料庫結構正規化的問題。另一種情境是，舊系統使用了非常的SQL語法，要將這些邏輯\u0026quot;翻譯\u0026quot;成合理的 Entity Framework 架構有技術上或時間上的限制時，就會考慮使用 Dapper 這個輕量的 ORM 搭配上 SQL 語法。\n使用 dotnet cli 建立專案 $ dotnet new webapi -o OracleDapperRepository \u0026amp;\u0026amp; cd OracleDapperRepository $ dotnet build $ dotnet run $ dotnet new gitignore $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝相依套件 $ dotnet add package Dapper --2.0.123 # 加入 Dapper package $ dotnet add package Oracle.ManagedDataAccess.Core --3.21.50 # 加入 連結 Oracle package $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add Dapper \u0026amp; Oracle Data Access NuGet packages\u0026#34; 查看 csproj 檔案中使用的相關套件\n$ cat OracleDapperRepository.csproj\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt;  \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Dapper\u0026#34; Version=\u0026#34;2.0.123\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Oracle.ManagedDataAccess.Core\u0026#34; Version=\u0026#34;3.21.50\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;6.2.3\u0026#34; /\u0026gt;  \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;   設定 Connection string 打開 VS Code，在 appsettings.json 檔案中加入 Connection String\n{ \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;OracleConnection\u0026#34;:\u0026#34;Data Source=192.0.0.1/ORCLCDB;User ID=username;Password=password\u0026#34; }, //... } 專案完成後的檔案結構 ./專案目錄 ├── .config/ │ └── dotnet-tools.json ├── .vscode/ │ ├── launch.js │ └── tasks.json ├── Controller/ │ ├── SysmstafController.cs │ └── WeatherForecast.cs ├── Models/ │ └── sysmstaf.cs ├── obj/ ├── Properties/ │ └── launchSettings.json ├── Repositories/ │ ├── Interfaces/ │ │ └── ISysmstafRepository.cs │ └── SysmstafRepository.cs ├── .gitignore ├── appsettings.json ├── OracleDapperRepository.csproj ├── Program.cs ├── README.md └── WeatherForecast.cs 專案完成後所提供的 API 端點    Methods Urls Actions     POST /api/Sysmstaf/StaffId/:id 使用員工編號查詢員工資料   POST /api/Sysmstaf/LoginId/:id 使用登錄編號查詢員工資料   POST /api/Sysmstaf/GetDatas 取得所有員工資料   GET /api/Sysmstaf/GetAllData 取得所有員工資料    建置專案中目錄結構與程式 在專案目錄中新增 Models/ 和 Repositories/ 二個目錄，並在 Repositories/ 目錄下建立一個 Interfaces/ 子目錄\n在 Models/ 資料夾中新增 Data Model 新增 Model class: Models\\sysmstaf.cs\nnamespace OracleDapperRepository.Models { public class sysmstaf { public string? STAFF_ID { get; set; } public int ROLE_ID { get; set; } public string? PASS_TX { get; set; } public string? LOGIN_TX { get; set; } } } 在 Repositories/Interfaces/ 目錄下新增一個 ISysmstafRepository.cs Interface file using OracleDapperRepository.Models; namespace OracleDapperRepository.Repositories.Interfaces { public interface ISysmstafRepository { Task\u0026lt;sysmstaf\u0026gt; GetByStaffID(string staffId); Task\u0026lt;sysmstaf\u0026gt; GetByLoginID(string loginID); Task\u0026lt;IEnumerable\u0026lt;sysmstaf\u0026gt;\u0026gt; GetAllData(); } } 在 Repositories/ 目錄下新增 SysmstafRepository.cs using System.Data; using Dapper; using Oracle.ManagedDataAccess.Client; using OracleDapperRepository.Models; using OracleDapperRepository.Repositories.Interfaces; namespace OracleDapperRepository.Repositories { public class SysmstafRepository : ISysmstafRepository { private readonly string _connectionString; public SysmstafRepository(string connectionStr) { _connectionString = connectionStr; } public IDbConnection Connection { get { return new OracleConnection(_connectionString); } } public async Task\u0026lt;sysmstaf\u0026gt; GetByLoginID(string loginID) { using (IDbConnection conn = Connection) { string sSQL = \u0026#34;select * from sysmstaf where login_tx= :LOGIN_ID\u0026#34;; return await conn.QueryFirstOrDefaultAsync\u0026lt;sysmstaf\u0026gt;(sSQL, new { LOGIN_ID = loginID }); } } public async Task\u0026lt;sysmstaf\u0026gt; GetByStaffID(string staffId) { using (IDbConnection conn = Connection) { string sSQL = \u0026#34;select * from sysmstaf where staff_id= :STAFF_ID\u0026#34;; return await conn.QueryFirstOrDefaultAsync\u0026lt;sysmstaf\u0026gt;(sSQL, new { STAFF_ID = staffId }); } } public async Task\u0026lt;IEnumerable\u0026lt;sysmstaf\u0026gt;\u0026gt; GetAllData() { using (IDbConnection conn = Connection) { string sSql = \u0026#34;select * from sysmstaf Order by login_tx\u0026#34;; var result = await conn.QueryAsync\u0026lt;sysmstaf\u0026gt;(sSql); return result.ToList(); } } } } 在 Controllers/ 目錄下新增 SysmstafController.cs using Microsoft.AspNetCore.Mvc; using OracleDapperRepository.Models; using OracleDapperRepository.Repositories.Interfaces; namespace OracleDapperRepository.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class SysmstafController : ControllerBase { private readonly ISysmstafRepository _sysmstafRepo; public SysmstafController(ISysmstafRepository sysmstafRepo) { _sysmstafRepo = sysmstafRepo; } [HttpGet] [Route(\u0026#34;StaffId/{staffId}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;sysmstaf\u0026gt;\u0026gt; GetByStaffID(string staffId) { return await _sysmstafRepo.GetByStaffID(staffId); } [HttpGet] [Route(\u0026#34;LoginId/{loginId}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;sysmstaf\u0026gt;\u0026gt; GetByLoginID(string loginId) { return await _sysmstafRepo.GetByLoginID(loginId); } [HttpGet] [Route(\u0026#34;GetAllData\u0026#34;)] public async Task\u0026lt;IEnumerable\u0026lt;sysmstaf\u0026gt;\u0026gt; GetAllData() { return await _sysmstafRepo.GetAllData(); ; } } } 在 Program.cs 中將 SysmstafRepository 注入 Container 中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  using OracleDapperRepository.Repositories; using OracleDapperRepository.Repositories.Interfaces; var builder = WebApplication.CreateBuilder(args); string ConnectionString = builder.Configuration.GetConnectionString(\u0026#34;OracleConnection\u0026#34;); // 取得 appsettings.json 中的 ConnectionStrings 設定值  // Add services to the container. builder.Services.AddTransient\u0026lt;ISysmstafRepository\u0026gt;(x =\u0026gt; new SysmstafRepository(ConnectionString)); // 將  builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); var app = builder.Build(); // ...   透過 swagger (OpenAPI) 來看結果 啟動程式來測試執行結果 $ dotnet watch\n","permalink":"https://calvinegs.github.io/posts/dotnet6-webapi-oracle-dapper/","summary":"github Source code #tag: dapper_oracle\n當已有現存的資料庫(此以 Oracle 為例)並且存在有歷史資料，或與其他系統共用資料庫，在這前題下，通常無法隨意的去更改資料庫結構，這時若要採用 Entity Framework 架構就容易遇到資料庫結構正規化的問題。另一種情境是，舊系統使用了非常的SQL語法，要將這些邏輯\u0026quot;翻譯\u0026quot;成合理的 Entity Framework 架構有技術上或時間上的限制時，就會考慮使用 Dapper 這個輕量的 ORM 搭配上 SQL 語法。\n使用 dotnet cli 建立專案 $ dotnet new webapi -o OracleDapperRepository \u0026amp;\u0026amp; cd OracleDapperRepository $ dotnet build $ dotnet run $ dotnet new gitignore $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝相依套件 $ dotnet add package Dapper --2.0.123 # 加入 Dapper package $ dotnet add package Oracle.","title":"ASP.NET Core 6 Web API 使用 Dapper ORM 連結 Oracle"},{"content":"   組合鍵 說明     Ctrl+K F Close folder   Ctrl+K Ctrl+O Open folder   Ctrl+R Open Project (透過歷史記錄清單)   Ctrl+Shift+E Explorer / Editor 間的焦點切換   Ctrl+0 Focus Side Bar 將焦點切換至 Side Bar   Ctrl+B 顯示/隠蔵 Side Bar   Ctrl+[1~9] 在 Editor Groups 間焦點切換   Ctrl+Enter 在 新 Group 中打開新指定檔案   Ctrl+\\ 拆分編輯視窗   Ctrl+K Ctrl+\\ 在新 Group 中(在現在 Group 的下方)打開游標在的檔案   Ctrl+F4 or Crtl+W Close Editor   Ctrl+Alt+←→ 在 Groups 間移動檔案   Ctrl+Shift+PgUp/PgDn 在同一個 Group 中移動目前的 editor 到左/右邊   Ctrl+PgDn/PgUp 在 Tabs 間的焦點切換(跨 Groups)   Ctrl+Tab 在同一個 Group 在已開啟的檔案清單中切換(往下)   Ctrl+Shift+Tab 在同一個 Group在已開啟的檔案清單中切換(往上)   Ctrl+K Ctrl+C 註解游標在的這行   Ctrl+Shift+\\ 找到對應的括弧   Ctrl+K Ctrl+U 移除註解 (游標在的這行)   Ctrl+/ 在 \u0026ldquo;註解/移除註解\u0026rdquo; 間切換 (游標在的這行)   Shift+Alt+A 切換區塊註解 (針對被選擇的程式碼)   Shift+Alt+F 將檔案中程式碼格式化   Ctrl+K Ctrl+F 將被選取的程式碼格式化   Ctrl+L 全選整行 (重覆則可往下選擇多行)   Ctrl+X 或 Ctrl+Shift+K 刪除一行   Ctrl + backspace 刪除游標前的字句   Ctrl+K Ctrl+X 刪除行尾的空白字元   Ctrl+, Settings 顯示設定功能   Ctrl+K V 顯示/隱藏 Markdown file 的 Preview 功能   Alt+[1~9] 在Group 中 Tabs 間作焦點切換   Alt+0 移至同一個 Group 中最後一個 editor Tab   Alt+Shift+0 切換 Groups 成為並列或並排   Ctrl+Shift+P Show Command Palette   Ctrl+P Open File   Ctrl+K Ctrl+S Keyboard Shortcuts   Ctrl+K S Save All Files   Ctrl+N New File   Ctrl+K Ctrl+W 關閉所有開啟的檔案   Ctrl+K W 關閉現行 Group   Ctrl+I 顯示系統建議   Ctrl+Shift+T 重新開啟關閉的檔案   Ctrl+K M 切換檔案格式 Change Language Mode   Ctrl+K Enter Keep preview mode editor open (將目前以 Preview 模式開啟的檔案轉換成編輯模式)   Ctrl+K P Copy path of an active file (將目前的檔案目徑含檔名複製到剪貼簿中)   Ctrl+K R Reveal active file in Explorer (將目前的檔案開啟在新的 檔案總管視窗 中)   Ctrl+K O Show active file in a new window/instance (將目前的檔案開啟在新的 vscode 中)   Ctrl+Alt N run code in code runner (屬擴充套件的功能)   Ctrl+= 放大   Ctrl+- 縮小   Ctrl+0 (Num Lock) 恢復原來大小   Ctrl+Shift+L 用你已選擇的字串來標示(選擇)整個檔案中所有符合的文字   Ctrl+F2 不須要先選擇目標字串即可有同上的功能   Shift+Alt+←→ Select until the end of the word   Ctrl+F Find   Ctrl+Shift+O Show Symbol Document Outline   Ctrl+Shift+F File Find   Ctrl+Shift+G Git   Ctrl+Shift+D Debug   Ctrl+Shift+X Extension   Ctrl+Alt+↑↓ Multi line column selection   Ctrl+D Multi Currsor selection   Alt+z 切換斷行功能   Alt+Shift+↓ 複製焦點在的這一行   Alt+↑↓ 移動焦點在的這一行往上/往下   Alt+←→ Go back / forward (往前/後 曾經的操作過程)   Alt+F5 在程式碼比對視窗中，移動到下一個程式碼有變動處   Alt+Shift+F5 在程式碼比對視窗中，移動到上一個程式碼有變動處   F12 Go to Definition (跳至\u0026quot;Function\u0026quot; / \u0026ldquo;變數\u0026rdquo; 定義地方)   Shift+F12 Go to References (檢視 \u0026ldquo;Function\u0026rdquo; / \u0026ldquo;變數\u0026rdquo; 使用的地方)   Ctrl+F12 Go to implementations (跳至\u0026quot;Function\u0026quot; / \u0026ldquo;變數\u0026rdquo; 實現的地方)   Alt+F12 Peek definition (檢視 \u0026ldquo;Function\u0026rdquo; / \u0026ldquo;變數\u0026rdquo; 的出處及定義內容)   Ctrl + ‵ (or Ctrl+J) 切換整合是終端機   Ctrl + shift + ‵ 建立新的整合終端機   Ctrl + shift + c 建立新的終端機 (焦點在 Terminal 時無效)   Ctrl + shift + 5 切割終端機   Alt + ↑↓←→ 切換整合終端機聚焦點   Alt + U 若所在檔案不是 ts 檔，則顯示對應的 ts 檔案。若是 ts 檔，則顯示前一個檔案   Alt + I 若所在檔案不是 css 檔，則顯示對應的 css 檔案。若是 css 檔，則顯示前一個檔案   Alt + O 若所在檔案不是 html 檔，則顯示對應的 html 檔案。若是 html 檔，則顯示前一個檔案   Alt + P 若所在檔案不是 spec.ts 檔，則顯示對應的 spec.ts 檔案。若是 spec.ts 檔，則顯示前一個檔案    註: 後四項是 VSCide Extension angular2-switcher 所支援\n","permalink":"https://calvinegs.github.io/posts/vscod-shortcut/","summary":"組合鍵 說明     Ctrl+K F Close folder   Ctrl+K Ctrl+O Open folder   Ctrl+R Open Project (透過歷史記錄清單)   Ctrl+Shift+E Explorer / Editor 間的焦點切換   Ctrl+0 Focus Side Bar 將焦點切換至 Side Bar   Ctrl+B 顯示/隠蔵 Side Bar   Ctrl+[1~9] 在 Editor Groups 間焦點切換   Ctrl+Enter 在 新 Group 中打開新指定檔案   Ctrl+\\ 拆分編輯視窗   Ctrl+K Ctrl+\\ 在新 Group 中(在現在 Group 的下方)打開游標在的檔案   Ctrl+F4 or Crtl+W Close Editor   Ctrl+Alt+←→ 在 Groups 間移動檔案   Ctrl+Shift+PgUp/PgDn 在同一個 Group 中移動目前的 editor 到左/右邊   Ctrl+PgDn/PgUp 在 Tabs 間的焦點切換(跨 Groups)   Ctrl+Tab 在同一個 Group 在已開啟的檔案清單中切換(往下)   Ctrl+Shift+Tab 在同一個 Group在已開啟的檔案清單中切換(往上)   Ctrl+K Ctrl+C 註解游標在的這行   Ctrl+Shift+\\ 找到對應的括弧   Ctrl+K Ctrl+U 移除註解 (游標在的這行)   Ctrl+/ 在 \u0026ldquo;註解/移除註解\u0026rdquo; 間切換 (游標在的這行)   Shift+Alt+A 切換區塊註解 (針對被選擇的程式碼)   Shift+Alt+F 將檔案中程式碼格式化   Ctrl+K Ctrl+F 將被選取的程式碼格式化   Ctrl+L 全選整行 (重覆則可往下選擇多行)   Ctrl+X 或 Ctrl+Shift+K 刪除一行   Ctrl + backspace 刪除游標前的字句   Ctrl+K Ctrl+X 刪除行尾的空白字元   Ctrl+, Settings 顯示設定功能   Ctrl+K V 顯示/隱藏 Markdown file 的 Preview 功能   Alt+[1~9] 在Group 中 Tabs 間作焦點切換   Alt+0 移至同一個 Group 中最後一個 editor Tab   Alt+Shift+0 切換 Groups 成為並列或並排   Ctrl+Shift+P Show Command Palette   Ctrl+P Open File   Ctrl+K Ctrl+S Keyboard Shortcuts   Ctrl+K S Save All Files   Ctrl+N New File   Ctrl+K Ctrl+W 關閉所有開啟的檔案   Ctrl+K W 關閉現行 Group   Ctrl+I 顯示系統建議   Ctrl+Shift+T 重新開啟關閉的檔案   Ctrl+K M 切換檔案格式 Change Language Mode   Ctrl+K Enter Keep preview mode editor open (將目前以 Preview 模式開啟的檔案轉換成編輯模式)   Ctrl+K P Copy path of an active file (將目前的檔案目徑含檔名複製到剪貼簿中)   Ctrl+K R Reveal active file in Explorer (將目前的檔案開啟在新的 檔案總管視窗 中)   Ctrl+K O Show active file in a new window/instance (將目前的檔案開啟在新的 vscode 中)   Ctrl+Alt N run code in code runner (屬擴充套件的功能)   Ctrl+= 放大   Ctrl+- 縮小   Ctrl+0 (Num Lock) 恢復原來大小   Ctrl+Shift+L 用你已選擇的字串來標示(選擇)整個檔案中所有符合的文字   Ctrl+F2 不須要先選擇目標字串即可有同上的功能   Shift+Alt+←→ Select until the end of the word   Ctrl+F Find   Ctrl+Shift+O Show Symbol Document Outline   Ctrl+Shift+F File Find   Ctrl+Shift+G Git   Ctrl+Shift+D Debug   Ctrl+Shift+X Extension   Ctrl+Alt+↑↓ Multi line column selection   Ctrl+D Multi Currsor selection   Alt+z 切換斷行功能   Alt+Shift+↓ 複製焦點在的這一行   Alt+↑↓ 移動焦點在的這一行往上/往下   Alt+←→ Go back / forward (往前/後 曾經的操作過程)   Alt+F5 在程式碼比對視窗中，移動到下一個程式碼有變動處   Alt+Shift+F5 在程式碼比對視窗中，移動到上一個程式碼有變動處   F12 Go to Definition (跳至\u0026quot;Function\u0026quot; / \u0026ldquo;變數\u0026rdquo; 定義地方)   Shift+F12 Go to References (檢視 \u0026ldquo;Function\u0026rdquo; / \u0026ldquo;變數\u0026rdquo; 使用的地方)   Ctrl+F12 Go to implementations (跳至\u0026quot;Function\u0026quot; / \u0026ldquo;變數\u0026rdquo; 實現的地方)   Alt+F12 Peek definition (檢視 \u0026ldquo;Function\u0026rdquo; / \u0026ldquo;變數\u0026rdquo; 的出處及定義內容)   Ctrl + ‵ (or Ctrl+J) 切換整合是終端機   Ctrl + shift + ‵ 建立新的整合終端機   Ctrl + shift + c 建立新的終端機 (焦點在 Terminal 時無效)   Ctrl + shift + 5 切割終端機   Alt + ↑↓←→ 切換整合終端機聚焦點   Alt + U 若所在檔案不是 ts 檔，則顯示對應的 ts 檔案。若是 ts 檔，則顯示前一個檔案   Alt + I 若所在檔案不是 css 檔，則顯示對應的 css 檔案。若是 css 檔，則顯示前一個檔案   Alt + O 若所在檔案不是 html 檔，則顯示對應的 html 檔案。若是 html 檔，則顯示前一個檔案   Alt + P 若所在檔案不是 spec.","title":"VS Code 中常用快捷鍵"},{"content":"在另一篇筆記中 ASP.NET Core 5 Web API - 從無到有 已經了解如何從無到有 使用 Dotnet core 5.0 建立 一個 Web API，本篇筆記將以此有基礎來記錄如何使用 Asp.Net Core Identity framework 及 JWT 來建置一個簡單又安全的 \u0026ldquo;使用者權限管理\u0026quot;功能。\ngithub Source code #tag: identity_jwt\n使用 Asp.Net Core Identity framework 來管理使用者使用權限 ASP.NET Core Identity:\n 支援使用者介面 (UI) 登入功能的 API。 管理使用者、密碼、設定檔資料、角色、宣告、權杖、電子郵件確認等。  ASP.Net Core Identity Framework 是一個很方便且還算完善的使用權限管理架構。\n安裝給 AspNetCore Idendity Framework 使用的相關套件 $ dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore --version 5.0.13 $ dotnet add package Microsoft.AspNetCore.Identity.UI --version 5.0.13 除了安裝相關套件外，還要調整相關程式:\n 在 Startup.cs 檔案中將 AspNetCore Identity Service 注入到 container 中 (before services.AddControllers())  # 在 startup.cs 檔案中 services.AddControllers() 指令前加入以下指令 services.AddDefaultIdentity\u0026lt;IdentityUser\u0026gt;(options =\u0026gt; options.SignIn.RequireConfirmedAccount = true) .AddEntityFrameworkStores\u0026lt;ApiDbContext\u0026gt;();  在 Startup.cs 檔案中 HTTP request pipeline 中 新加入 UseAuthentication()  # 在 startup.cs 檔案中 app.UseAuthorization() 指令前加入以下指令 app.UseAuthentication();  使用 AspNetCore Identity，則 DataContext (ApiDbContext.cs 中) 必須要繼承 IdentityDbContext， 同時 Model creationg 時要改成呼叫 base.OnModelCreation  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public partial class ApiDbContext : IdentityDbContext { public DbSet\u0026lt;ItemData\u0026gt; ItemData { get; set; }  public ApiDbContext() { } // ...  protected override void OnModelCreating(ModelBuilder modelBuilder) { // OnModelCreatingPartial(modelBuilder);  base.OnModelCreating(modelBuilder);  } }   新增一個 entity framework 遷移 並 更新資料庫 完成上述程式調整後，來執行資料庫遷移(migrations)\n$ dotnet build $ dotnet ef migrations add \u0026#34;Add Identity Framework\u0026#34; $ dotnet ef database update (app.db 產生 Identity Framework 會使用到的資料表) 新增 使用者註冊和登入時使用的 Data model class (Models/AuthData.cs) using System.Collections.Generic; using System.ComponentModel.DataAnnotations; namespace Todo5.Models { public class RegistrationResponse { public string Token { get; set; } public bool Success { get; set; } public List\u0026lt;string\u0026gt; Errors { get; set; } } public class UserLoginRequest { [Required] [EmailAddress] public string Email { get; set; } [Required] public string Password { get; set; } } public class UserRegistrationDto { [Required] public string Username { get; set; } [Required] [EmailAddress] public string Email { get; set; } [Required] public string Password { get; set; } } } 新增 註冊和登入邏輯 (Controllers/AuthManagementControll.cs) using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Identity; using Microsoft.AspNetCore.Mvc; using Todo5.Models; namespace Todo5.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] // api/authManagement [ApiController] public class AuthManagementController : ControllerBase { private readonly UserManager\u0026lt;IdentityUser\u0026gt; _userManager; public AuthManagementController( UserManager\u0026lt;IdentityUser\u0026gt; userManager) { _userManager = userManager; } [HttpPost] [Route(\u0026#34;Register\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Register([FromBody] UserRegistrationDto user) { if (ModelState.IsValid) { // We can utilise the model  var existingUser = await _userManager.FindByEmailAsync(user.Email); if (existingUser != null) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Email already in use\u0026#34; }, Success = false }); } var newUser = new IdentityUser() { Email = user.Email, UserName = user.Username }; var isCreated = await _userManager.CreateAsync(newUser, user.Password); if (isCreated.Succeeded) { return Ok(new RegistrationResponse() { Success = true, }); } else { return BadRequest(new RegistrationResponse() { Errors = isCreated.Errors.Select(x =\u0026gt; x.Description).ToList(), Success = false }); } } return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid payload\u0026#34; }, Success = false }); } [HttpPost] [Route(\u0026#34;Login\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Login([FromBody] UserLoginRequest user) { if (ModelState.IsValid) { var existingUser = await _userManager.FindByEmailAsync(user.Email); if (existingUser == null) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid login request\u0026#34; }, Success = false }); } var isCorrect = await _userManager.CheckPasswordAsync(existingUser, user.Password); if (!isCorrect) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid login request\u0026#34; }, Success = false }); } return Ok(new RegistrationResponse() { Success = true, }); } return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid payload\u0026#34; }, Success = false }); } } } 使用者帳號註冊 註冊成功 使用已註冊成功帳號來進行登入 建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add Asp.Net Core Identity framework\u0026#34; 新增 JWT 功能 到目前為止我們已透過 Dotnet Core Identity framework 完成了簡易的使用者資料驗證的功能(註冊/登入)，下面要繼續完成採用 JWT 進行 Token-based 的身分驗證與授權實作。\nJWT(Json Web Token)是一個實現授權功能上相對簡單又安全方式。實作的步驟包含了三個部分：\n 產生合法有效的 JWT Token 驗證合法有效的 JWT Token 限制特定 API 只能在通過 JWT 驗證的 HTTP 要求才能存取  首先，先加入相關套件:\n$ dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 5.0.13 $ dotnet add package Microsoft.IdentityModel.Tokens --version 6.11.1 產生合法有效的 JWT Token 在前述的　Controller 程式(Controllers/AuthManagementControll.cs)中加入 GenerateJwtToken Function\nprivate string GenerateJwtToken(IdentityUser user) { var key = Encoding.ASCII.GetBytes(_appSettings.Secret); var claims = new ClaimsIdentity(new [] { new Claim(\u0026#34;Id\u0026#34;, user.Id), new Claim(JwtRegisteredClaimNames.Email, user.Email), new Claim(JwtRegisteredClaimNames.Sub, user.Email), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }); var tokenDescriptor = new SecurityTokenDescriptor { Subject = claims, Expires = DateTime.UtcNow.AddHours(6), SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature) }; var jwtTokenHandler = new JwtSecurityTokenHandler(); var token = jwtTokenHandler.CreateToken(tokenDescriptor); var jwtToken = jwtTokenHandler.WriteToken(token); return jwtToken; } 並在 Login \u0026amp; Register function 中去呼叫　GenerateJwtToken function，並回傳 Token ()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100  [HttpPost] [Route(\u0026#34;Register\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Register([FromBody] UserRegistrationDto user) { if (ModelState.IsValid) { // We can utilise the model  var existingUser = await _userManager.FindByEmailAsync(user.Email); if (existingUser != null) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Email already in use\u0026#34; }, Success = false }); } var newUser = new IdentityUser() { Email = user.Email, UserName = user.Username }; var isCreated = await _userManager.CreateAsync(newUser, user.Password); if (isCreated.Succeeded) { var jwtToken = GenerateJwtToken(newUser);  return Ok(new RegistrationResponse() { Success = true, Token = jwtToken  }); } else { return BadRequest(new RegistrationResponse() { Errors = isCreated.Errors.Select(x =\u0026gt; x.Description).ToList(), Success = false }); } } return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid payload\u0026#34; }, Success = false }); } [HttpPost] [Route(\u0026#34;Login\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Login([FromBody] UserLoginRequest user) { if (ModelState.IsValid) { var existingUser = await _userManager.FindByEmailAsync(user.Email); if (existingUser == null) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid login request\u0026#34; }, Success = false }); } var isCorrect = await _userManager.CheckPasswordAsync(existingUser, user.Password); if (!isCorrect) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid login request\u0026#34; }, Success = false }); } var jwtToken = GenerateJwtToken(existingUser);  return Ok(new RegistrationResponse() { Success = true, Token = jwtToken  }); } return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid payload\u0026#34; }, Success = false }); }   驗證合法有效的 JWT Token 先在 Helpers 目錄下新增 AppSettings Class 用來存放 JWT 使用到的 Key\nnamespace Todo5.Helpers { public class AppSettings { public string Secret { get; set; } } } 並在 appsettings.json 設定檔中加入 Secret 值:\n{ \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;DefaultConnection\u0026#34;: \u0026#34;Data Source=app.db; Cache=Shared\u0026#34; }, \u0026#34;AppSettings\u0026#34;: { \u0026#34;Secret\u0026#34;: \u0026#34;This is a test for Authorization in asp.net webapi. Using JWT Technology to keep user info.\u0026#34; }, \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } 再到 Startup.cs 檔案中注入 \u0026ldquo;驗證合法有效 JWT Token 的功能\u0026rdquo;\n// 開始: 為 JWT 新增的程式碼 services.Configure\u0026lt;AppSettings\u0026gt;(Configuration.GetSection(\u0026#34;AppSettings\u0026#34;)); var key = Encoding.ASCII.GetBytes(Configuration[\u0026#34;AppSettings:Secret\u0026#34;]); var TokenValidationParameters = new TokenValidationParameters { ValidateIssuerSigningKey = true, // this will validate the 3rd part of the jwt token using the secret that we added in the appsettings and verify we have generated the jwt token  IssuerSigningKey = new SymmetricSecurityKey(key), // Add the secret key to our Jwt encryption  ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, RequireExpirationTime = false, }; services .AddAuthentication(options =\u0026gt; { options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; }) .AddJwtBearer(cfg =\u0026gt; { cfg.RequireHttpsMetadata = false; cfg.TokenValidationParameters = TokenValidationParameters; }); // 結束: 為 JWT 新增的程式碼 限制特定 API 只能在通過 JWT 驗證的 HTTP 要求才能存取 在欲限制的功能(function in Controller)前加入 \u0026ldquo;[Authorize]\u0026rdquo; 屬性 (TodoController.cs 程式中)\n// GET: api/Todo [HttpGet] [Authorize] # 加入屬性 public async Task\u0026lt;ActionResult\u0026lt;IEnumerable\u0026lt;ItemData\u0026gt;\u0026gt;\u0026gt; GetItemData() { return await _context.ItemData.ToListAsync(); } 為 Swagger 加入 JWT 功能 程式到此已完成加入 JWT 功能，下面是為了使用 Swagger 進行 API 測試時，可以有 JWT 相關功能而調整的部份\n// 註解掉原有程式碼 (以下三行) // services.AddSwaggerGen(c =\u0026gt; // { // c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;Todo5\u0026#34;, Version = \u0026#34;v1\u0026#34; }); // });  // 改成下面的程式，讓 Swagger 具備有 JWT 的相關功能 services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;TodoApp\u0026#34;, Version = \u0026#34;v1\u0026#34; }); c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { In = ParameterLocation.Header, Description = \u0026#34;Please enter JWT with Bearer into field\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, Type = SecuritySchemeType.ApiKey }); c.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} }, new string[] {} } }); }); 在 Swagger 的 UI 中，畫面右上角多出了 \u0026ldquo;Authorize\u0026rdquo; 按鈕。此功能是用來記錄 登入成功後所回傳的 Token\n此刻 API 已要求要擕帶有合法 Token，若在未透過\u0026quot;Authorize\u0026quot;功能填入 Token 時來操作 API，將會回傳\u0026quot;未授權\u0026quot;的錯誤。如下圖: 先以合法使用者帳號登入，在登入成功後，回傳的 Response body 中會帶有 Token，將此 Token 值複製下來 按下 Authorize 按鈕後，填入該 Token 值，並在 Token 值前鍵入 \u0026ldquo;bearer \u0026quot; 再次操作 Get API，即可成功取得回傳值。 ","permalink":"https://calvinegs.github.io/posts/dotnet5-webapi-ii/","summary":"在另一篇筆記中 ASP.NET Core 5 Web API - 從無到有 已經了解如何從無到有 使用 Dotnet core 5.0 建立 一個 Web API，本篇筆記將以此有基礎來記錄如何使用 Asp.Net Core Identity framework 及 JWT 來建置一個簡單又安全的 \u0026ldquo;使用者權限管理\u0026quot;功能。\ngithub Source code #tag: identity_jwt\n使用 Asp.Net Core Identity framework 來管理使用者使用權限 ASP.NET Core Identity:\n 支援使用者介面 (UI) 登入功能的 API。 管理使用者、密碼、設定檔資料、角色、宣告、權杖、電子郵件確認等。  ASP.Net Core Identity Framework 是一個很方便且還算完善的使用權限管理架構。\n安裝給 AspNetCore Idendity Framework 使用的相關套件 $ dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore --version 5.0.13 $ dotnet add package Microsoft.AspNetCore.Identity.UI --version 5.0.13 除了安裝相關套件外，還要調整相關程式:","title":"ASP.NET Core 5 Web API 加入權限管理 (Dotnet Core Identity Framework + JWT)"},{"content":"在此要討論的是有關 TypeScript 的 型別推論(type inference) 與 型別註記(type annotation)\n關於 Javascript 的型別 Javascript 是個動態型別的語言，也就是說擁有 \u0026lsquo;型別\u0026rsquo; 的是 \u0026lsquo;值\u0026rsquo; 而不是變數。\nlet myVar; console.log(`${myVar}: ${typeof myVar}`); // undefined : undefined myVar = 20; console.log(`${myVar}: ${typeof myVar}`); // 20 : number myVar = \u0026#34;Hi\u0026#34;; console.log(`${myVar}: ${typeof myVar}`); // Hi : string myVar = true; console.log(`${myVar}: ${typeof myVar}`); // true : boolean Type Annotation (型別註記) TypeScript 提供靜型別功能，讓我們可以明確指定變數的型別。編譯器在轉譯過程即可偵測到使用不同型別時主動抛出錯誤訊息。下面的例子就是使用型別註記來定義靜態型別:\nfunction calculateTax(amount: number): number { return amount * 1.2; } console.log(`${20}: ${calculateTax(20)}`); //20: 24 console.log(`${\u0026#34;Hello\u0026#34;}: ${calculateTax(\u0026#34;Hello\u0026#34;)}`); //error console.log(`${true}: ${calculateTax(true)}`); //error Type inference (型別推論) TypeScript 編譯器可以根據變數宣告時給定的值來推論它的型別。\nfunction calculateTax(amount: number): number { return amount * 1.2; } let price = 100; //未給定資料型別，由給定的值推論此時的 price 變數型別為 number let taxAmount = calculateTax(price); //未給定資料型別，由回傳值推論此時的變數型別為 number，因為 calculateTax 型別註記為 number let halfShare = taxAmount / 2; //未給定資料型別，由計算結果值推論此時的變數型別為 number console.log(`Full amount in tax: ${taxAmount}`); //Full amount in tax: 120 console.log(`Half share: ${halfShare}`); //Half share: 60 調整 tsc 編輯參數來查看編譯器所採用的型別 tsc 編譯器推論的型別若與預期的有出入，可以在 tscconfig.json \u0026ldquo;compilerOptions\u0026quot;中加入一條\u0026quot;declaration\u0026rdquo;: true 的設定值\n{ \u0026quot;compilerOptions\u0026quot;: { \u0026quot;target\u0026quot;: \u0026quot;es2020\u0026quot;, \u0026quot;outDir\u0026quot;: \u0026quot;./dist\u0026quot;, \u0026quot;rootDir\u0026quot;: \u0026quot;./src\u0026quot;, \u0026quot;declaration\u0026quot;: true } } 上述範例改成:\nfunction calculateTax(amount: number) { return (amount * 1.2).toFixed(2); } let price = 100; //未給定資料型別，由給定的值推論此時的 price 變數型別為 number let taxAmount = calculateTax(price); //未給定資料型別，由回傳值推論此時的變數型別為 string，因為 calculateTax function toFixed(2) 結果是 string let halfShare = taxAmount / 2; // 產生錯誤 console.log(`Full amount in tax: ${taxAmount}`); //Full amount in tax: 120 console.log(`Half share: ${halfShare}`); //Half share: 60 由於 toFixed(2) 回傳的是 string，導致 taxAmount 變數型別被推論成 string 而產生錯誤警告。 tsc 因為在 tscconfig.json 多加入了編輯參數 \u0026ldquo;declaration\u0026rdquo;: true，這個參數告訴編譯器，除了輸出程式碼轉譯外，還要輸芔包含型別宣告資訊的 .d.ts 檔，所以會在 build 目錄中產生一個 index.d.js，內容如下圖，可以看到 taxAmount 被推論成 string\ndeclare function calculateTax(amount: number): string; declare let price: number; declare let taxAmount: string; declare let halfShare: number; 關於 Any 的型別推論 將範例改成如下圖，calculateTax 回傳值及傳入參數皆註記成為 any\nfunction calculateTax(amount: any): any { return (amount * 1.2).toFixed(2); } let price = 100; //未給定資料型別，由給定的值推論此時的 price 變數型別為 number let taxAmount = calculateTax(price); //由於 calcaulateTax 型別註記為 any，故被推論成 any let halfShare = taxAmount / 2; // 未給定資料型別，(any / 2) 計算結果會被推論成 number console.log(`Full amount in tax: ${taxAmount}`); //Full amount in tax: 120.00 console.log(`Half share: ${halfShare}`); //Half share: 60 結果發現在 index.d.js 檔中 taxAmount 也被推論成 any，且編譯結果正常。\ndeclare function calculateTax(amount: any): any; declare let price: number; declare let taxAmount: any; declare let halfShare: number; 但這樣的使用 any 型別，你會發現這和寫 javascript 程式碼無任何差別，也就是說你讓程式自行承擔結東，而沒有用到 TypeScript 靜態型別的好處(編譯時期即可檢查出程式可能出問題的地方)。\n我們來測試一下，將 calculateTax function 改成如下:\nfunction calculateTax(amount: any): any { return `$${(amount * 1.2).toFixed(2)}`; } 再執行看看，發現編譯程式時正常，確在執行時期產生非預期結果\nFull amount in tax: $120.00 Half share: NaN 結論就是你應該儘可能的不要有 any 這樣的型別註記。\nContextual Typing (依照背景來進行的型態推論) TypeScript 使用變量的位置來推斷它們的類型，這就是所謂的 contextual typing\ndocument.addEventListener(\u0026#34;click\u0026#34;, function (event) { console.log(event.button); // }); 在這個例子中，TypeScript 因為 click 事件而知道 event 參數是 MouseEvent 的一個實例。\ndocument.addEventListener(\u0026#34;scroll\u0026#34;, function (event) { console.log(event.button); // compiler error }); 而在這個例子中，因為是 \u0026lsquo;scroll\u0026rsquo; 事件，所以參數中不能是 button，因此轉譯時會產生錯誤。\nwindow.onmousedown = function(mouseEvent) { console.log(mouseEvent.button); //\u0026lt;- OK  console.log(mouseEvent.kangaroo); //\u0026lt;- Error! }; Typescript 型別檢查器使用 Window.onmousedown 函數的型別來推斷賦值右邊的函數運算式的型別。因此，它能夠推斷出 mouseEvent 參數的型別，它確實包含一個按鈕屬性，但不包含袋鼠屬性。\n","permalink":"https://calvinegs.github.io/posts/ts-type-inferenc-annotation/","summary":"在此要討論的是有關 TypeScript 的 型別推論(type inference) 與 型別註記(type annotation)\n關於 Javascript 的型別 Javascript 是個動態型別的語言，也就是說擁有 \u0026lsquo;型別\u0026rsquo; 的是 \u0026lsquo;值\u0026rsquo; 而不是變數。\nlet myVar; console.log(`${myVar}: ${typeof myVar}`); // undefined : undefined myVar = 20; console.log(`${myVar}: ${typeof myVar}`); // 20 : number myVar = \u0026#34;Hi\u0026#34;; console.log(`${myVar}: ${typeof myVar}`); // Hi : string myVar = true; console.log(`${myVar}: ${typeof myVar}`); // true : boolean Type Annotation (型別註記) TypeScript 提供靜型別功能，讓我們可以明確指定變數的型別。編譯器在轉譯過程即可偵測到使用不同型別時主動抛出錯誤訊息。下面的例子就是使用型別註記來定義靜態型別:\nfunction calculateTax(amount: number): number { return amount * 1.2; } console.","title":"型別推論(type inference) 與 型別註記(type annotation)"},{"content":"github Source code #tag: web_api\n本文將記錄如何一步步從無到有使用 Dotnet Core 5.0 建立 ASP.NET Core 5 Web API，其中將會使用到下列技術:\n Dotnet cli Entity Framework Sqlite ASP.NET Core Generator  使用 dotnet cli 建立專案 $ dotnet --version # 檢查 dotnet 版本，目前版本為: 5.0.201 $ dotnet new webapi -n \u0026#34;Todo5\u0026#34; \u0026amp;\u0026amp; cd \u0026#34;Todo5\u0026#34; $ ls # 查看 專案檔案結構 $ dotnet new gitignore # 使用 dotnet cli 來產生預設的 git ignore 檔案 建立 git 初始版本 $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝本機工具 此方式安裝的工具，僅限本機存取(只針對目前的目錄和子目錄)， 首先透過 dotnet new tool-manifest 命令來產生工具資訊清單檔，再使用 dotnet tool install 來安裝各式工具程式。這樣的方式好處是在專案若多人協助方式時，則可利用 dotnet tool restore 命令將紀錄在 .config/dotnet-tools.json 的工具資訊清單檔重建在不同協助人員的電腦中。\n$ dotnet new tool-manifest #會產生 .config/dotnet-tools.json 檔案 $ dotnet tool install dotnet-ef --version 5.0.13 #使用 local 安裝方式來安裝 Entity Framework 工具 $ dotnet tool install dotnet-aspnet-codegenerator --version 5.0.2 #使用 local 安裝方式來安裝 Code Generator 工具 $ cat .\\.config\\dotnet-tools.json # 查看安裝上述二項工具後的設定資訊 1 2 3 4 5 6 7 8 9 10 11 12 13 14  { \u0026#34;version\u0026#34;: 1, \u0026#34;isRoot\u0026#34;: true, \u0026#34;tools\u0026#34;: { \u0026#34;dotnet-ef\u0026#34;: {  \u0026#34;version\u0026#34;: \u0026#34;5.0.13\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-ef\u0026#34;] }, \u0026#34;dotnet-aspnet-codegenerator\u0026#34;: {  \u0026#34;version\u0026#34;: \u0026#34;5.0.2\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-aspnet-codegenerator\u0026#34;] } } }   安裝程式使用的相關套件 $ dotnet add package Microsoft.EntityFrameworkCore.Sqlite --version 5.0.13 #Sqlite 使用的套件 $ dotnet add package Microsoft.EntityFrameworkCore.Tools --version 5.0.13 #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.Design --version 5.0.13 #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 5.0.13 #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 5.0.2 #搭配 dotnet-aspnet-codegenerator 使用 安裝的程式套件資訊紀錄在 \u0026ldquo;專案\u0026rdquo;.csproj 檔案中\n$ cat .\\Todo5.csproj #查看 安裝套件的相關設定值 1\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; 2 3 \u0026lt;PropertyGroup\u0026gt; 4 \u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; 5 \u0026lt;RootNamespace\u0026gt;_5Todo\u0026lt;/RootNamespace\u0026gt; 6 \u0026lt;/PropertyGroup\u0026gt; 7 8 \u0026lt;ItemGroup\u0026gt; 9 \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Design\u0026#34; Version=\u0026#34;5.0.13\u0026#34;\u0026gt; 10 \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; 11 \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; 12 \u0026lt;/PackageReference\u0026gt; 13 \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Sqlite\u0026#34; Version=\u0026#34;5.0.13\u0026#34; /\u0026gt; 14 \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.SqlServer\u0026#34; Version=\u0026#34;5.0.13\u0026#34; /\u0026gt; 15 \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;5.0.13\u0026#34;\u0026gt; 16 \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; 17 \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; 18 \u0026lt;/PackageReference\u0026gt; 19 \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;5.0.2\u0026#34; /\u0026gt; 20 \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;5.6.3\u0026#34; /\u0026gt; 21 \u0026lt;/ItemGroup\u0026gt; 22 23\u0026lt;/Project\u0026gt; 建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add EFCore NuGet packages\u0026#34; 新增 database context (自動產生) $ dotnet ef dbcontext scaffold \u0026#34;Data Source=app.db; Cache=Shared\u0026#34; Microsoft.EntityFrameworkCore.Sqlite -c ApiDbContext -o Data #在專案目錄 ./Data 子目錄下新建立一個 ApiDbContext.cs 的 DB Context file $ dotnet run #可使用 dotnet watch run 命令來自動監控程式碼的變動 開啟瀏覽器查看以下網址 \u0026ldquo;https://localhost:5001/WeatherForecast\u0026rdquo; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  [ { \u0026#34;date\u0026#34;: \u0026#34;2022-01-11T11:44:43.1899069+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: -6, \u0026#34;temperatureF\u0026#34;: 22, \u0026#34;summary\u0026#34;: \u0026#34;Hot\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-12T11:44:43.190114+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 28, \u0026#34;temperatureF\u0026#34;: 82, \u0026#34;summary\u0026#34;: \u0026#34;Balmy\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-13T11:44:43.1901167+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 23, \u0026#34;temperatureF\u0026#34;: 73, \u0026#34;summary\u0026#34;: \u0026#34;Hot\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-14T11:44:43.1901169+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 42, \u0026#34;temperatureF\u0026#34;: 107, \u0026#34;summary\u0026#34;: \u0026#34;Warm\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-15T11:44:43.1901171+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 22, \u0026#34;temperatureF\u0026#34;: 71, \u0026#34;summary\u0026#34;: \u0026#34;Cool\u0026#34; } ]   開啟瀏覽器查看以下 Swagger 網址 \u0026ldquo;https://localhst:5001/swagger/index.html\u0026rdquo; 建立另一個 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Create dbcontext classes using dotnet-ef\u0026#34; Open VS Code $ Code . 在 Models 目錄下新增一個 model(模型) class - ItemData 1 2 3 4 5 6 7 8 9 10  namespace Todo5.Models { public class ItemData { public int Id { get; set; } public string Title { get; set; } public string Details { get; set; } public bool Done { get; set; } } }   在 ApiDbContext.cs 中宣告一個 ItemData table public DbSet\u0026lt;ItemData\u0026gt; ItemDatas { get; set; }\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  using System; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata; using Todo5.Models; #nullable disable namespace Todo5.Data { public partial class ApiDbContext : DbContext { public DbSet\u0026lt;ItemData\u0026gt; ItemDatas { get; set; }  public ApiDbContext() { } //...  } }   在 appsettings.json 檔案中新增 ConnectionString 設定資料 \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;DefaultConnection\u0026#34;: \u0026#34;Data Source=app.db;Cache=Shared\u0026#34; }, 在 Startup.cs 檔案中註冊 database context (連絡到 Sqlite DB) 15 16 17 18 19  services.AddDbContext\u0026lt;ApiDbContext\u0026gt;(options =\u0026gt; options.UseSqlite( Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;)  ) );   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  namespace TodoApp { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } // This method gets called by the runtime. Use this method to add services to the container.  public void ConfigureServices(IServiceCollection services) { services.AddDbContext\u0026lt;ApiDbContext\u0026gt;(options =\u0026gt; options.UseSqlite( Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;)  ) ); services.AddControllers(); // ...  } }; }   移除預設產生的樣本程式碼 Weather Forecast 程式碼是預設自動產生的，可直接將 WeatherForecast.cs \u0026amp; WeatherForecastController.cs 刪除\nAdd the initial migration to create the database $ dotnet build $ dotnet ef migrations add \u0026#34;Initial Migrations\u0026#34; $ dotnet ef database update # 在根目錄產生 app.db sqlite database 使用 ASPNET Codegenerator 自動產生 Todo Controller $ dotnet aspnet-codegenerator controller -name TodoController -async -api -m ItemData -dc ApiDbContext -outDir Controllers 執行 Swagger 開啟瀏覽器查看以下網址 \u0026ldquo;https://localhst:5001/swagger/index.html\u0026rdquo;\n透過 POST Method 新增一筆資料\n使用 GET Method 查詢資料 ","permalink":"https://calvinegs.github.io/posts/dotnet5-webapi/","summary":"github Source code #tag: web_api\n本文將記錄如何一步步從無到有使用 Dotnet Core 5.0 建立 ASP.NET Core 5 Web API，其中將會使用到下列技術:\n Dotnet cli Entity Framework Sqlite ASP.NET Core Generator  使用 dotnet cli 建立專案 $ dotnet --version # 檢查 dotnet 版本，目前版本為: 5.0.201 $ dotnet new webapi -n \u0026#34;Todo5\u0026#34; \u0026amp;\u0026amp; cd \u0026#34;Todo5\u0026#34; $ ls # 查看 專案檔案結構 $ dotnet new gitignore # 使用 dotnet cli 來產生預設的 git ignore 檔案 建立 git 初始版本 $ git init \u0026amp;\u0026amp; git add .","title":"ASP.NET Core 5 Web API - 從無到有"},{"content":"Angular 的版本更新迭代的相當快 (所有的前端開於工具都有相同的情形)，安裝及使用 Angular Cli 時必須在有 Node.js 的環境下才能進行。\n當你在同一台電腦中使用不同版本的 Angular 時就容易在安裝相關套件時遇到警語，原因常是因為 Angular 與 Node.js 版本搭配的關係。\n至於為何有同時使用不同版本的 Angular 呢? 除了開發的專案沒有全部都一起升級至統一版本(這是一件複雜的事)的因素外，個人最常遇到的狀況是: 當在網上(github)找到很棒的 Demo / Sample 程式，在 git clone 回電腦後發現它的版本是舊版本 Angular 所撰寫，使用 npm install 安裝相關套件時，出現警告訊息，甚至無法安裝成功。\n為了要管理同一台電腦中存在著有不同版 Node.js，讓你很容易在各版本中自由的進行切換 (甚至在進入不同目錄時自動切換對應的 Node.js 版本)，你需要 Node.js 版本管理工具，如: NVM 或 NVS，在這個筆記中要記錄的是 NVS。\n安裝 nvs F:\\\u0026gt; choco list nvs #先查看是否已安裝了 nvs F:\\\u0026gt; choco install nvs #安裝 nvs F:\\\u0026gt; nvs --version #查看是否安裝成功，並顯示 nvs 版本  註：安裝完成後若遇到在 cmd 中可正常執行，但在Windows PowerShell 無法使用時，可使用‘系統管理員’身份開啟 Posershell，並執行 PS\u0026gt;Set-ExecutionPolicy RemoteSigned 應可解決這個問題。\n 安裝不同版本 Node.js 以個人工作環境為例，目前使用的 Angular 是 13.0 搭配的 Node.js 版本是 V16.10.0。\n當我需要參考其他範例時，如在 github 找到一個範例程式，git clone 後，查看該專案發現它撰寫時使用 Angular 8.2.0 這個版本\nPS F:\\test\\angular-forms-workshop\u0026gt; cat package.json\n{ \u0026#34;name\u0026#34;: \u0026#34;angular-forms-workshop\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34; }, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@ng-bootstrap/ng-bootstrap\u0026#34;: \u0026#34;^5.1.0\u0026#34;, \u0026#34;@ng-dynamic-forms/core\u0026#34;: \u0026#34;^9.0.1\u0026#34;, \u0026#34;@ng-dynamic-forms/ui-ng-bootstrap\u0026#34;: \u0026#34;^9.0.1\u0026#34;, \u0026#34;angular2-text-mask\u0026#34;: \u0026#34;^9.0.0\u0026#34;, \u0026#34;bootstrap\u0026#34;: \u0026#34;^4.3.1\u0026#34;, \u0026#34;rxjs\u0026#34;: \u0026#34;~6.4.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^1.10.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.9.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;~0.802.0\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/language-service\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;~8.9.4\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~3.3.8\u0026#34;, \u0026#34;@types/jasminewd2\u0026#34;: \u0026#34;~2.0.3\u0026#34;, \u0026#34;codelyzer\u0026#34;: \u0026#34;^5.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~3.4.0\u0026#34;, \u0026#34;jasmine-spec-reporter\u0026#34;: \u0026#34;~4.2.1\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~4.1.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~2.2.0\u0026#34;, \u0026#34;karma-coverage-istanbul-reporter\u0026#34;: \u0026#34;~2.0.1\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~2.0.1\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;^1.4.0\u0026#34;, \u0026#34;protractor\u0026#34;: \u0026#34;~5.4.0\u0026#34;, \u0026#34;ts-node\u0026#34;: \u0026#34;~7.0.0\u0026#34;, \u0026#34;tslint\u0026#34;: \u0026#34;~5.15.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~3.5.3\u0026#34; } } 若直接使用 npm install 來回復此專案的套件，將會出現許多的警告訊息，如下圖:\n查閱對照表後發現 Angular 8.2 版本應該搭配的是 Node.js 10.9.0 ( Angular 與 Node.js 對照表 )\n此時可透過 nvs 來額外再安裝 Node.js 10.9.0 版本到你的系統中，並將 Node.js 使用版本 切換到 10.9.0\nPS F:\\test\\angular-forms-workshop\u0026gt; nvs add 10.9.0 PS F:\\test\\angular-forms-workshop\u0026gt; nvs use 10.9.0 完成後，使用這個 正確 的版本就可以順利安裝相關的套件了。\n同一時間，我又在 github 找到另一個合適的範例程式，git clone 後，查看該專案撰寫時是使用那個版本的 Angular，發現是 11.2.13\nPS F:\\test\\angular-forms-workshop\u0026gt; cd ..\\angular.io-example\\ PS F:\\test\\angular.io-example\u0026gt; cat package.json { \u0026#34;name\u0026#34;: \u0026#34;angular.io-example\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;rxjs\u0026#34;: \u0026#34;6.6.7\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;2.2.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;0.10.3\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;3.6.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;jasmine-marbles\u0026#34;: \u0026#34;0.6.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/animations\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;angular-in-memory-web-api\u0026#34;: \u0026#34;0.11.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;11.2.13\u0026#34; }, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;~0.1102.12\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~11.2.12\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;~11.2.13\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~3.6.0\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^12.11.1\u0026#34;, \u0026#34;codelyzer\u0026#34;: \u0026#34;^6.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~3.6.0\u0026#34;, \u0026#34;jasmine-spec-reporter\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~6.1.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~3.1.0\u0026#34;, \u0026#34;karma-coverage\u0026#34;: \u0026#34;~2.0.3\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~4.0.0\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;^1.5.0\u0026#34;, \u0026#34;protractor\u0026#34;: \u0026#34;~7.0.0\u0026#34;, \u0026#34;ts-node\u0026#34;: \u0026#34;~8.3.0\u0026#34;, \u0026#34;tslint\u0026#34;: \u0026#34;~6.1.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~4.1.5\u0026#34; } } 一樣的道理，透過 nvs 再多安裝 Node.js 12.11.1 版本\nPS F:\\test\\angular-forms-workshop\u0026gt; nvs add 12.11.1 nvs 的使用方法 查看目前所有已安裝的 Node.js 版本\nPS F:\\test\\angular-forms-workshop\u0026gt; nvs ls\nnode/16.10.0/x64 #Angular 13 所搭配的 Node.js 版本 node/14.15.5/x64 (Fermium) #Angular 12 所搭配的 Node.js 版本 node/12.11.1/x64 #Angular 11 所搭配的 Node.js 版本 node/10.9.0/x64 #Angular 8 所搭配的 Node.js 版本 node/8.9.4/x64 #Angular 7 所搭配的 Node.js 版本 手動切換 PS F:\\test\\angular-forms-workshop\u0026gt; nvs use 10 #使用(切換到)第十版，在範例中會自動切換到 10.9.0 PS F:\\test\\angular-forms-workshop\u0026gt; node -v #顯示目前使用中的 Node.js 版本 v10.9.0 PS F:\\test\\angular-forms-workshop\u0026gt; nvs ls #前導 \u0026#39;\u0026gt;\u0026#39; 符號表示是目前`使用中`的版本 node/16.10.0/x64 node/14.15.5/x64 (Fermium) node/12.11.1/x64 \u0026gt;node/10.9.0/x64 node/8.9.4/x64 (Carbon) 自動切換 每個目錄若搭配 .node-version 檔名的文字檔，且內容是 Node.js 的版本資訊:\nPS F:\\test\u0026gt; node -v \u0026gt; .node-version #將版本資訊寫入 .node-version 檔案中 PS F:\\test\u0026gt; cat .node-version #查看內容 v10.9.0 除有上述檔案及內容外，還必須搭配 開啓 nvs 自動切換 功能\nPS F:\\test\u0026gt; nvs auto on \n以上兩個條件都成立時，當切換不同現行目錄時，系統會自動選擇套用不同的 Node.js 版本\nPS F:\\test\u0026gt; cd .\\angular.io-example\\ PATH += $env:LOCALAPPDATA\\nvs\\node\\12.11.1\\x64 PS F:\\test\\angular.io-example\u0026gt; node -v v12.11.1 PS F:\\test\\angular.io-example\u0026gt; cat .\\.node-version v12.11.1 PS F:\\test\\angular.io-example\u0026gt; cd ..\\angular-forms-workshop\\ PATH -= $env:LOCALAPPDATA\\nvs\\node\\12.11.1\\x64 PATH += $env:LOCALAPPDATA\\nvs\\node\\10.9.0\\x64 PS F:\\test\\angular-forms-workshop\u0026gt; node -v v10.9.0 半自動型手動切換 若 nvs 自動切換 功能設為 off 則可視為所謂的 半自動 模式。\n無.node-version 檔案，也無 nvs 也無設定預設版本的情況:\nPS F:\\test\u0026gt; nvs use\n上述指令等同 nvs use default (nvs use auto、nvs auto 亦同義) 就是切換所在目錄的 Node.js 版本，系統第一優先查看的現行目錄中的 .node-version 檔案裡所指定的 Node.js 版本，若無 .node-version 檔案，則使用 nvs default (預設)版本，若 nvs 也無設定預設版本，則會將目前的 \u0026lsquo;使用版本\u0026rsquo; reset 成 null。\n","permalink":"https://calvinegs.github.io/posts/nvs-using/","summary":"Angular 的版本更新迭代的相當快 (所有的前端開於工具都有相同的情形)，安裝及使用 Angular Cli 時必須在有 Node.js 的環境下才能進行。\n當你在同一台電腦中使用不同版本的 Angular 時就容易在安裝相關套件時遇到警語，原因常是因為 Angular 與 Node.js 版本搭配的關係。\n至於為何有同時使用不同版本的 Angular 呢? 除了開發的專案沒有全部都一起升級至統一版本(這是一件複雜的事)的因素外，個人最常遇到的狀況是: 當在網上(github)找到很棒的 Demo / Sample 程式，在 git clone 回電腦後發現它的版本是舊版本 Angular 所撰寫，使用 npm install 安裝相關套件時，出現警告訊息，甚至無法安裝成功。\n為了要管理同一台電腦中存在著有不同版 Node.js，讓你很容易在各版本中自由的進行切換 (甚至在進入不同目錄時自動切換對應的 Node.js 版本)，你需要 Node.js 版本管理工具，如: NVM 或 NVS，在這個筆記中要記錄的是 NVS。\n安裝 nvs F:\\\u0026gt; choco list nvs #先查看是否已安裝了 nvs F:\\\u0026gt; choco install nvs #安裝 nvs F:\\\u0026gt; nvs --version #查看是否安裝成功，並顯示 nvs 版本  註：安裝完成後若遇到在 cmd 中可正常執行，但在Windows PowerShell 無法使用時，可使用‘系統管理員’身份開啟 Posershell，並執行 PS\u0026gt;Set-ExecutionPolicy RemoteSigned 應可解決這個問題。","title":"使用 nvs 來管理不同版本 Node.js 執行環境"},{"content":" ","permalink":"https://calvinegs.github.io/posts/ngcli-nodejs-verion/","summary":" ","title":"Angular cli 與 Node.js 版本對照"},{"content":"TypeScript 不僅已可使用在主機端來進行 Node.js 程式的開發，也支援前端開發的眾多架構，使用 TypeScript 有許多額外的好處，因此學習 TypeScript 是現在軟體開發工程師不可缺的一項技能。本文是用來記錄如何設置一個簡易的 TypeScript 開發環境，用來學習 TypeScript。\n開始設置 建立一個目錄\n$ mkdir typescript-starter $ cd typescript-starter 透過 npm 產生 package.json 檔案\n$ npm init -y 在 Local 端安裝 TypeScript\n$ npm install typescript --save-dev #or -D 為 Node.js 安裝類型檔\n$ npm install @types/node --save-dev # 在 node.js 中使用 typescript 時，此套件用來加載所有類型定義 透過 tsc 建立 TypeScript 的設定檔 (tsconfig.json)\n$ npx tsc --init P.S. 由於 typescript 是安裝在 local，執行時要透過 npx 指令(由 npm 所提供)\n指定額外的參數\n$ npx tsc --init --rootDir src --outDir build --esModuleInterop --resolveJsonModule --lib es6 --module commonjs --allowJs true --noImplicitAny true  rootDir: tsc 轉碼器找尋程式的地方。 outDir: TypeScript 轉譯成 JavaScript 所存放的地方。 esModuleInterop: 若使用 commonjs 為此專案的 module system，則此設定值必須設定為 true。 resolveJsonModule: 若此專案會使用 JSON，則此設定值必須設定為 true。 lib: 指定為 \u0026lsquo;es6\u0026rsquo; 指可使用到新版 JS 的一些語言特性，指定 \u0026lsquo;es5\u0026rsquo; 則會有較高的相容易。 module: 指存 module system，如: commonjs。 allowJs: 此選項將允許您在 .ts 文件中包含 .js 文件。 noImplicitAny: 值為 true 時，在 TypeScript 文件中，不允許不明確地指定類型。  將多餘不會使用的參數移除\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;lib\u0026#34;: [\u0026#34;es6\u0026#34;], \u0026#34;allowJs\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;src\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;noImplicitAny\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;resolveJsonModule\u0026#34;: true } } 建立 src 目錄，並在此目錄下寫程式\n$ mkdir src $ touch src/index.ts 程式如下:\nimport * as cowsay from \u0026#34;cowsay\u0026#34;; console.log( cowsay.say({ text: \u0026#34;I\u0026#39;m a moooodule\u0026#34;, e: \u0026#34;oO\u0026#34;, T: \u0026#34;U \u0026#34;, }) ); 因為程式中使用到額外的 library - cowsay，要先安裝\n$ npm install cowsay 利用 tsc 來轉譯 TypeScript 成為 JavaScript\n$ npx tsc 轉譯成 es5 版本 JavaScript 的結果:\n\u0026#34;use strict\u0026#34;; // const aVar = \u0026#39;abc\u0026#39;; // console.log(\u0026#39;Hello world!\u0026#39; + `${aVar}`) var __createBinding = (this \u0026amp;\u0026amp; this.__createBinding) || (Object.create ? function (o, m, k, k2) { if (k2 === undefined) k2 = k; Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; }, }); } : function (o, m, k, k2) { if (k2 === undefined) k2 = k; o[k2] = m[k]; }); var __setModuleDefault = (this \u0026amp;\u0026amp; this.__setModuleDefault) || (Object.create ? function (o, v) { Object.defineProperty(o, \u0026#34;default\u0026#34;, { enumerable: true, value: v }); } : function (o, v) { o[\u0026#34;default\u0026#34;] = v; }); var __importStar = (this \u0026amp;\u0026amp; this.__importStar) || function (mod) { if (mod \u0026amp;\u0026amp; mod.__esModule) return mod; var result = {}; if (mod != null) for (var k in mod) if (k !== \u0026#34;default\u0026#34; \u0026amp;\u0026amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k); __setModuleDefault(result, mod); return result; }; Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); var cowsay = __importStar(require(\u0026#34;cowsay\u0026#34;)); console.log( cowsay.say({ text: \u0026#34;I\u0026#39;m a moooodule\u0026#34;, e: \u0026#34;Ox\u0026#34;, T: \u0026#34;V \u0026#34;, }) ); 使用一些有用的設定及 Script 安裝 ts-node 和 nodemon\nts-node 是一個 TypeScript 執行引擎和 Node.js 的 REPL。它以JIT方式將TypeScript轉譯為 JavaScript，使你能夠直接在 Node.js上 執行 TypeScript 而不需要預轉譯。通過 node 的模組載入 API 來實現的，使其能夠與其他 Node.js 工具和程式庫一起無縫使用。\nnodemon 是一個工具，它通過檢測程式目錄中的文件更改時可以自動重新啟動應用程式(本範例中是啟動 Node.js)，以此協助應用程式開發。\n$ npm install --save-dev ts-node nodemon 新增一個 nodemon 的設定檔 nodemon.json\n$ touch nodemon.json 內容如下:\n{ \u0026#34;watch\u0026#34;: [\u0026#34;src\u0026#34;], \u0026#34;ext\u0026#34;: \u0026#34;.ts,.js\u0026#34;, \u0026#34;ignore\u0026#34;: [], \u0026#34;exec\u0026#34;: \u0026#34;npx ts-node ./src/index.ts\u0026#34; } 在 package.json 中加入啟動的 script\n\u0026#34;start\u0026#34;: \u0026#34;nodemon\u0026#34;, 執行 scripts\nPS F:\\test\\ts\\ts-starter\u0026gt; npm start # npm start 是 npm run start 的 alias \u0026gt; ts-starter@1.0.0 start \u0026gt; nodemon [nodemon] 2.0.15 [nodemon] to restart at any time, enter `rs` [nodemon] watching path(s): src\\**\\* [nodemon] watching extensions: ts,js [nodemon] starting `npx ts-node ./src/index.ts` ________________________ \u0026lt; I\u0026#39;m a slaughtered deer \u0026gt; ------------------------ \\  ^__^ \\  (Ox)\\_______ (__)\\  )\\/\\  V ||----w | || || [nodemon] clean exit - waiting for changes before restart 直接修改程式碼，將 index.ts 中的 slaughtered deer 改成 deer，存檔後，系統將自動轉譯程式碼，並透過 Node.js 顯示出結果:\n","permalink":"https://calvinegs.github.io/posts/setup-typescript-env/","summary":"TypeScript 不僅已可使用在主機端來進行 Node.js 程式的開發，也支援前端開發的眾多架構，使用 TypeScript 有許多額外的好處，因此學習 TypeScript 是現在軟體開發工程師不可缺的一項技能。本文是用來記錄如何設置一個簡易的 TypeScript 開發環境，用來學習 TypeScript。\n開始設置 建立一個目錄\n$ mkdir typescript-starter $ cd typescript-starter 透過 npm 產生 package.json 檔案\n$ npm init -y 在 Local 端安裝 TypeScript\n$ npm install typescript --save-dev #or -D 為 Node.js 安裝類型檔\n$ npm install @types/node --save-dev # 在 node.js 中使用 typescript 時，此套件用來加載所有類型定義 透過 tsc 建立 TypeScript 的設定檔 (tsconfig.json)\n$ npx tsc --init P.S. 由於 typescript 是安裝在 local，執行時要透過 npx 指令(由 npm 所提供)","title":"設置 TypeScript 開發環境 (Node.js)"},{"content":"Hugo 內容文件中使用基本 Markdown 語法，還額外支援由 Hugo 所提供的加強語法(也支援基本 HTML 元素)。\n標題 (Headings) 要建立標題，請在文字前添加井字符號 #(請注意井字符號後要加入一個空格)。使用的井字符號的數量應與標題級別相對應。例如，要建立三級標題 (\u0026lt;h3\u0026gt;)，請使用三個井字符號（例如，### My Header）。\n段落 (Paragraphs) 一個 Markdown 段落是由一個或多個連續的文字行組成，它的前後要有一個以上的空行。\n文字區塊引用 (Blockquotes) 在段落的第一行最前面加\u0026quot;\u0026gt;\u0026quot;\n未註明出處的文字區塊引用 (Blockquote without attribution)  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n 註明出處的文字區塊引用 (Blockquote with attribution)  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n 斷行 (Line Breaks) 要建立換行符號 (\u0026lt;br\u0026gt;)，請以兩個或多個空格結束一行，然後鍵入 return 鍵。\n表格 (Tables) 表格功能並不是 Markdown 規格, 不過 Hugo 支援這個好用的功能.\n   Name Age     Bob 27   Alice 23    表格內支援內嵌 Markdown 語法    Italics Bold Code     italics bold code    表格內的對齊功能    Number Next number Previous number     Five Six Four   Ten Eleven Nine   Seven Eight Six   Two Three One    程式碼區塊 (Code Blocks) 使用 \u0026lsquo;反引號\u0026rsquo; 的程式碼區塊 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   使用 \u0026lsquo;四個空格\u0026rsquo; 的程式碼區塊 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  使用 Hugo 內部支援 highlight shortcode 的程式碼區塊 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   使用 Gist 的程式區塊 \u0026lt;script src=\u0026quot;https://gist.github.com/spf13/7896402.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n 清單 有序清單  First item Second item Third item  無序清單  List item Another item And another item  巢狀清單  Fruit  Apple Orange Banana   Dairy  Milk Cheese     First item Second item Third item  Indented item Indented item   Fourth item  以數字開頭的無序清單 將\u0026rsquo;段落\u0026rsquo;加入清單中   This is the first list item.\n  Here\u0026rsquo;s the second list item.\nI need to add another paragraph below the second list item.\n  And here\u0026rsquo;s the third list item.\n  將\u0026rsquo;文字區塊引用\u0026rsquo;加入清單中   This is the first list item.\n  Here\u0026rsquo;s the second list item.\n A blockquote would look great below the second list item.\n   And here\u0026rsquo;s the third list item.\n  將\u0026rsquo;程式區塊\u0026rsquo;加入清單中   Open the file.\n  Find the following code block on line 21:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt;    Update the title to match the name of your website.\n  將\u0026rsquo;圖檔\u0026rsquo;加入清單中   Open the file containing the Linux mascot.\n  Marvel at its beauty.\n  Close the file.\n  Task List 反引號的使用 水平線 (Horizontal Rules) Try to put a blank line before\u0026hellip;\n \u0026hellip;and after a horizontal rule.\n連結 (Links) My favorite search engine is Duck Duck Go.\nI love supporting the EFF.\nThis is the Markdown Guide.\nSee the section on code.\n斜體 \u0026amp; 強調 使用 * 符號套用在文字的前後方，即可將文字改為斜體字；而使用連續兩個*加在文字的前後方則會是強調文字。\n有時候，你得停一下腳步，等一等 心靈，讓心情平和，想一想自己生活中擁有的所有 美好 的東西。\n使用跳脫字元 要顯示原本用於格式化 Markdown 文件中的文字字元，請在該字符前添加反斜線 (\\)。\n其他元素的使用 — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://calvinegs.github.io/posts/markdown-syntax/","summary":"Hugo 內容文件中使用基本 Markdown 語法，還額外支援由 Hugo 所提供的加強語法(也支援基本 HTML 元素)。\n標題 (Headings) 要建立標題，請在文字前添加井字符號 #(請注意井字符號後要加入一個空格)。使用的井字符號的數量應與標題級別相對應。例如，要建立三級標題 (\u0026lt;h3\u0026gt;)，請使用三個井字符號（例如，### My Header）。\n段落 (Paragraphs) 一個 Markdown 段落是由一個或多個連續的文字行組成，它的前後要有一個以上的空行。\n文字區塊引用 (Blockquotes) 在段落的第一行最前面加\u0026quot;\u0026gt;\u0026quot;\n未註明出處的文字區塊引用 (Blockquote without attribution)  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n 註明出處的文字區塊引用 (Blockquote with attribution)  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n 斷行 (Line Breaks) 要建立換行符號 (\u0026lt;br\u0026gt;)，請以兩個或多個空格結束一行，然後鍵入 return 鍵。","title":"Hugo 中使用的 Markdown 語法介紹"},{"content":"GitHub Page 功能是 GitHub 提供的一項支援靜態網頁的服務，只要在你的 repository 中加入一個名為 gh-pages 的分支，則 GitHub 便會預設將此分支內的檔案以靜態網頁的方式呈現，因此利用此特性就可很容易的製作一個簡單的網站。GitHub Pages 提供了二種不同形態的頁面 \u0026ldquo;User or organization site\u0026rdquo; \u0026amp; \u0026ldquo;Project Site\u0026rdquo;。其中個人/組織 網站一個 GitHub 帳號只能有一個、而專案網站則可以很多個。\n https://calvinegs.github.io #只有一個 https://calvinegs.github.io/project1\nhttps://calvinegs.github.io/project2\nhttps://calvinegs.github.io/project3\n\u0026hellip;\n 安裝步驟 Step 1: 在 GitHub 上建立一個 new repository Repository name 若為 Owner_name.github.io 即所謂的 User site，Repository name 即為靜態網站的網址。以下圖為例，有效網址為 https://calvinegs.github.io\nStep 2: 使用 GitHub Action 構建 Hugo 透過 GitHub Action 功能，在你每次將新版本的 Hugo 網站內容推送到 GitHub repository 時，GitHub 將自動建置網站。\n新增一個 .github/workflows/gh-pages.yml，內容如下:\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public Step 3: GitHub Page 的設置 在第一次推送 Hugo 網站內容推送到 GitHub repository 時，透過 GitHub Action 的建置，將在你的 repository 中新新一個分支名稱叫 gh-pages。請在 GitHub Page 的設置功能中將它由 \u0026ldquo;Main\u0026rdquo; 指向 \u0026ldquo;gh-pages\u0026rdquo; 分支。\nStep 4: 設置 Hugo 設定檔 將 Hugo 設定檔 config.toml 中的 baseURL 設定成 https://Owner_name.github.io。\nbaseurl = \u0026#34;https://calvinabba.github.io\u0026#34; DefaultContentLanguage = \u0026#34;en\u0026#34; title = \u0026#34;Beautiful Blog\u0026#34; theme = \u0026#34;beautifulhugo\u0026#34; ","permalink":"https://calvinegs.github.io/posts/deployhugo-githubpages/","summary":"GitHub Page 功能是 GitHub 提供的一項支援靜態網頁的服務，只要在你的 repository 中加入一個名為 gh-pages 的分支，則 GitHub 便會預設將此分支內的檔案以靜態網頁的方式呈現，因此利用此特性就可很容易的製作一個簡單的網站。GitHub Pages 提供了二種不同形態的頁面 \u0026ldquo;User or organization site\u0026rdquo; \u0026amp; \u0026ldquo;Project Site\u0026rdquo;。其中個人/組織 網站一個 GitHub 帳號只能有一個、而專案網站則可以很多個。\n https://calvinegs.github.io #只有一個 https://calvinegs.github.io/project1\nhttps://calvinegs.github.io/project2\nhttps://calvinegs.github.io/project3\n\u0026hellip;\n 安裝步驟 Step 1: 在 GitHub 上建立一個 new repository Repository name 若為 Owner_name.github.io 即所謂的 User site，Repository name 即為靜態網站的網址。以下圖為例，有效網址為 https://calvinegs.github.io\nStep 2: 使用 GitHub Action 構建 Hugo 透過 GitHub Action 功能，在你每次將新版本的 Hugo 網站內容推送到 GitHub repository 時，GitHub 將自動建置網站。\n新增一個 .github/workflows/gh-pages.yml，內容如下:\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.","title":"在 Github Pages 部署 Hugo 靜態網站"},{"content":"Hugo 是一個静態網站生成器，搭配 git 很適合來建立個人部落格。在一系列的筆記中將介紹如何安裝/使用相關工具與技術，目的是搭建一個完全免費的個人部落格。\n使用的相關工具/技術:\n Hugo git vs code gist github page Markdown  Chocolatey Chocolatey 是一個 Windows 上的套件管理工具，它結合了 Nuget 基礎服務與 powershell 指令，提供快速安裝應用程式與工具的服務，將安裝軟體的內容封裝到一個安裝包中，在 Chocolatey 中只需要一條簡單的指令就能完成搜尋、安裝、更新、解安裝等操作。\n在 Windows 10 上安裝 Chocolatey 以‘系統管理員’身份開啟 \u0026lsquo;Windows PowerShell\u0026rsquo;,　執行以下指令來進行 Chocolatey 安裝\nPS C:\\\u0026gt;Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 移除 Chocolatey 刪除 C:\\ProgramData\\chocolatey 目錄及移除環境變數即可，搜尋 \u0026ldquo;編輯系統環境變數\u0026rdquo; \\ \u0026ldquo;進階\u0026rdquo; \\ \u0026ldquo;環境變數\u0026rdquo;\n安裝 hugo Step 1: 在 Windows 10 上使用 choco 安裝 hugo C:\\\u0026gt; choco install hugo -confirm C:\\\u0026gt; choco install hugo-extended - config C:\\\u0026gt; hugo version Step 2: Create a New Site (建立部落格網站) C:\\\u0026gt; hugo new site quickstart C:\\\u0026gt; hugo new site quickstart -f yml # 若要使用 config.yaml 為 config 設定檔，則加入額外參數 Step 3: Add a Theme (新增部落格主題) 請先確認在您的作業系統中已經安裝了 git\nC:\\\u0026gt; cd quickstart C:\\\u0026gt; git init C:\\\u0026gt; git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke C:\\\u0026gt; git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 在 config.toml 中加入 theme = \u0026ldquo;ananke\u0026rdquo;\nC:\\\u0026gt; echo \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml Step 4: Add Some Content (建立新文章) C:\\\u0026gt; hugo new posts/my-first-post.md 在 md file 中加入以下內容\n # Test Page\nThis is my first test page.\n Step 5: Start the Hugo server (本機測試) C:\\\u0026gt; hugo server -D 開啟瀏覽器，輸入網址 https://localhost:1313 ","permalink":"https://calvinegs.github.io/posts/installhugo-windows/","summary":"Hugo 是一個静態網站生成器，搭配 git 很適合來建立個人部落格。在一系列的筆記中將介紹如何安裝/使用相關工具與技術，目的是搭建一個完全免費的個人部落格。\n使用的相關工具/技術:\n Hugo git vs code gist github page Markdown  Chocolatey Chocolatey 是一個 Windows 上的套件管理工具，它結合了 Nuget 基礎服務與 powershell 指令，提供快速安裝應用程式與工具的服務，將安裝軟體的內容封裝到一個安裝包中，在 Chocolatey 中只需要一條簡單的指令就能完成搜尋、安裝、更新、解安裝等操作。\n在 Windows 10 上安裝 Chocolatey 以‘系統管理員’身份開啟 \u0026lsquo;Windows PowerShell\u0026rsquo;,　執行以下指令來進行 Chocolatey 安裝\nPS C:\\\u0026gt;Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 移除 Chocolatey 刪除 C:\\ProgramData\\chocolatey 目錄及移除環境變數即可，搜尋 \u0026ldquo;編輯系統環境變數\u0026rdquo; \\ \u0026ldquo;進階\u0026rdquo; \\ \u0026ldquo;環境變數\u0026rdquo;\n安裝 hugo Step 1: 在 Windows 10 上使用 choco 安裝 hugo C:\\\u0026gt; choco install hugo -confirm C:\\\u0026gt; choco install hugo-extended - config C:\\\u0026gt; hugo version Step 2: Create a New Site (建立部落格網站) C:\\\u0026gt; hugo new site quickstart C:\\\u0026gt; hugo new site quickstart -f yml # 若要使用 config.","title":"在 Windows 10 使用 Hugo"}]