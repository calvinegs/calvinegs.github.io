[{"content":"github Source code\n在之前的筆記中 使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api。並使用 Microsoft Identity 框架來存儲使用者和角色等資料 已仔細的紀錄如何使用 .Net 6.0 來建置一個支援 JWT ＆ Identity framework 的 WebApi 網站應用程式，在該篇筆記中所使用的資料庫是 MS SQL 2019，而這篇筆記裡將紀錄如何將它改成支援 PostgresSQL。\n若你還沒有安裝 PostgresSQL 可以參考這筆記先將資料庫管理系統備妥 使用 Docker 執行 PostgresSQL 與 pgAdmin\ngit clone Example Code 先 git clone ｀使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api。並使用 Microsoft Identity 框架來存儲使用者和角色等資料｀ 這篇筆記的 Source code\n$ git clone https://github.com/calvinegs/dotnet6-webapi-jwt.git dotnet6-webapi-postgress restore 相依的套件 $ cd dotnet6-webapi-postgress $ dotnet restore 正在判斷要還原的專案... 已還原 /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj (1.12 sec 內)。 除移、SQL Server 套件改使用 Postgres 相關套件 $ dotnet remove package Microsoft.EntityFrameworkCore.SqlServer info : 正在從專案 \u0026#39;/home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj\u0026#39; 中移除套件 \u0026#39;Microsoft.EntityFrameworkCore.SqlServer\u0026#39; 的 PackageReference。 $ dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL 正在判斷要還原的專案... Writing /tmp/tmpU1vZfj.tmp info : 正在將套件 \u0026#39;Npgsql.EntityFrameworkCore.PostgreSQL\u0026#39; 的 PackageReference 新增至專案 \u0026#39;/home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj\u0026#39;。 info : GET https://api.nuget.org/v3/registration5-gz-semver2/npgsql.entityframeworkcore.postgresql/index.json info : OK https://api.nuget.org/v3/registration5-gz-semver2/npgsql.entityframeworkcore.postgresql/index.json 858 毫秒 info : 正在還原 /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj 的封裝... info : 套件 \u0026#39;Npgsql.EntityFrameworkCore.PostgreSQL\u0026#39; 與專案 \u0026#39;/home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj\u0026#39; 中的所有架構相容。 info : 已將套件 \u0026#39;Npgsql.EntityFrameworkCore.PostgreSQL\u0026#39; 版本 \u0026#39;6.0.4\u0026#39; 的 PackageReference 新增至檔案 \u0026#39;/home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj\u0026#39;。 info : 正在將資產檔案寫入磁碟。路徑: /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/obj/project.assets.json log : 已還原 /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/dotnet6-webapi-jwt.csproj (371 ms 內)。 使用 VSCode 開啟專案 $ code . 開啟 dotnet6-webapi-jwt.csproj 專案檔可發現已採用 ｀Npgsql.EntityFrameworkCore.PostgreSQL｀套件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;RootNamespace\u0026gt;dotnet6_webapi_jwt\u0026lt;/RootNamespace\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Identity.EntityFrameworkCore\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Design\u0026#34; Version=\u0026#34;6.0.5\u0026#34;\u0026gt; \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;6.0.5\u0026#34;\u0026gt; \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Npgsql.EntityFrameworkCore.PostgreSQL\u0026#34; Version=\u0026#34;6.0.4\u0026#34; /\u0026gt;  \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;6.2.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;   修改 DbContext 參數 修改 Program.cs 中 DbContext 的參數設定\nbuilder.Services.AddDbContext\u0026lt;ApiDbContext\u0026gt;( options =\u0026gt; options.UseSqlServer( _configuration.GetConnectionString(\u0026#34;ConnStr\u0026#34;) ) );  改成\n builder.Services.AddDbContext\u0026lt;ApiDbContext\u0026gt;( options =\u0026gt; options.UseNpgsql( _configuration.GetConnectionString(\u0026#34;ConnStr\u0026#34;) ) ); 修改 appsettings.json 中的 Conection String \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34; },  改成\n \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;User ID =docker;Password=docker;Server=localhost;Port=5432;Database=pg_testdb; Integrated Security=true;Pooling=true\u0026#34; }, 將原有專案的 Migrations 子目錄移除 $ rm -f ./Migrations $ dotnet build # 重新建置程式 Microsoft (R) Build Engine for .NET 17.2.0+41abc5629 版 Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。 正在判斷要還原的專案... 所有專案都在最新狀態，可進行還原。 dotnet6-webapi-jwt -\u0026gt; /home/egs/cal-data/tech-test/webapi/test/dotnet6-webapi-postgress/bin/Debug/net6.0/dotnet6-webapi-jwt.dll 建置成功。 0 個警告 0 個錯誤 經過時間 00:00:02.21 新增一個資料遷移 $ dotnet ef Migrations add \u0026#34;Initial Migrations\u0026#34; Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 6.0.5 initialized \u0026#39;ApiDbContext\u0026#39; using provider \u0026#39;Npgsql.EntityFrameworkCore.PostgreSQL:6.0.4+6cb649128e3e7aa8eddd77dfa75b34bad51e6e94\u0026#39; with options: None Done. To undo this action, use \u0026#39;ef migrations remove\u0026#39; 將資料遷移更新至資料庫 $ dotnet ef database update ![2022-06-02 18-07-55](https://user-images.githubusercontent.com/21993717/171607590-cd6e06ad-7ae7-47d2-bfba-afe9aab0d11e.png)  資料遷移成功後會在資料庫中自動産生 Identity Framework 所使用的資料表，而自定的 Model 也會一併産生新資料表\n 執行結果 ","permalink":"https://calvinegs.github.io/posts/dotnet6-webapi-jwt-postgres/","summary":"github Source code\n在之前的筆記中 使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api。並使用 Microsoft Identity 框架來存儲使用者和角色等資料 已仔細的紀錄如何使用 .Net 6.0 來建置一個支援 JWT ＆ Identity framework 的 WebApi 網站應用程式，在該篇筆記中所使用的資料庫是 MS SQL 2019，而這篇筆記裡將紀錄如何將它改成支援 PostgresSQL。\n若你還沒有安裝 PostgresSQL 可以參考這筆記先將資料庫管理系統備妥 使用 Docker 執行 PostgresSQL 與 pgAdmin\ngit clone Example Code 先 git clone ｀使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api。並使用 Microsoft Identity 框架來存儲使用者和角色等資料｀ 這篇筆記的 Source code\n$ git clone https://github.com/calvinegs/dotnet6-webapi-jwt.git dotnet6-webapi-postgress restore 相依的套件 $ cd dotnet6-webapi-postgress $ dotnet restore 正在判斷要還原的專案.","title":"使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api。並使用 Microsoft Identity 框架來存儲使用者和角色等資料（使用 PostgresSQL）"},{"content":"github Source code\n使用 Docker 執行 PostgresSQL 與 pgAdmin 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 postgresSQL 及其管理工具 pgAdmin。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.16 API version: 1.41 Go version: go1.17.10 Git commit: aa7e414 Built: Thu May 12 09:17:23 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.16 API version: 1.41 (minimum version 1.12) Go version: go1.17.10 Git commit: f756502 Built: Thu May 12 09:15:28 2022 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.4 GitCommit: 212e8b6fa2f44b9c21b2798135fc6fb7c53efc16 runc: Version: 1.1.1 GitCommit: v1.1.1-0-g52de29d docker-init: Version: 0.19.0 GitCommit: de40ad0 檢查是否已安裝了 docker compose $ docker compose version Docker Compose version v2.5.0 建置專案 目錄結構 $ mkdir postgres-pgadmin \u0026amp;\u0026amp; cd postgres-pgadmin $ touch docker-compose.yml README.md $ mkdir pgadmin pgdbdata sql $ touch ./pgadmin/pgdb_servers.json $ touch ./sql/initdb.sql ./postgres-pgadmin ├── docker-compose.yml ├── README.md ├── pgadmin │ └── pgdb_servers.json ├── pgdbdata └── sql └── initdb.sql 建立 docker-compose.yml 在這個 compse command file 中分別建立了二個 services，用來啟動 postgres 與 pgadmin。指令與說明如下\nversion: \u0026#39;3\u0026#39; services: postgres: container_name: pg_server # 自定 container 名稱 image: postgres:14.3  # 使用 postgres@14.3 docker image 檔 restart: always ports: - \u0026#34;5432:5432\u0026#34; environment: - POSTGRES_USER=docker  # 建立一個 postgres user  - POSTGRES_PASSWORD=docker # 這個 user 的密碼 volumes: # 將 local 的 ./sql/initdb.sql 掛載到 postgres docker /docker-entrypoint-initdb.d/init.sql，目的是建立一個名為 pg_testdb 資料庫 - ./sql/initdb.sql:/docker-entrypoint-initdb.d/init.sql  healthcheck: test: [\u0026#34;CMD-SHELL\u0026#34;, \u0026#34;pg_isready -U docker\u0026#34;] interval: 10s timeout: 5s retries: 5 pgadmin: container_name: pg_admin  # 自定 container 名稱 image: dpage/pgadmin4:6.9  # 使用 pgadmin4＠6.9 docker image 檔 depends_on: postgres: condition: service_healthy environment: PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL:-user@domain.org} PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD:-docker} PGADMIN_CONFIG_SERVER_MODE: \u0026#39;False\u0026#39; PGADMIN_SERVER_JSON_FILE: \u0026#39;/config/pgdb_servers.json\u0026#39; # 使用這個 Json 檔案來設定 pgadmin  volumes: - ./pgadmin:/config  # 將 local 的 ./pgadmin 目錄掛載到 pgadmin4 docker 中 ports: - \u0026#34;5431:80\u0026#34; # 將 pgadmin4 docker 中的 80 Port 映射到 local 端的 5431 Port restart: always 建立 pgdb_servers.json 這用檔案的用途是給 pgAdmin docker 啟動時設置環境用。\n{ \u0026#34;Servers\u0026#34;: { \u0026#34;1\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;pg-test\u0026#34;, \u0026#34;Group\u0026#34;: \u0026#34;Servers\u0026#34;, \u0026#34;Port\u0026#34;: 5432, \u0026#34;Username\u0026#34;: \u0026#34;docker\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;postgres\u0026#34;, \u0026#34;SSLMode\u0026#34;: \u0026#34;prefer\u0026#34;, \u0026#34;MaintenanceDB\u0026#34;: \u0026#34;postgres\u0026#34; } } } 建立 initdb.sql 這用檔案的用途是給 postgres docker 啟動時透過 volumn 指令掛戴將此 SQL 檔案映射到 docker 內的 /docker-entrypoint-initdb.d/init.sql 檔，使得 docker initial 時會自動建立一個名為 pg_testdb 的資料庫。\nCREATE DATABASE pg_testdb; 執行 docker compose 上述的目錄與檔案內容準備完成後，在與 docker-compose.yml 的相同目錄中執行 docker compose up來啟動這個二 Services，啟動成功後開啟另一個 terminal 使用 ｀$ docker ps｀ 指令查看容器啟動狀況\n$ docker compose up # ... pg_server | 2022-06-01 13:39:11.333 UTC [1] LOG: listening on IPv4 address \u0026#34;0.0.0.0\u0026#34;, port 5432 pg_server | 2022-06-01 13:39:11.333 UTC [1] LOG: listening on IPv6 address \u0026#34;::\u0026#34;, port 5432 pg_server | 2022-06-01 13:39:11.335 UTC [1] LOG: listening on Unix socket \u0026#34;/var/run/postgresql/.s.PGSQL.5432\u0026#34; pg_server | 2022-06-01 13:39:11.340 UTC [64] LOG: database system was shut down at 2022-06-01 13:39:11 UTC pg_server | 2022-06-01 13:39:11.346 UTC [1] LOG: database system is ready to accept connections pg_admin | NOTE: Configuring authentication for DESKTOP mode. pg_admin | ---------- pg_admin | Loading servers with: pg_admin | User: pgadmin4@pgadmin.org pg_admin | SQLite pgAdmin config: /var/lib/pgadmin/pgadmin4.db pg_admin | ---------- pg_admin | Added 0 Server Group(s) and 1 Server(s). pg_admin | [2022-06-01 13:39:48 +0000] [1] [INFO] Starting gunicorn 20.1.0 pg_admin | [2022-06-01 13:39:48 +0000] [1] [INFO] Listening at: http://[::]:80 (1) pg_admin | [2022-06-01 13:39:48 +0000] [1] [INFO] Using worker: gthread pg_admin | [2022-06-01 13:39:48 +0000] [91] [INFO] Booting worker with pid: 91  查看 docker 執行的情況\n $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 11bb5b91463c dpage/pgadmin4:6.9 \u0026#34;/entrypoint.sh\u0026#34; 17 seconds ago Up 5 seconds 443/tcp, 0.0.0.0:5431-\u0026gt;80/tcp, :::5431-\u0026gt;80/tcp pg_admin 1dbca769db67 postgres:14.3 \u0026#34;docker-entrypoint.s…\u0026#34; 17 seconds ago Up 16 seconds (healthy) 0.0.0.0:5432-\u0026gt;5432/tcp, :::5432-\u0026gt;5432/tcp pg_serve 使用 PgAdmin 連結到 Postgres DB 打開瀏覧器輸入： localhost:5431\n第一次開啟時要先設定 pgAdmin 的密碼，輸入 pgAdmin 的密碼後按下 OK 按鈕。\n接下來會顯示要連結到 pg-test 資料庫的使用者(本例中是 docker)的密碼輸入畫面，輸入密碼後按下 OK 按鈕。\n輸入密碼完成後，即可顯示資料庫的相關資訊：\n有關 pgadmin 更詳細資訊請 打開\n使用 dbeaver-cd 連結到 Postgres DB 開啟 dbeaver-cd 程式，按下 ｀New Database Connection` 按鈕\n開始設置連線資料設定，選擇資料庫 - PostgreSQL 按下 ｀Next`\n輸入相關資訊，如 Database name、Username、Password\u0026hellip;等，按下｀Test Connectiono\u0026hellip;｀來測試設定是否成功。\n設定無誤會顯示 ｀已連結的訊息視窗｀。按下｀OK｀回到設置畫面，再按下 \u0026ldquo;Finish\u0026rdquo; 即可進入 DBeaver 資料庫管理功能中。\n資料庫的實際檔案存放在 Local 的 ./pgdbdata 目錄中 使用作業系統管理者權限來查看此目錄\n$ sudo ls -al ./pgdbdata/ [sudo] egs 的密碼： 總用量 132 drwx------ 19 systemd-coredump egs 4096 六 2 11:26 . drwxrwxr-x 6 egs egs 4096 六 2 10:23 .. drwx------ 7 systemd-coredump systemd-coredump 4096 六 2 10:27 base drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:28 global drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_commit_ts drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_dynshmem -rw------- 1 systemd-coredump systemd-coredump 4821 六 2 10:27 pg_hba.conf -rw------- 1 systemd-coredump systemd-coredump 1636 六 2 10:27 pg_ident.conf drwx------ 4 systemd-coredump systemd-coredump 4096 六 2 11:26 pg_logical drwx------ 4 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_multixact drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_notify drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_replslot drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_serial drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_snapshots drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 11:26 pg_stat drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 11:26 pg_stat_tmp drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_subtrans drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_tblspc drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_twophase -rw------- 1 systemd-coredump systemd-coredump 3 六 2 10:27 PG_VERSION drwx------ 3 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_wal drwx------ 2 systemd-coredump systemd-coredump 4096 六 2 10:27 pg_xact -rw------- 1 systemd-coredump systemd-coredump 88 六 2 10:27 postgresql.auto.conf -rw------- 1 systemd-coredump systemd-coredump 28835 六 2 10:27 postgresql.conf -rw------- 1 systemd-coredump systemd-coredump 36 六 2 10:27 postmaster.opts ","permalink":"https://calvinegs.github.io/posts/docker-postgres-pgadmin/","summary":"github Source code\n使用 Docker 執行 PostgresSQL 與 pgAdmin 對開發人員而言，使用各式的資料庫管理系統來當應用程式的後端資料存取層是家常便飯。若再考慮上每種資料庫管理系統有不同的版本，肯定會讓你的開發環境負擔過重、過於複雜。使用 Docker 來於適當的時機開啟適用的資料庫管理系統會是一個不錯的選擇。\n本篇筆記紀錄使用 docker (docker compose) 來快速的設置 postgresSQL 及其管理工具 pgAdmin。\n檢查是否已安裝了 Docker (docker version) $ docker version Client: Docker Engine - Community Version: 20.10.16 API version: 1.41 Go version: go1.17.10 Git commit: aa7e414 Built: Thu May 12 09:17:23 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.16 API version: 1.41 (minimum version 1.12) Go version: go1.","title":"使用 Docker 執行 PostgresSQL 與 pgAdmin"},{"content":"github Source code\n本文將記錄如何一步步從無到有使用 Angular 13 Reactive Form 表單驗證 與 Bootstrap 建立 一個使用者資料註冊的表單　功能，在這個表單中當按下送出時會自動檢核使用者所輸入的資料是否合乎程式中所設定的檢核邏輯，並顯示合適的訊息反應給使用者。其中將會使用到下列技術:\n Ａngular CLI Bootstrap 4 \u0026amp; 5 (UI Framework) Angular Reactive Form Custome Validator  建立新專案 $ ng version Angular CLI: 13.3.6 Node: 16.14.0 Package Manager: npm 8.3.1 OS: linux x64 Angular: 13.3.9 ... animations, common, compiler, compiler-cli, core, forms ... platform-browser, platform-browser-dynamic, router Package Version --------------------------------------------------------- @angular-devkit/architect 0.1303.6 @angular-devkit/build-angular 13.3.6 @angular-devkit/core 13.3.6 @angular-devkit/schematics 13.3.6 @angular/cli 13.3.6 @schematics/angular 13.3.6 rxjs 7.5.5 typescript 4.6.4 $ ng new form-validation # 使用 ng cli 來建立專案 ? Would you like to add Angular routing? (y/N) N # 選擇 N 不使用 routing 功能 ? Which stylesheet format would you like to use? # 選擇 SCSS  CSS ❯ SCSS [ https://sass-lang.com/documentation/syntax#scss ] Sass [ https://sass-lang.com/documentation/syntax#the-indented-syntax ] Less [ http://lesscss.org ] ... Packages installed successfully. Successfully initialized git. $ cd form-validation/ $ ls -al 總用量 844 drwxrwxr-x 6 egs egs 4096 五 28 15:08 . drwxrwxr-x 3 egs egs 4096 五 28 15:07 .. -rw-rw-r-- 1 egs egs 3261 五 28 15:07 angular.json -rw-rw-r-- 1 egs egs 600 五 28 15:07 .browserslistrc -rw-rw-r-- 1 egs egs 274 五 28 15:07 .editorconfig drwxrwxr-x 8 egs egs 4096 五 28 15:08 .git -rw-rw-r-- 1 egs egs 548 五 28 15:07 .gitignore -rw-rw-r-- 1 egs egs 1432 五 28 15:07 karma.conf.js drwxrwxr-x 599 egs egs 20480 五 28 15:08 node_modules -rw-rw-r-- 1 egs egs 1078 五 28 15:07 package.json -rw-rw-r-- 1 egs egs 778846 五 28 15:08 package-lock.json -rw-rw-r-- 1 egs egs 1068 五 28 15:07 README.md drwxrwxr-x 5 egs egs 4096 五 28 15:07 src -rw-rw-r-- 1 egs egs 287 五 28 15:07 tsconfig.app.json -rw-rw-r-- 1 egs egs 863 五 28 15:07 tsconfig.json -rw-rw-r-- 1 egs egs 333 五 28 15:07 tsconfig.spec.json drwxrwxr-x 2 egs egs 4096 五 28 15:07 .vscode $ code .　# 打開 vscode 設置專案 匯入 ReactiveFormModule 模組  開啟 src/app/app.module.ts 並由 @angular/forms 匯入 ReactiveFormModule\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { ReactiveFormsModule } from \u0026#39;@angular/forms\u0026#39;; import { AppComponent } from \u0026#39;./app.component\u0026#39;; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, ReactiveFormsModule  ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }   使用 Bootstrap  方法一: 開啟 src/index.html 在  加入 link tag\n  使用 bootstrap 4 時使用第 9 行匯入語法 使用 bootstrap 5 時使用第 10 行匯入語法　   上述語法二擇一\n  由於 bootstrap 4 \u0026amp; 5 兩個版本語法有相異處，在範例中將展示不同的寫法\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;FormValidation\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-zCbKRCUGaJDkqS1kPbPd7TveP5iyJE0EjAuZQTgFLD2ylzuqKfdKlfG/eSrtxUkn\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;    方法二: 使用 npm install 來進行安裝 1.1 先使用 npm install 將 bootstrap 安裝到專案的 node_modules 目錄下\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # 上述版本二擇一 $ npm install bootstarp@4.6.1 npm WARN deprecated popper.js@1.16.1: You can find the new Popper v2 at @popperjs/core, this package is dedicated to the legacy v1 added 3 packages, and audited 928 packages in 1s 108 packages are looking for funding run `npm fund` for details found 0 vulnerabilities  $ npm install bootstrap@5.1.3 added 2 packages, and audited 927 packages in 2s 108 packages are looking for funding run `npm fund` for details found 0 vulnerabilities    npm install 成功後，可以在 package.json 中查看到已裝 bootstrap 的資訊\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;~13.3.0\u0026#34;, \u0026#34;bootstrap\u0026#34;: \u0026#34;^4.6.1\u0026#34;,  \u0026#34;rxjs\u0026#34;: \u0026#34;~7.5.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^2.3.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.11.4\u0026#34; },    1.2 npm install 成功後，還必須在 angular.json architect/build/options/styles 中匯入已安裝的 bootstrap\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  { \u0026#34;$schema\u0026#34;: \u0026#34;./node_modules/@angular/cli/lib/config/schema.json\u0026#34;, \u0026#34;version\u0026#34;: 1, \u0026#34;newProjectRoot\u0026#34;: \u0026#34;projects\u0026#34;, \u0026#34;projects\u0026#34;: { \u0026#34;form-validation\u0026#34;: { \u0026#34;projectType\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;schematics\u0026#34;: { \u0026#34;@schematics/angular:component\u0026#34;: { \u0026#34;style\u0026#34;: \u0026#34;css\u0026#34; } }, \u0026#34;root\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;sourceRoot\u0026#34;: \u0026#34;src\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;app\u0026#34;, \u0026#34;architect\u0026#34;: { \u0026#34;build\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-devkit/build-angular:browser\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;outputPath\u0026#34;: \u0026#34;dist/form-validation\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;src/index.html\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;src/main.ts\u0026#34;, \u0026#34;polyfills\u0026#34;: \u0026#34;src/polyfills.ts\u0026#34;, \u0026#34;tsConfig\u0026#34;: \u0026#34;tsconfig.app.json\u0026#34;, \u0026#34;assets\u0026#34;: [ \u0026#34;src/favicon.ico\u0026#34;, \u0026#34;src/assets\u0026#34; ], \u0026#34;styles\u0026#34;: [ \u0026#34;src/styles.scss\u0026#34;, \u0026#34;node_modules/bootstrap/scss/bootstrap.scss\u0026#34;  ], \u0026#34;scripts\u0026#34;: [] ... }, } } } } }   開始撰寫程式 開啟 app.component.ts 程式檔案，並先 import @angular/form module 中的　AbstractControl, FormBuilder, FormGroup, Validators。我們會使用 Angular FormBuilder 建立一個 FormGroup 物件（表單屬性），然後綁定到模板  元素（稍後使用 [formGroup] 指令）。 Validators 提供了一組內置的驗證器（required、minLength、maxLength…），可供表單控件(control)所使用。\n1 2  import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;;    完成後程式如下\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { AbstractControl, FormBuilder, FormControl, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.scss\u0026#39;] }) export class AppComponent implements OnInit { form: FormGroup = new FormGroup({ fullname: new FormControl(\u0026#39;\u0026#39;), username: new FormControl(\u0026#39;\u0026#39;), email: new FormControl(\u0026#39;\u0026#39;), password: new FormControl(\u0026#39;\u0026#39;), confirmPassword: new FormControl(\u0026#39;\u0026#39;), acceptTerms: new FormControl(false), }); submitted = false;  constructor(private formBuilder: FormBuilder) {} ngOnInit(): void { this.form = this.formBuilder.group( { fullname: [\u0026#39;\u0026#39;, Validators.required], username: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(20) ] ], email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]], password: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(40) ] ], confirmPassword: [\u0026#39;\u0026#39;,Validators.required], acceptTerms: [false, Validators.requiredTrue] }, { validators: [Validation.match(\u0026#39;password\u0026#39;, \u0026#39;confirmPassword\u0026#39;)] } )  } get f(): { [key: string]: AbstractControl } { return this.form.controls; }  onSubmit(): void { this.submitted = true; if (this.form.invalid) { return; } console.log(JSON.stringify(this.form.value, null, 2)); } onReset(): void { this.submitted = false; this.form.reset(); } }    在上述程式裡，我們所建立的 this.form (程式 24-50 行)這個 FormGroup 物件中使用到了許多內建的表單驗證器，如：Validators.required（必填）、Validators.minLength（最小長度）、Validators.maxLength（最大長度）、Validators.requiredTrue（必須為 true）等，同時在程式第 48 行也會使用到｀自定驗證器｀(稍後會進行如何撰寫一個自定驗證器)\n  在程式第51行我們定義了一個 getter 以方便我們在 template 中存取 form 中的控件（contol）。透過這個 getter function 你可以使用｀f.username｀ 來取代 ｀form.controls.username｀，使 template（表單樣版） 看起簡潔些。\n 自定 CSS 設定 為控制整張 form 的寬度，我們在 app.component.scss 中定義了一個 class - register-form，定義它最大寬度，並套用在 html 檔案中。\n.register-form { max-width: 350px; margin: auto; } 自定表單驗證器 在前述 reactive 表單定義中我們希望在 “Confirm Password” 欄位除了“必填”的檢核邏輯外，還要有一個驗證的機制是｀比對 “Password” 與 “Confirm Password” 這兩個欄位值必須一致\u0026quot;，這個邏輯在內建的表單欄位驗證器中並沒有提供，所以我們要自行撰寫這個驗證器。\n自定驗證器就像我們在日常程式中經常使用的函數一樣。你可以為任何給定場景創立自定驗證器。在 Angular 中建立自定驗證非常簡單，就像建立其他函數一樣。自定驗證器將 AbstractControl 作為參數，如果驗證失敗，則以 key: value 對的形式回傳一個物件。\n先建立一個子目錄 utils，新增一個 validation.ts 程式檔，主要的邏輯有\n 首先，若檢查有任何誤則回傳 null 再則，若兩個被檢核的欄位值不相同，則回傳  import { AbstractControl, ValidatorFn } from \u0026#34;@angular/forms\u0026#34;; export default class Validation { static match(controlName: string, checkControlName: string): ValidatorFn { return (controls: AbstractControl) =\u0026gt; { const control = controls.get(controlName); const checkControl = controls.get(checkControlName); if (checkControl?.errors \u0026amp;\u0026amp; !checkControl.errors[\u0026#39;matching\u0026#39;]) { return null; } if (control?.value !== checkControl?.value) { controls.get(checkControlName)?.setErrors({ matching: true }); return { match: true }; } else { return null; } } } }  完成後的驗證器會被使用在 app.component.ts form 的定義中，見下程式第26行\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  ngOnInit(): void { this.form = this.formBuilder.group( { fullname: [\u0026#39;\u0026#39;, Validators.required], username: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(20) ] ], email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]], password: [ \u0026#39;\u0026#39;, [ Validators.required, Validators.minLength(6), Validators.maxLength(40) ] ], confirmPassword: [\u0026#39;\u0026#39;,Validators.required], acceptTerms: [false, Validators.requiredTrue] }, { validators: [Validation.match(\u0026#39;password\u0026#39;, \u0026#39;confirmPassword\u0026#39;)]  } ) }   執行程式  結行結果：\n  按下｀送出｀按鈕將所有檢核不合可訊息顯示在欄位下方\n  email 格式不符的驗證\n  password 長度的驗證\n  confirm password 自定驗證喌右的檢核\n  檢核完成\n 套用 bootstrap 5 的 html  index.html 中 link 到 bootstrp@5.1.3 的版本\n \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;FormValidation\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-zCbKRCUGaJDkqS1kPbPd7TveP5iyJE0EjAuZQTgFLD2ylzuqKfdKlfG/eSrtxUkn\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  app.component.html 套用的 bootstrp class 需要微調\n \u0026lt;div class=\u0026#34;container-fluid register-form\u0026#34;\u0026gt; \u0026lt;form needs-validation [formGroup]=\u0026#34;form\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;note\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; 使用者資料註冊 \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;fullname\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Full Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;fullname\u0026#34; id=\u0026#34;fullname\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;fullname\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;fullname\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; Full Name 為必填 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;username\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;username\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Username 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;minlength\u0026#39;]\u0026#34;\u0026gt; Username 必須至少為六個字元 \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;username\u0026#39;].errors[\u0026#39;maxlength\u0026#39;]\u0026#34;\u0026gt; Username 必須至多為二十個字元 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;email\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;email\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;email\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;email\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Email 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;email\u0026#39;].errors[\u0026#39;email\u0026#39;]\u0026#34;\u0026gt;Email 格式不符\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;password\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;password\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Password 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;minlength\u0026#39;]\u0026#34;\u0026gt; Password 必須至少為六個字元 \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;password\u0026#39;].errors[\u0026#39;maxlength\u0026#39;]\u0026#34;\u0026gt; Password 必須至多為四十個字元 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;confirmPassword\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Confirm Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; formControlName=\u0026#34;confirmPassword\u0026#34; id=\u0026#34;confirmPassword\u0026#34; class=\u0026#34;form-control\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;confirmPassword\u0026#39;].errors, \u0026#39;is-valid\u0026#39;: submitted \u0026amp;\u0026amp; !f[\u0026#39;confirmPassword\u0026#39;].errors }\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;confirmPassword\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;confirmPassword\u0026#39;].errors[\u0026#39;required\u0026#39;]\u0026#34;\u0026gt;Confirm Password 為必填\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;f[\u0026#39;confirmPassword\u0026#39;].errors[\u0026#39;matching\u0026#39;]\u0026#34;\u0026gt; Confirm Password 不符 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;valid-feedback\u0026#34;\u0026gt; 填寫正確 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4 form-check\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; formControlName=\u0026#34;acceptTerms\u0026#34; id=\u0026#34;acceptTerms\u0026#34; class=\u0026#34;form-check-input\u0026#34; [ngClass]=\u0026#34;{ \u0026#39;is-invalid\u0026#39;: submitted \u0026amp;\u0026amp; f[\u0026#39;acceptTerms\u0026#39;].errors }\u0026#34;/\u0026gt; \u0026lt;label for=\u0026#34;acceptTerms\u0026#34; class=\u0026#34;form-check-label\u0026#34;\u0026gt; 我已閱讀並同意條款 \u0026lt;/label\u0026gt; \u0026lt;div *ngIf=\u0026#34;submitted \u0026amp;\u0026amp; f[\u0026#39;acceptTerms\u0026#39;].errors\u0026#34; class=\u0026#34;invalid-feedback\u0026#34;\u0026gt; 同意條款 為必填 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;送出\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;onReset()\u0026#34; class=\u0026#34;btn btn-warning float-end\u0026#34;\u0026gt; 重置 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; ","permalink":"https://calvinegs.github.io/posts/angular-formvalidate/","summary":"github Source code\n本文將記錄如何一步步從無到有使用 Angular 13 Reactive Form 表單驗證 與 Bootstrap 建立 一個使用者資料註冊的表單　功能，在這個表單中當按下送出時會自動檢核使用者所輸入的資料是否合乎程式中所設定的檢核邏輯，並顯示合適的訊息反應給使用者。其中將會使用到下列技術:\n Ａngular CLI Bootstrap 4 \u0026amp; 5 (UI Framework) Angular Reactive Form Custome Validator  建立新專案 $ ng version Angular CLI: 13.3.6 Node: 16.14.0 Package Manager: npm 8.3.1 OS: linux x64 Angular: 13.3.9 ... animations, common, compiler, compiler-cli, core, forms ... platform-browser, platform-browser-dynamic, router Package Version --------------------------------------------------------- @angular-devkit/architect 0.1303.6 @angular-devkit/build-angular 13.3.6 @angular-devkit/core 13.3.6 @angular-devkit/schematics 13.3.6 @angular/cli 13.","title":"使用 Angular 13 建立 Reactive Form 表單驗證範例"},{"content":"github Source code #tag: dotnet6_webapi_jwt\n本文將記錄如何一步步從無到有使用 Dotnet Core 6.0 建立 ASP.NET Core Web API，其中將會使用到下列技術:\n Dotnet CLI Entity Framework Json Web Token SQL Server (Docker Version) ASP.NET Core Generator  建置新專案 $ dotnet new webapi -o dotnet6-webapi-jwt 範本「ASP.NET Core Web API」已成功建立。 正在處理建立後的動作... 正在 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/dotnet6-webapi-jwt.csproj 上執行 \u0026#39;dotnet restore\u0026#39;... 正在判斷要還原的專案... 已還原 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/dotnet6-webapi-jwt.csproj (238 ms 內)。 還原成功。 $ cd dotnet6-webapi-jwt $ ls -al 總用量 40 drwxrwxr-x 5 egs egs 4096 五 20 09:38 . drwxrwxr-x 12 egs egs 4096 五 20 09:38 .. -rw-rw-r-- 1 egs egs 127 五 20 09:38 appsettings.Development.json -rw-rw-r-- 1 egs egs 151 五 20 09:38 appsettings.json drwxrwxr-x 2 egs egs 4096 五 20 09:38 Controllers -rw-rw-r-- 1 egs egs 382 五 20 09:38 dotnet6-webapi-jwt.csproj drwxrwxr-x 2 egs egs 4096 五 20 09:38 obj -rw-rw-r-- 1 egs egs 557 五 20 09:38 Program.cs drwxrwxr-x 2 egs egs 4096 五 20 09:38 Properties -rw-rw-r-- 1 egs egs 267 五 20 09:38 WeatherForecast.cs  dotnet code 版本安裝與管理\n $ dotnet --list-sdks # 顯示已安裝的 sdk 版本資訊 5.0.408 [/usr/share/dotnet/sdk] 6.0.300 [/usr/share/dotnet/sdk] $ dotnet --version # 顯示目前所使用的版本 6.0.300 # 預設是最新的版本  由於 dotnet 版本演化滿快的，所以會建議在專案目錄中要指定使用 SDK 的版本，以免當你又安裝了更新版本（如7.0）後程式執行出問題。\n $ dotnet new globaljson --sdk-version 6.0.300 範本「global.json 檔案」已成功建立。 $ cat global.json { \u0026#34;sdk\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;6.0.300\u0026#34; } }  使用 dotnet cli 來產生預設的 git ignore 檔案\n $ dotnet new gitignore  建立 git 初始版本\n $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝本機工具 此方式安裝的工具，僅限本機存取(只針對目前的目錄和子目錄)， 首先透過 dotnet new tool-manifest 命令來產生工具資訊清單檔，再使用 dotnet tool install 來安裝各式工具程式。這樣的方式好處是在專案若多人協助方式時，則可利用 dotnet tool restore 命令將紀錄在 .config/dotnet-tools.json 的工具資訊清單檔重建在不同協助人員的電腦中。\n$ dotnet new tool-manifest #會產生 .config/dotnet-tools.json 檔案 $ dotnet tool install --local dotnet-ef #使用 local 安裝方式來安裝 Entity Framework 工具 您可使用下列命令，從此目錄叫用工具: \u0026#39;dotnet tool run dotnet-ef\u0026#39; 或 \u0026#39;dotnet dotnet-ef\u0026#39;。 已成功安裝工具 \u0026#39;dotnet-ef\u0026#39; (版本 \u0026#39;6.0.5\u0026#39;)。項目已新增至資訊清單檔 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/.config/dotnet-tools.json。 $ dotnet tool install --local dotnet-aspnet-codegenerator #使用 local 安裝方式來安裝 Code Generator 工具 您可使用下列命令，從此目錄叫用工具: \u0026#39;dotnet tool run dotnet-aspnet-codegenerator\u0026#39; 或 \u0026#39;dotnet dotnet-aspnet-codegenerator\u0026#39;。 已成功安裝工具 \u0026#39;dotnet-aspnet-codegenerator\u0026#39; (版本 \u0026#39;6.0.5\u0026#39;)。項目已新增至資訊清單檔 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/.config/dotnet-tools.json。 $ cat .\\.config\\dotnet-tools.json # 查看安裝上述二項工具後的設定資訊 1 2 3 4 5 6 7 8 9 10 11 12 13 14  { \u0026#34;version\u0026#34;: 1, \u0026#34;isRoot\u0026#34;: true, \u0026#34;tools\u0026#34;: { \u0026#34;dotnet-ef\u0026#34;: {  \u0026#34;version\u0026#34;: \u0026#34;6.0.5\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-ef\u0026#34;] }, \u0026#34;dotnet-aspnet-codegenerator\u0026#34;: {  \u0026#34;version\u0026#34;: \u0026#34;6.0.5\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-aspnet-codegenerator\u0026#34;] } } }   安裝程式使用的相關套件 $ dotnet add package Microsoft.EntityFrameworkCore.Tools #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.Design #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.SqlServer #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore #使用 Identity Framework時必須安裝此套件 $ dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer # $ dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design #搭配 dotnet-aspnet-codegenerator 使用 安裝的程式套件資訊紀錄在 \u0026ldquo;專案\u0026rdquo;.csproj 檔案中\n$ cat dotnet6-webapi-jwt.csproj #查看 安裝套件的相關設定值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;RootNamespace\u0026gt;dotnet6_webapi_jwt\u0026lt;/RootNamespace\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Identity.EntityFrameworkCore\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Design\u0026#34; Version=\u0026#34;6.0.5\u0026#34;\u0026gt;  \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.SqlServer\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;6.0.5\u0026#34;\u0026gt;  \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;6.2.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;   建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add EFCore NuGet packages\u0026#34; 執行程式 $ dotnet watch  打開 VS Code\n $ code .  目前産生的程式架構\n 設置使用 Entity Framework相關設定 新增 database context (自動產生)  使用 dotnet ef 工具在專案目錄 ./Data 子目錄下新建立一個 ApiDbContext.cs 的 DB Context file\n 註：在使用前先把 SQL Server 環境傋妥，安裝 SQL Server 可參考此篇筆紀　github Source code\n$ dotnet ef dbcontext scaffold \u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34; Microsoft.EntityFrameworkCore.SqlServer -c ApiDbContext -o Data Build started... Build succeeded. To protect potentially sensitive information in your connection string, you should move it out of source code. You can avoid scaffolding the connection string by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148. For more guidance on storing connection strings, see http://go.microsoft.com/fwlink/?LinkId=723263. using System; using System.Collections.Generic; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata; namespace dotnet6_webapi_jwt.Data { public partial class ApiDbContext : DbContext { public ApiDbContext() { } public ApiDbContext(DbContextOptions\u0026lt;ApiDbContext\u0026gt; options) : base(options) { } public virtual DbSet\u0026lt;Inventory\u0026gt; Inventories { get; set; } = null!; protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { if (!optionsBuilder.IsConfigured) { // optionsBuilder.UseSqlServer(\u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34;);  } } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity\u0026lt;Inventory\u0026gt;(entity =\u0026gt; { entity.HasNoKey(); entity.ToTable(\u0026#34;Inventory\u0026#34;); entity.Property(e =\u0026gt; e.Id).HasColumnName(\u0026#34;id\u0026#34;); entity.Property(e =\u0026gt; e.Name) .HasMaxLength(50) .HasColumnName(\u0026#34;name\u0026#34;); entity.Property(e =\u0026gt; e.Quantity).HasColumnName(\u0026#34;quantity\u0026#34;); }); OnModelCreatingPartial(modelBuilder); } partial void OnModelCreatingPartial(ModelBuilder modelBuilder); } }  在 appsettings.json 檔案中加入 Connection String\n { \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34; } } 使用 Asp.Net Core Identity framework 來管理使用者使用權限 ASP.NET Core Identity:\n 支援使用者介面 (UI) 登入功能的 API。 管理使用者、密碼、設定檔資料、角色、宣告、權杖、電子郵件確認等。  ASP.Net Core Identity Framework 是一個方便且還完善的使用權限管理架構。\n將相關 Asp.Net Core Identity framework 功能注入到 container 中 除了安裝相關套件外，還要調整相關程式:\n 在 Program.cs 檔案中將加入以下程式碼 (before services.AddControllers())  ConfigurationManager _configuration = builder.Configuration; // Add services to the container. builder.Services.AddDbContext\u0026lt;ApiDbContext\u0026gt;( options =\u0026gt; options.UseSqlServer( _configuration.GetConnectionString(\u0026#34;ConnStr\u0026#34;) ) ); builder.Services.AddIdentity\u0026lt;IdentityUser, IdentityRole\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApiDbContext\u0026gt;() .AddDefaultTokenProviders();  使用 AspNetCore Identity，則 DataContext (ApiDbContext.cs 中) 必須要繼承 IdentityDbContext， 同時 Model creationg 時要改成呼叫 base.OnModelCreation  1 2 3 4 5 6 7 8 9 10 11 12 13 14  public partial class ApiDbContext : IdentityDbContext\u0026lt;IdentityUser\u0026gt; { public ApiDbContext() { } // ...  protected override void OnModelCreating(ModelBuilder modelBuilder) { // OnModelCreatingPartial(modelBuilder);  base.OnModelCreating(modelBuilder);  } }   新增一個 entity framework 遷移 並 更新資料庫 完成上述程式調整後，來執行資料庫遷移(migrations)\n$ dotnet build $ dotnet ef migrations add \u0026#34;Add Identity Framework\u0026#34; Build started... Build succeeded. info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 6.0.5 initialized \u0026#39;ApiDbContext\u0026#39; using provider \u0026#39;Microsoft.EntityFrameworkCore.SqlServer:6.0.5\u0026#39; with options: None Done. To undo this action, use \u0026#39;ef migrations remove\u0026#39; $ dotnet ef database update  在　dotnet ef migrations add \u0026ldquo;Add Identity Framework\u0026rdquo; 指令完成後，可以在專案目錄下發生産生新的子目錄 Migrations，並有三個新檔案\n  在 dotnet ef database update 指令完成後，SQL Server TestDB 資料庫中產生 Identity Framework 會使用到的資料表\n 建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;新增一個 entity framework 遷移 並 更新資料庫\u0026#34; 使用 Jason Web Token 在 appsettings.json 中自定JWT實作會使用到的設定值 { // ...  \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnStr\u0026#34;: \u0026#34;Data Source=localhost;Initial Catalog=TestDB;User ID=SA;Password=Sql@12345\u0026#34; }, \u0026#34;JwtSettings\u0026#34;: { \u0026#34;ValidIssuer\u0026#34;: \u0026#34;Dotnet6WebApiDemo\u0026#34;, \u0026#34;ValidAudience\u0026#34;: \u0026#34;Dotnet6WebApiDemo\u0026#34;, \u0026#34;Secret\u0026#34;: \u0026#34;Dotnet6 WebApi Demo. Using Json Web Token Technology to keep user info.\u0026#34; } } 新增 使用者註冊和登入時使用的 Data model class (Models/AuthenticateData.cs) using System.ComponentModel.DataAnnotations; namespace dotnet6_webapi_jwt.Models; public class Response { public string? Status { get; set; } public string? Message { get; set; } } public class LoginModel { [EmailAddress] [Required(ErrorMessage = \u0026#34;Eamil Address is required\u0026#34;)] public string? Email { get; set; } [Required(ErrorMessage = \u0026#34;Password is required\u0026#34;)] public string? Password { get; set; } } public class RegisterModel { [Required(ErrorMessage = \u0026#34;User Name is required\u0026#34;)] public string? Username { get; set; } [EmailAddress] [Required(ErrorMessage = \u0026#34;Email Address is required\u0026#34;)] public string? Email { get; set; } [Required(ErrorMessage = \u0026#34;Password is required\u0026#34;)] public string? Password { get; set; } } public static class UserRoles { public const string Admin = \u0026#34;Admin\u0026#34;; public const string User = \u0026#34;User\u0026#34;; } 新增 註冊和登入邏輯 (Controllers/AuthenticateControll.cs) using System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using System.Text; using dotnet6_webapi_jwt.Models; using Microsoft.AspNetCore.Identity; using Microsoft.AspNetCore.Mvc; using Microsoft.IdentityModel.Tokens; namespace dotnet6_webapi_jwt.Controllers; [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class AuthenticateController : ControllerBase { private readonly UserManager\u0026lt;IdentityUser\u0026gt; _userManager; private readonly RoleManager\u0026lt;IdentityRole\u0026gt; _roleManager; private readonly IConfiguration _configuration; public AuthenticateController( UserManager\u0026lt;IdentityUser\u0026gt; userManager, RoleManager\u0026lt;IdentityRole\u0026gt; roleManager, IConfiguration configuration) { _userManager = userManager; _roleManager = roleManager; _configuration = configuration; } [HttpPost] [Route(\u0026#34;login\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Login([FromBody] LoginModel userModel) { var user = await _userManager.FindByEmailAsync(userModel.Email); if (user != null \u0026amp;\u0026amp; await _userManager.CheckPasswordAsync(user, userModel.Password)) { var userRoles = await _userManager.GetRolesAsync(user); var claims = new List\u0026lt;Claim\u0026gt; { new Claim(ClaimTypes.Name, user.UserName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()), }; foreach (var userRole in userRoles) { claims.Add(new Claim(ClaimTypes.Role, userRole)); } var token = CreateToken(claims); return Ok(new { token = new JwtSecurityTokenHandler().WriteToken(token), expiration = token.ValidTo }); } return Unauthorized(); } [HttpPost] [Route(\u0026#34;register\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Register([FromBody] RegisterModel model) { var userExists = await _userManager.FindByEmailAsync(model.Email); if (userExists != null) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User already exists!\u0026#34; }); IdentityUser user = new() { Email = model.Email, SecurityStamp = Guid.NewGuid().ToString(), UserName = model.Username }; var result = await _userManager.CreateAsync(user, model.Password); if (!result.Succeeded) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User creation failed! Please check user details and try again.\u0026#34; }); return Ok(new Response { Status = \u0026#34;Success\u0026#34;, Message = \u0026#34;User created successfully!\u0026#34; }); } [HttpPost] [Route(\u0026#34;register-admin\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; RegisterAdmin([FromBody] RegisterModel model) { var userExists = await _userManager.FindByEmailAsync(model.Email); if (userExists != null) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User already exists!\u0026#34; }); IdentityUser user = new() { Email = model.Email, SecurityStamp = Guid.NewGuid().ToString(), UserName = model.Username }; var result = await _userManager.CreateAsync(user, model.Password); if (!result.Succeeded) return StatusCode(StatusCodes.Status500InternalServerError, new Response { Status = \u0026#34;Error\u0026#34;, Message = \u0026#34;User creation failed! Please check user details and try again.\u0026#34; }); if (!await _roleManager.RoleExistsAsync(UserRoles.Admin)) await _roleManager.CreateAsync(new IdentityRole(UserRoles.Admin)); if (!await _roleManager.RoleExistsAsync(UserRoles.User)) await _roleManager.CreateAsync(new IdentityRole(UserRoles.User)); if (await _roleManager.RoleExistsAsync(UserRoles.Admin)) { await _userManager.AddToRoleAsync(user, UserRoles.Admin); } if (await _roleManager.RoleExistsAsync(UserRoles.Admin)) { await _userManager.AddToRoleAsync(user, UserRoles.User); } return Ok(new Response { Status = \u0026#34;Success\u0026#34;, Message = \u0026#34;User created successfully!\u0026#34; }); } private JwtSecurityToken CreateToken(List\u0026lt;Claim\u0026gt; claims) { var secretkey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes( _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;))); // _configuration.GetSection(\u0026#34;JwtSettings:Secret\u0026#34;).Value)  var credentials = new SigningCredentials(secretkey, SecurityAlgorithms.HmacSha512Signature); var token = new JwtSecurityToken( // 亦可使用　SecurityTokenDescriptor　來産生 Token  issuer: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidIssuer\u0026#34;), audience: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidAudience\u0026#34;), expires: DateTime.Now.AddDays(1), claims: claims, signingCredentials: credentials); return token; } } 有關實作 JWT 的流程 透過 JWT 的實作可以讓你的專案實現 Token-base 的身份驗證與授權。 （Json Web Token) 實作的過程大致可以分成三個部分:\n 在登入成功後産生合法的 JWT Token 每次收到 request 時驗證是否為合法有效的 JWT Token 在特定 API Endpoint 上驗證是否帶有 “合法有效的 JWT Token”，以達到權限管理的需求  産生合法的 Jason Web Token  在上述 AuthenticateController.cs 程式中，我們建立一個 CreateToken() 的 function，並在登入檢核成功時産生一個 token 回傳。\n 設置驗證是否為合法有效的 JWT Token  第一步，透過 DI 將 JWT 相關設定設置好\n builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; }) .AddJwtBearer(options =\u0026gt; { // 當驗證失敗時，回應標頭會包含 WWW-Authenticate 標頭，這裡會顯示失敗的詳細錯誤原因  options.IncludeErrorDetails = true; // 預設值為 true，有時會特別關閉  options.TokenValidationParameters = new TokenValidationParameters { // 透過這項宣告，就可以從 \u0026#34;NAME\u0026#34; 取值  NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, // 透過這項宣告，就可以從 \u0026#34;Role\u0026#34; 取值，並可讓 [Authorize] 判斷角色  RoleClaimType = \u0026#34;http://schemas.microsoft.com/ws/2008/06/identity/claims/role\u0026#34;, // 驗證 Issuer (一般都會)  ValidateIssuer = true, ValidIssuer = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidIssuer\u0026#34;), // 驗證 Audience (通常不太需要)  ValidateAudience = false, //ValidAudience = = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:ValidAudience\u0026#34;),  // 驗證 Token 的有效期間 (一般都會)  ValidateLifetime = true, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已  ValidateIssuerSigningKey = false, // 應該從 IConfiguration 取得  IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)) }; });  第二步，要啟動 request pipeline 中的 Middleware (UseAuthentication \u0026amp; UseAuthorization 都需要)\n app.UseAuthentication(); app.UseAuthorization(); 在特定 API EndPoint 上驗證是否帶有合法有效的 JWT Token  在 WeatherForecastController.cs Get() function 上加入[Authorize] 即可\n 1 2 3 4 5 6 7 8 9 10 11 12  [Authorize] [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); }    如上程式加入[Authorize]後，再重新瀏覽 weatherforecast endpoint，會回傳 Status: 401 Unauthorized 的錯誤訊息。\n  先登入取得 Token\n  先加入 Authorization Header，並將登入成功後回傳的 Token 加到 Authorization Header 中。再次送出就可正常的取得所有天氣預測資料了。\n 使用 OpenApi Swagger 來測試 API  OpenApi Swagger 來測試 API時, 因為　Swagger 測試網頁預設是沒有設定 Token 的功能,必須將程式碼中的 builder.Services.AddSwaggerGen();改成以下內容\n builder.Services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;JwtDemo\u0026#34;, Version = \u0026#34;v1\u0026#34; }); c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { In = ParameterLocation.Header, Description = \u0026#34;Please enter JWT with Bearer into field\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, Type = SecuritySchemeType.ApiKey }); c.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} }, new string[] {} } }); });  有了上述的程式設定，當再次 dotnet run 啟動程式後，瀏覽器呈現的 Swagger 畫面右上角會多出了｀Authorize｀ 的按鈕。按下按鈕就是讓你填入登入成功後回傳的 Token\n  在 Value: 文字框內填入 \u0026ldquo;Bearer yJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTUxMiIsInR5cCI6IkpXVCJ9\u0026hellip;..\u0026quot;，再按下 Authorize 按鈕即表下在接下來的 Request 中都會自動帶入 Token 傳給 WebApi Server。 （請注意 Bearer後再先接著一個空白字元再加上 Token值）\n  再次執行　\u0026ldquo;WeatherForecast\u0026rdquo; 的測試(Execute)　就可正常的取得回傳值了\n  　若要使用 \u0026ldquo;角色\u0026rdquo; 的授權檢核，只須將｀[Authorize]｀改成｀[Authorize(Roles = UserRoles.Admin)]｀即可\n 1 2 3 4 5 6 7 8 9 10 11 12  [Authorize(Roles = UserRoles.Admin)] [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); }   加入 git 版本控制 $ git commit -m \u0026#34;finished JWT function\u0026#34; -a 使用　aspnet-codegenerator　工具來自動産生程式碼 最後我們來看看如何使用工具來自動産生程式去維護一個新的資料表\n在 Models 目錄下新增一個 model(模型) class - ItemData  Models/ItemData.cs\n namespace dotnet6_webapi_jwt.Models; public class ItemData { public int Id { get; set; } public string? Title { get; set; } public string? Details { get; set; } public bool Done { get; set; } } 在 ApiDbContext.cs 中宣告一個 ItemData table public DbSet\u0026lt;ItemData\u0026gt;? ItemData { get; set; } 新增一個遷移與更新資料庫 $ dotnet build $ dotnet ef migrations add \u0026#34;Add New Table - ItemData\u0026#34; $ dotnet ef database update 使用 ASPNET Codegenerator 自動產生 Todo Controller $ dotnet aspnet-codegenerator controller -name TodoController -async -api -m ItemData -dc ApiDbContext -outDir Controllers Building project ... Finding the generator \u0026#39;controller\u0026#39;... Running the generator \u0026#39;controller\u0026#39;... Minimal hosting scenario! Attempting to compile the application in memory with the modified DbContext. Attempting to figure out the EntityFramework metadata for the model and DbContext: \u0026#39;ItemData\u0026#39; info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 6.0.5 initialized \u0026#39;ApiDbContext\u0026#39; using provider \u0026#39;Microsoft.EntityFrameworkCore.SqlServer:6.0.5\u0026#39; with options: None Added Controller : \u0026#39;/Controllers/TodoController.cs\u0026#39;. RunTime 00:00:10.90  TodoController.cs\n using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; using Microsoft.EntityFrameworkCore; using dotnet6_webapi_jwt.Data; using dotnet6_webapi_jwt.Models; namespace dotnet6_webapi_jwt.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class TodoController : ControllerBase { private readonly ApiDbContext _context; public TodoController(ApiDbContext context) { _context = context; } // GET: api/Todo [HttpGet] public async Task\u0026lt;ActionResult\u0026lt;IEnumerable\u0026lt;ItemData\u0026gt;\u0026gt;\u0026gt; GetItemData() { if (_context.ItemData == null) { return NotFound(); } return await _context.ItemData.ToListAsync(); } // GET: api/Todo/5 [HttpGet(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;ItemData\u0026gt;\u0026gt; GetItemData(int id) { if (_context.ItemData == null) { return NotFound(); } var itemData = await _context.ItemData.FindAsync(id); if (itemData == null) { return NotFound(); } return itemData; } // PUT: api/Todo/5  // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754 [HttpPut(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; PutItemData(int id, ItemData itemData) { if (id != itemData.Id) { return BadRequest(); } _context.Entry(itemData).State = EntityState.Modified; try { await _context.SaveChangesAsync(); } catch (DbUpdateConcurrencyException) { if (!ItemDataExists(id)) { return NotFound(); } else { throw; } } return NoContent(); } // POST: api/Todo  // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754 [HttpPost] public async Task\u0026lt;ActionResult\u0026lt;ItemData\u0026gt;\u0026gt; PostItemData(ItemData itemData) { if (_context.ItemData == null) { return Problem(\u0026#34;Entity set \u0026#39;ApiDbContext.ItemData\u0026#39; is null.\u0026#34;); } _context.ItemData.Add(itemData); await _context.SaveChangesAsync(); return CreatedAtAction(\u0026#34;GetItemData\u0026#34;, new { id = itemData.Id }, itemData); } // DELETE: api/Todo/5 [HttpDelete(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; DeleteItemData(int id) { if (_context.ItemData == null) { return NotFound(); } var itemData = await _context.ItemData.FindAsync(id); if (itemData == null) { return NotFound(); } _context.ItemData.Remove(itemData); await _context.SaveChangesAsync(); return NoContent(); } private bool ItemDataExists(int id) { return (_context.ItemData?.Any(e =\u0026gt; e.Id == id)).GetValueOrDefault(); } } } 測試新功能  在 open api - swagger 網頁上透過 POST 的 EndPoint 新增一筆 Toto list\n  送出新增的資料，回覆新增成功\n  由資料庫中可以查詢到新建立的 record\n  透過 GET 的 EndPoint 也可以查詢到新增 Toto list\n 以上可以發現使用 ASPNET Codegenerator 自動産生的程式就可簡單的完成資料表格的新增、查詢、修改、刪除等日常功能，真是方便呢！\n","permalink":"https://calvinegs.github.io/posts/dotnet6-webapi-jwt/","summary":"github Source code #tag: dotnet6_webapi_jwt\n本文將記錄如何一步步從無到有使用 Dotnet Core 6.0 建立 ASP.NET Core Web API，其中將會使用到下列技術:\n Dotnet CLI Entity Framework Json Web Token SQL Server (Docker Version) ASP.NET Core Generator  建置新專案 $ dotnet new webapi -o dotnet6-webapi-jwt 範本「ASP.NET Core Web API」已成功建立。 正在處理建立後的動作... 正在 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/dotnet6-webapi-jwt.csproj 上執行 \u0026#39;dotnet restore\u0026#39;... 正在判斷要還原的專案... 已還原 /home/egs/cal-data/tech-test/webapi/dotnet6-webapi-jwt/dotnet6-webapi-jwt.csproj (238 ms 內)。 還原成功。 $ cd dotnet6-webapi-jwt $ ls -al 總用量 40 drwxrwxr-x 5 egs egs 4096 五 20 09:38 .","title":"使用 .NET 6.0 進行 JWT 身份驗證的 ASP.NET Web Api。並使用 Microsoft Identity 框架來存儲使用者和角色等資料"},{"content":"如何在 Ubuntu 中使用 Docker 啟動 MS SQL Server 2019  參考資料：　https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15\u0026amp;pivots=cs1-bash\n 首先當然在你的作業系統中必須先安裝好 Docker 下載　SQL Server Image file $ sudo docker pull mcr.microsoft.com/mssql/server:2019-latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mcr.microsoft.com/mssql/server 2019-latest f554c0722914 4 weeks ago 1.64GB 使用 Docker 把 SQL Server image file 啟動 $ docker run -e \u0026quot;ACCEPT_EULA=Y\u0026quot; -e \u0026quot;SA_PASSWORD=Sql@1234\u0026quot; \\ -p 1433:1433 --name sql1 -h sql1 \\ -d mcr.microsoft.com/mssql/server:2019-latest $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 36c9fe84ea3e mcr.microsoft.com/mssql/server:2019-latest \u0026quot;/opt/mssql/bin/perm…\u0026quot; 42 hours ago Up 40 minutes 0.0.0.0:1433-\u0026gt;1433/tcp, :::1433-\u0026gt;1433/tcp sql1 修改 SA Password $ docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd \\  -S localhost -U SA -P \u0026#34;Sql@1234\u0026#34; \\  -Q \u0026#39;ALTER LOGIN SA WITH PASSWORD=\u0026#34;Sql@12345\u0026#34;\u0026#39; 連接上 Docker 中的 SQL Server $ docker exec -it sql1 \u0026#34;bash\u0026#34; 執行 SQL Commander 工具來操作 SQL Server mssql@sql1:/$ /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P \u0026#34;Sql@12345\u0026#34; 查看 SQL Server 版本 1\u0026gt; select @@version 2\u0026gt; go Microsoft SQL Server 2019 (RTM-CU16) (KB5011644) - 15.0.4223.1 (X64) Apr 11 2022 16:24:07 Copyright (C) 2019 Microsoft Corporation Developer Edition (64-bit) on Linux (Ubuntu 20.04.4 LTS) \u0026lt;X64\u0026gt; (1 rows affected) 建立 TestDB 資料庫 1\u0026gt; CREATE DATABASE TestDB 2\u0026gt; Select name from sys.databases 3\u0026gt; go 在 TestDB 資料庫中建立 Inventory 資料表 並 寫入資料 1\u0026gt; USE TestDB 2\u0026gt; CREATE TABLE Inventory (id INT, name NVARCHAR(50), quantity INT) 3\u0026gt; INSERT INTO Inventory VALUES (1, \u0026#39;banana\u0026#39;, 150); INSERT INTO Inventory VALUES (2, \u0026#39;orange\u0026#39;, 154); 4\u0026gt; go 查詢 Inventory 資料表 1\u0026gt; SELECT * FROM Inventory WHERE quantity \u0026gt; 152; 2\u0026gt; go 離開 SQL Commder 工具 1\u0026gt; quit 離開 Docker 環境 mssql@sql1:/$ exit 安裝 dbeaver-ce  有了資料後，通常你會需要一個管理工具來連結上該資料庫來做一些日常的資料管理。由於工作關係，會常使用到各式資料庫，若你的管理工具只適用某類資料，那勢必要安裝好幾個工具了。在此建議可使用 bdeaver-cd (https://dbeaver.io/download/)\n $ wget https://dbeaver.io/files/dbeaver-ce_latest_amd64.deb $ sudo dpkg -i dbeaver-ce_latest_amd64.deb  安裝完成後啟動它，進行連結資料庫設定   連結 SQL Server 資料庫   管理資料庫 - 查詢資料表資料、結構、修改資料表資料、結構\u0026hellip;  ","permalink":"https://calvinegs.github.io/posts/sqlserver2019-docker/","summary":"如何在 Ubuntu 中使用 Docker 啟動 MS SQL Server 2019  參考資料：　https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15\u0026amp;pivots=cs1-bash\n 首先當然在你的作業系統中必須先安裝好 Docker 下載　SQL Server Image file $ sudo docker pull mcr.microsoft.com/mssql/server:2019-latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mcr.microsoft.com/mssql/server 2019-latest f554c0722914 4 weeks ago 1.64GB 使用 Docker 把 SQL Server image file 啟動 $ docker run -e \u0026quot;ACCEPT_EULA=Y\u0026quot; -e \u0026quot;SA_PASSWORD=Sql@1234\u0026quot; \\ -p 1433:1433 --name sql1 -h sql1 \\ -d mcr.microsoft.com/mssql/server:2019-latest $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 36c9fe84ea3e mcr.","title":"Run SQL Server container images with Docker"},{"content":"github Source code #tag: minimal_webapi_jwt\n本篇筆記中將紀錄如何使用 ASP.NET Core 6 提供的 Minimal APIs 新框架建置一個使用 Token-base 身份驗證的 Web API 網站。\n建立新專案 $ dotnet new webapi -o JwtAuthDemo -minimal 範本「ASP.NET Core Web API」已成功建立。 正在處理建立後的動作... 正在 /home/egs/cal-data/tech-test/webapi/Minimal/JwtAuthDemo/JwtAuthDemo.csproj 上執行 \u0026#39;dotnet restore\u0026#39;... 正在判斷要還原的專案... 已還原 /home/egs/cal-data/tech-test/webapi/Minimal/JwtAuthDemo/JwtAuthDemo.csproj (214 ms 內)。 還原成功。 $ cd JwtAuthDemo $ ls -al 總用量 32 drwxrwxr-x 4 egs egs 4096 五 13 18:36 . drwxrwxr-x 7 egs egs 4096 五 13 18:36 .. -rw-rw-r-- 1 egs egs 127 五 13 18:36 appsettings.Development.json -rw-rw-r-- 1 egs egs 151 五 13 18:36 appsettings.json -rw-rw-r-- 1 egs egs 327 五 13 18:36 JwtAuthDemo.csproj drwxrwxr-x 2 egs egs 4096 五 13 18:36 obj -rw-rw-r-- 1 egs egs 1131 五 13 18:36 Program.cs drwxrwxr-x 2 egs egs 4096 五 13 18:36 Properties  dotnet code 版本安裝與管理\n $ dotnet --list-sdks # 顯示已安裝的 sdk 版本資訊 5.0.408 [/usr/share/dotnet/sdk] 6.0.300 [/usr/share/dotnet/sdk] $ dotnet --version # 顯示目前所使用的版本 6.0.300 # 預設是最新的版本  由於 dotnet 版本演化滿快的，所以會建議在專案目錄中要指定使用 SDK 的版本，以免當你又安裝了更新版本（如7.0）後程式執行出問題。\n $ dotnet new globaljson --sdk-version 6.0.300 範本「global.json 檔案」已成功建立。 $ cat global.json { \u0026#34;sdk\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;6.0.300\u0026#34; } }  使用 dotnet cli 來產生預設的 git ignore 檔案\n $ dotnet new gitignore  建立 git 初始版本\n $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34;  安裝 Microsoft.AspNetCore.Authentication.JwtBearer 套件\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  $ dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer  $ cat JwtAuthDemo.csproj \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; Version=\u0026#34;6.0.5\u0026#34; /\u0026gt;  \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;6.2.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;    加入 Git 新版本\n $ git commit -m \u0026#34;Add new package Microsoft.AspNetCore.Authentication.JwtBearer\u0026#34; -a $ code . # 打開 VS Code  目前産生的程式架構\n  執行程式\n $ dotnet watch 實作 JWT 的流程 上圖中可以看到，由系統自動産生的 sample code 已經可以正常執行。\n接下來將在程式中實作JWT功能， 透過 JWT　的實作可以讓你的專案實現 Token-base 的身份驗證與授權。 （Json Web Token) 實作的過程大致可以分成三個部分:\n 在登入成功後産生合法的 JWT Token 每次收到 request 時驗證是否為合法有效的 JWT Token 在特定 API Endpoint 上驗證是否帶有 “合法有效的 JWT Token”，以達到權限管理的需求  産生合法的 Jason Web Token  在 Program.cs 中新一個建立 Token 的 function\n string CreateToken(LoginViewModel user) { List\u0026lt;Claim\u0026gt; claims = new List\u0026lt;Claim\u0026gt; { new Claim(ClaimTypes.Name, user.Username), new Claim(ClaimTypes.Role, \u0026#34;Admin\u0026#34;) }; ConfigurationManager _configuration = builder.Configuration; var secretkey = new SymmetricSecurityKey(System.Text.Encoding.UTF8.GetBytes( _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;))); // _configuration.GetSection(\u0026#34;JwtSettings:Secret\u0026#34;).Value)  var credentials = new SigningCredentials(secretkey, SecurityAlgorithms.HmacSha512Signature); var token = new JwtSecurityToken( // 亦可使用　SecurityTokenDescriptor　來産生 Token  issuer: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), audience: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Audience\u0026#34;), claims: claims, expires: DateTime.Now.AddDays(1), signingCredentials: credentials); var jwt = new JwtSecurityTokenHandler().WriteToken(token); return jwt; }  建立一個 登入 的 Endpoint\n app.MapPost(\u0026#34;/signin\u0026#34;, (LoginViewModel login) =\u0026gt; { if (ValidateUser(login)) // 驗證登入的帳號是否合法  { var token = CreateToken(login); // 若為合法使用者，則産生一個使用 Token  return Results.Ok(new { token }); // 將登入狀態與Token一併回傳前端  } else { return Results.BadRequest(); // 驗證失敗時回傳 status: 400 Bad Request  } } ).WithName(\u0026#34;SignIn\u0026#34;).AllowAnonymous(); bool ValidateUser(LoginViewModel login) { return login.Username == \u0026#34;cal\u0026#34; ? true : false; }  建立一個 model 來接收 login 資料\n record LoginViewModel(string Username, string Password); 驗證是否為合法有效的 JWT Token  第一步，透過 DI 將 JWT 相關設定設置好\n builder.Services .AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { // 當驗證失敗時，回應標頭會包含 WWW-Authenticate 標頭，這裡會顯示失敗的詳細錯誤原因  options.IncludeErrorDetails = true; // 預設值為 true，有時會特別關閉  options.TokenValidationParameters = new TokenValidationParameters { // 透過這項宣告，就可以從 \u0026#34;NAME\u0026#34; 取值  NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, // 透過這項宣告，就可以從 \u0026#34;Role\u0026#34; 取值，並可讓 [Authorize] 判斷角色  RoleClaimType = \u0026#34;http://schemas.microsoft.com/ws/2008/06/identity/claims/role\u0026#34;, // 驗證 Issuer (一般都會)  ValidateIssuer = true, ValidIssuer = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), // 驗證 Audience (通常不太需要)  ValidateAudience = false, //ValidAudience = \u0026#34;JwtAuthDemo\u0026#34;, // 不驗證就不需要填寫  // 驗證 Token 的有效期間 (一般都會)  ValidateLifetime = true, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已  ValidateIssuerSigningKey = false, // 應該從 IConfiguration 取得  IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)) }; }); builder.Services.AddAuthorization();  第二步，要記得也要啟動 request pipeline 中的 Middleware (UseAuthentication \u0026amp; UseAuthorization 都需要)\n app.UseAuthentication(); app.UseAuthorization(); 在特定 API EndPoint 上驗證是否帶有合法有效的 JWT Token  加入.RequireAuthorization() 即可\n 1 2 3 4 5 6 7 8 9 10 11 12 13  app.MapGet(\u0026#34;/weatherforecast\u0026#34;, () =\u0026gt; { var forecast = Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast ( DateTime.Now.AddDays(index), Random.Shared.Next(-20, 55), summaries[Random.Shared.Next(summaries.Length)] )) .ToArray(); return forecast; }) .WithName(\u0026#34;GetWeatherForecast\u0026#34;).RequireAuthorization();    如上程式加入.RequireAuthorization()後，再重新瀏覽 weatherforecast endpoint，會回傳 Status: 401 Unauthorized 的錯誤訊息。\n  使用 Postman，先加入 Authorization Header，並將登入成功後回傳的 Token 加到 Authorization Header 中。再次送出就可正常的取得所有天氣預測資料了。\n  加入 git 版本控制\n $ git commit -m \u0026#34;finished JWT function\u0026#34; -a  完整程式如下(Program.cs)\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166  using System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using System.Text; using Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.IdentityModel.Tokens; var builder = WebApplication.CreateBuilder(args); ConfigurationManager _configuration = builder.Configuration; var secret = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Secret\u0026#34;); // Add services to the container. // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); builder.Services .AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { // 當驗證失敗時，回應標頭會包含 WWW-Authenticate 標頭，這裡會顯示失敗的詳細錯誤原因  options.IncludeErrorDetails = true; // 預設值為 true，有時會特別關閉  options.TokenValidationParameters = new TokenValidationParameters { // 透過這項宣告，就可以從 \u0026#34;NAME\u0026#34; 取值  NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, // 透過這項宣告，就可以從 \u0026#34;Role\u0026#34; 取值，並可讓 [Authorize] 判斷角色  RoleClaimType = \u0026#34;http://schemas.microsoft.com/ws/2008/06/identity/claims/role\u0026#34;, // 驗證 Issuer (一般都會)  ValidateIssuer = true, ValidIssuer = _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), // 驗證 Audience (通常不太需要)  ValidateAudience = false, //ValidAudience = \u0026#34;JwtAuthDemo\u0026#34;, // 不驗證就不需要填寫  // 驗證 Token 的有效期間 (一般都會)  ValidateLifetime = true, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已  ValidateIssuerSigningKey = false, // 應該從 IConfiguration 取得  IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)) }; }); builder.Services.AddAuthorization(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthentication(); app.UseAuthorization(); var summaries = new[] { \u0026#34;Freezing\u0026#34;, \u0026#34;Bracing\u0026#34;, \u0026#34;Chilly\u0026#34;, \u0026#34;Cool\u0026#34;, \u0026#34;Mild\u0026#34;, \u0026#34;Warm\u0026#34;, \u0026#34;Balmy\u0026#34;, \u0026#34;Hot\u0026#34;, \u0026#34;Sweltering\u0026#34;, \u0026#34;Scorching\u0026#34; }; app.MapGet(\u0026#34;/weatherforecast\u0026#34;, () =\u0026gt; { var forecast = Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast ( DateTime.Now.AddDays(index), Random.Shared.Next(-20, 55), summaries[Random.Shared.Next(summaries.Length)] )) .ToArray(); return forecast; }) .WithName(\u0026#34;GetWeatherForecast\u0026#34;).RequireAuthorization(); app.MapPost(\u0026#34;/signin\u0026#34;, (LoginViewModel login) =\u0026gt; { if (ValidateUser(login)) { var token = CreateToken(login); return Results.Ok(new { token }); } else { return Results.BadRequest(); } } ).WithName(\u0026#34;SignIn\u0026#34;).AllowAnonymous(); string CreateToken(LoginViewModel user) { List\u0026lt;Claim\u0026gt; claims = new List\u0026lt;Claim\u0026gt; { new Claim(ClaimTypes.Name, user.Username), new Claim(ClaimTypes.Role, \u0026#34;Admin\u0026#34;), new Claim(ClaimTypes.Role, \u0026#34;Users\u0026#34;), new Claim(\u0026#34;ProjectType\u0026#34;, \u0026#34;TTG\u0026#34;), }; var secretkey = new SymmetricSecurityKey(System.Text.Encoding.UTF8.GetBytes(secret)); // _configuration.GetSection(\u0026#34;JwtSettings:Secret\u0026#34;).Value)  var credentials = new SigningCredentials(secretkey, SecurityAlgorithms.HmacSha512Signature); var token = new JwtSecurityToken( // 亦可使用　SecurityTokenDescriptor　來産生 Token  issuer: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), audience: _configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Audience\u0026#34;), claims: claims, expires: DateTime.Now.AddDays(1), signingCredentials: credentials); var jwt = new JwtSecurityTokenHandler().WriteToken(token); return jwt; } bool ValidateUser(LoginViewModel login) { return login.Username == \u0026#34;cal\u0026#34; ? true : false; } app.MapGet(\u0026#34;/claims\u0026#34;, (ClaimsPrincipal user) =\u0026gt; { return Results.Ok(user.Claims.Select(p =\u0026gt; new { p.Type, p.Value })); }) .WithName(\u0026#34;Claims\u0026#34;) .RequireAuthorization(); app.MapGet(\u0026#34;/username\u0026#34;, (ClaimsPrincipal user) =\u0026gt; { return Results.Ok(user.Claims.FirstOrDefault(p =\u0026gt; p.Type == ClaimTypes.Name)?.Value); }) .WithName(\u0026#34;Username\u0026#34;) .RequireAuthorization(); app.MapGet(\u0026#34;/roles\u0026#34;, (ClaimsPrincipal user) =\u0026gt; { return Results.Ok(user.Claims.Select(p =\u0026gt; new { p.Type, p.Value }).Where( c=\u0026gt; c.Type == ClaimTypes.Role)); }) .WithName(\u0026#34;Userrole\u0026#34;) .RequireAuthorization(); app.MapGet(\u0026#34;/issuer\u0026#34;, (ClaimsPrincipal user) =\u0026gt; { return Results.Ok(user.Claims.FirstOrDefault(p =\u0026gt; p.Type == \u0026#34;iss\u0026#34;)?.Value); }) .WithName(\u0026#34;Issuer\u0026#34;) .RequireAuthorization(); await app.RunAsync(); record WeatherForecast(DateTime Date, int TemperatureC, string? Summary) { public int TemperatureF =\u0026gt; 32 + (int)(TemperatureC / 0.5556); } record LoginViewModel(string Username, string Password);   使用 OpenApi Swagger 來測試 API  將程式碼中的 builder.Services.AddSwaggerGen();改成以下內容\n builder.Services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;JwtDemo\u0026#34;, Version = \u0026#34;v1\u0026#34; }); c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { In = ParameterLocation.Header, Description = \u0026#34;Please enter JWT with Bearer into field\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, Type = SecuritySchemeType.ApiKey }); c.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} }, new string[] {} } }); });  有了上述的程式設定，當再次 dotnet run 啟動程式後，瀏覽器呈現的 Swagger 畫面右上角會多出了｀Authorize｀ 的按鈕。按下按鈕就是讓你填入登入成功後回傳的 Token\n  在 Value: 文字框內填入 \u0026ldquo;Bearer yJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTUxMiIsInR5cCI6IkpXVCJ9\u0026hellip;..\u0026quot;，再按下 Authorize 按鈕即表下在接下來的 Request 中都會自動帶入 Token 傳給 WebApi Server。 （請注意 Bearer後再先接著一個空白字元再加上 Token值）\n ","permalink":"https://calvinegs.github.io/posts/dotnet6-minimalapi-jwt/","summary":"github Source code #tag: minimal_webapi_jwt\n本篇筆記中將紀錄如何使用 ASP.NET Core 6 提供的 Minimal APIs 新框架建置一個使用 Token-base 身份驗證的 Web API 網站。\n建立新專案 $ dotnet new webapi -o JwtAuthDemo -minimal 範本「ASP.NET Core Web API」已成功建立。 正在處理建立後的動作... 正在 /home/egs/cal-data/tech-test/webapi/Minimal/JwtAuthDemo/JwtAuthDemo.csproj 上執行 \u0026#39;dotnet restore\u0026#39;... 正在判斷要還原的專案... 已還原 /home/egs/cal-data/tech-test/webapi/Minimal/JwtAuthDemo/JwtAuthDemo.csproj (214 ms 內)。 還原成功。 $ cd JwtAuthDemo $ ls -al 總用量 32 drwxrwxr-x 4 egs egs 4096 五 13 18:36 . drwxrwxr-x 7 egs egs 4096 五 13 18:36 .. -rw-rw-r-- 1 egs egs 127 五 13 18:36 appsettings.","title":"使用 ASP.NET Core 6 提供的 Minimal APIs 新框架建置一個極簡的 Web API 服務"},{"content":"Snowpack 號稱是更快速的前端建構工具，在開發 Web 應用程式的工作流程中，它可以替代更重、更複雜的打包工具，如 webpack 或 Parcel。\n在此不會討論 Snowpack 的設計細節，只紀錄如可快速的使用 Snowpack 來建置一個由 Typescript 支援網頁程式。由撰寫 Typescript 的過程中了解到強型別（及與搭配 vscode 編輯器）所帶來的好處。\n使用 create-snowpack-app 建立專案 bash``` $ mkdir doto-list \u0026amp;\u0026amp; cd todo-list $ $ npx create-snowpack-app . \u0026ndash;template @snowpack/app-template-blank-typescript \u0026ndash;force $ npm install $ code .\n\u0026gt; 産生的程式結構如下： ![程式結構](https://user-images.githubusercontent.com/21993717/166859633-95c09b00-2d36-4912-9d5a-91c5ff33ad32.png) \u0026gt; package.json ```json {hl_lines=[3,17,18]} { \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;snowpack dev\u0026quot;, \u0026quot;build\u0026quot;: \u0026quot;snowpack build\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;echo \\\u0026quot;This template does not include a test runner by default.\\\u0026quot; \u0026amp;\u0026amp; exit 1\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;prettier --write \\\u0026quot;src/**/*.{ts,js}\\\u0026quot;\u0026quot;, \u0026quot;lint\u0026quot;: \u0026quot;prettier --check \\\u0026quot;src/**/*.{ts,js}\\\u0026quot;\u0026quot; }, \u0026quot;dependencies\u0026quot;: { \u0026quot;canvas-confetti\u0026quot;: \u0026quot;^1.2.0\u0026quot; }, \u0026quot;devDependencies\u0026quot;: { \u0026quot;@snowpack/plugin-typescript\u0026quot;: \u0026quot;^1.2.1\u0026quot;, \u0026quot;@types/canvas-confetti\u0026quot;: \u0026quot;^1.0.0\u0026quot;, \u0026quot;@types/snowpack-env\u0026quot;: \u0026quot;^2.3.3\u0026quot;, \u0026quot;prettier\u0026quot;: \u0026quot;^2.2.1\u0026quot;, \u0026quot;snowpack\u0026quot;: \u0026quot;^3.3.7\u0026quot;, \u0026quot;typescript\u0026quot;: \u0026quot;^4.2.4\u0026quot; } }  $ npm start  開始建置 Todo List 網頁 調整 index.html  首先將 public/index.html 內容修改如下：\n \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Web site created using create-snowpack-app\u0026#34; /\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/dist/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;Snowpack App\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #list { list-style: none; padding: 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; id=\u0026#34;new-task-form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;new-task-title\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 安裝額外的 module $ npm install uuid $ npm install types@uuid --save-dev # uuid moduel 不是 Typescript 所撰寫，要將 uuid 使用在 Typescript 中必須搭配額外的宣告檔，透過這個宣告檔，我們就能享受強型別的好處 { \u0026#34;dependencies\u0026#34;: { \u0026#34;canvas-confetti\u0026#34;: \u0026#34;^1.2.0\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;^8.3.2\u0026#34;  }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@snowpack/plugin-typescript\u0026#34;: \u0026#34;^1.2.1\u0026#34;, \u0026#34;@types/canvas-confetti\u0026#34;: \u0026#34;^1.0.0\u0026#34;, \u0026#34;@types/snowpack-env\u0026#34;: \u0026#34;^2.3.3\u0026#34;, \u0026#34;@types/uuid\u0026#34;: \u0026#34;^8.3.4\u0026#34;,  \u0026#34;prettier\u0026#34;: \u0026#34;^2.2.1\u0026#34;, \u0026#34;snowpack\u0026#34;: \u0026#34;^3.3.7\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.2.4\u0026#34; } } 使用 uuid  修改 src/index.ts 內容\n import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; console.log(uuidV4());  存檔後由瀏覽器 Console 視窗中可以看到由 uuid module 提供的功能所産生的 ID： ｀637fd7c4-1bc3-444a-9335-4b355617edbd｀\n import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; //console.log(uuidV4());  const list = document.querySelector(\u0026#39;#list\u0026#39;); 開始撰寫程式 import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;);  將滑鼠移至 list 變數，可以發現目前 list 的型別是 \u0026ldquo;Element 或 null\u0026rdquo;。\n  透過 index.html 我們可以知道 #list 其實是 ul list，在透過 TypeScript 來撰寫程式時我們可以多利用它的型別檢核，來更方便、更正確的使用程式中的變數。\n import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; //console.log(uuidV4());  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;);  透過上述程式，使用 泛型 指定querySelector 回傳的是｀HTMLUListElement｀，再將滑鼠移至 list 變數，可以發現目前 list 的型別已經變成是 \u0026ldquo;HTMLUListElement 或 null\u0026rdquo;。這樣的好處是在接下去的程式中可以更精準的使用 list 這個物件。當使用了不是 HTMLUlistElement的屬性時，編輯器就會給你警告，讓程式錯誤在編輯時期就能即時發現。這就是 Typescript 強型別的好處。\n  將 index.ts 程式修改如下：\n import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;);  要注意的是 document.getElementById 的語法必不支援泛型，必須改成強制轉型的方式來限制回傳的型別\n  繼續完成 index.ts 程式，當你輸入form.addEventListener 按下 tab 時，VSCode 編輯器會自動將你輸入的程式改成 form?.addEventListener。原因是編輯器知道 form 變數的型別是 HTMLFormElement | null 而自動幫你調整合適的語法。 一樣的道理，在你輸入 input.value 後編輯器也會幫忙調成 input?.value。\n import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); form?.addEventListener(\u0026#34;submit\u0026#34;, e =\u0026gt; { e.preventDefault(); if (input?.value == \u0026#34;\u0026#34; || input?.value == null) return; input.value })  在上圖程式第 11 行，可發現此時的 input 變數的型別是 HTMLInputElement | null，但在本行程式後，由於已排除 null 的可能性，所在在程式第 13 行的 input 變數的型別已成為 HTMLInputElement(如下圖)\n  繼續完成當按下 \u0026ldquo;Sumit\u0026rdquo; 按鈕時要將新的 Task 加入到 Doto list 清單中\n import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); form?.addEventListener(\u0026#34;submit\u0026#34;, e =\u0026gt; { e.preventDefault(); if (input?.value == \u0026#34;\u0026#34; || input?.value == null) return; // 取得一個新的 Task  const newTask = { id: uuidV4(), title: input.value, completed: false, createdAt: new Date() }; // 透過 addListItem 這個 Function 來新增一個 Todo List  addListItem(newTask); }) function addListItem(task) { }  完成上述程式後，發現在 VSCode 編輯器中給了一個警告，告訴我們參數的型別不符，在 function 宣告中應該為參數設定適當的型別\n  透過編輯器我們可以 newTask 的型別\n  將 function 中參數型別設定成如下圖，編輯器不再有警告訊息\n function addListItem(task : { id: string, title: string, completed: boolean, createdAt: Date }) { }  但這樣的寫法顯然的不是好方式，改寫成如下，將 Task 的型別定義成一個叫 Task custom type，並將這個新的型別分別套用在 NewTask 宣告的地方以及 addListItem function 宣告的地方\n import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; // console.log(uuidV4());  type Task = { id: string; title: string; completed: boolean; createdAt: Date; }  const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); form?.addEventListener(\u0026#34;submit\u0026#34;, e =\u0026gt; { e.preventDefault(); if (input?.value == \u0026#34;\u0026#34; || input?.value == null) return; // 取得一個新的 Task  const newTask: Task = {  id: uuidV4(), title: input.value, completed: false, createdAt: new Date() }; // 透過 addListItem 這個 Function 來新增一個 Todo List  addListItem(newTask); }) function addListItem(task : Task) { }  經過強型別的設計可以很方便的在程式撰寫時就找出可能有問題的程式碼，如下圖：當傳給 addListItem 的參數型別不正確時，編輯器立即會顯示警告訊息。\n  繼續完成 addListItem function 的處理邏輯：\n function addListItem(task : Task) { const item = document.createElement(\u0026#34;li\u0026#34;); const lable = document.createElement(\u0026#34;label\u0026#34;); const checkbox = document.createElement(\u0026#34;input\u0026#34;); checkbox.type=\u0026#34;checkbox\u0026#34;; checkbox.checked = task.completed; lable.append(checkbox, task.title); item.append(lable); list?.append(item); }  執行結果\n  程式至此已經可以加入新 Task 也可以設定（勾選）是否已完成，但當按下 瀏覧器的 ｀重新載入此頁｀ 功能時會發現所有新增的 Tasks 都會不見，接下來我們將加 Local Storeage 的功能將新增的 Tasks 不僅顯示在畫面上也會寫入到 Local Storeage 中，在重新載入時會將紀錄在 Local Storeage 的 Tasks 再重新顯示在畫面中。\n 完成後程式 import {v4 as uuidV4 } from \u0026#39;uuid\u0026#39;; type Task = { id: string; title: string; completed: boolean; createdAt: Date; } const list = document.querySelector\u0026lt;HTMLUListElement\u0026gt;(\u0026#39;#list\u0026#39;); const form = document.getElementById(\u0026#39;new-task-form\u0026#39;) as HTMLFormElement | null; const input = document.querySelector\u0026lt;HTMLInputElement\u0026gt;(\u0026#39;#new-task-title\u0026#39;); const tasks: Task[] = LoadTasks(); // TasK[] 預設由 Local Storeage 中載入所有已新增的 Task tasks.forEach(addListItem); //將 Task[] 中的 Task 顯示到畫面上  form?.addEventListener(\u0026#34;submit\u0026#34;, e =\u0026gt; { e.preventDefault(); if (input?.value == \u0026#34;\u0026#34; || input?.value == null) return; // 取得一個新的 Task  const newTask: Task = { id: uuidV4(), title: input.value, completed: false, createdAt: new Date() }; tasks.push(newTask); // 透過 addListItem 這個 Function 來新增一個 Todo List  addListItem(newTask); input.value = \u0026#34;\u0026#34;; // 將 input 清空  input.focus(); // 將焦點重新定位在 input element 上  }) function addListItem(task : Task) { const item = document.createElement(\u0026#34;li\u0026#34;); const lable = document.createElement(\u0026#34;label\u0026#34;); const checkbox = document.createElement(\u0026#34;input\u0026#34;); checkbox.addEventListener(\u0026#34;change\u0026#34;, () =\u0026gt; { task.completed = checkbox.checked; saveTasks(); // checkbox 有變化時，將 Tasks 寫入 Local Storeage  }) checkbox.type=\u0026#34;checkbox\u0026#34;; checkbox.checked = task.completed; saveTasks(); // 新增 Task 時，將 Tasks 寫入 Local Storeage  lable.append(checkbox, task.title); item.append(lable); list?.append(item); } function saveTasks() { localStorage.setItem(\u0026#34;TASKS\u0026#34;, JSON.stringify(tasks)); }  function LoadTasks(): Task[] { const taskJSON = localStorage.getItem(\u0026#34;TASKS\u0026#34;); if (taskJSON == null) return []; return JSON.parse(taskJSON); }  在瀏覧器的 “開發人員工具” 的 “Application\u0026quot; 功能中透過 Clear All 可將 Local Storage 資料清除。清除後再按下 “重新載入這個網頁” 畫面會回到初始狀態。\n  新增 Task、改變 Task 完成否，再 “重新載入這個網頁”，畫面如我們希望的保留了我們已新增/修改的狀態。\n ","permalink":"https://calvinegs.github.io/posts/snowpack-typescript/","summary":"Snowpack 號稱是更快速的前端建構工具，在開發 Web 應用程式的工作流程中，它可以替代更重、更複雜的打包工具，如 webpack 或 Parcel。\n在此不會討論 Snowpack 的設計細節，只紀錄如可快速的使用 Snowpack 來建置一個由 Typescript 支援網頁程式。由撰寫 Typescript 的過程中了解到強型別（及與搭配 vscode 編輯器）所帶來的好處。\n使用 create-snowpack-app 建立專案 bash``` $ mkdir doto-list \u0026amp;\u0026amp; cd todo-list $ $ npx create-snowpack-app . \u0026ndash;template @snowpack/app-template-blank-typescript \u0026ndash;force $ npm install $ code .\n\u0026gt; 産生的程式結構如下： ![程式結構](https://user-images.githubusercontent.com/21993717/166859633-95c09b00-2d36-4912-9d5a-91c5ff33ad32.png) \u0026gt; package.json ```json {hl_lines=[3,17,18]} { \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;snowpack dev\u0026quot;, \u0026quot;build\u0026quot;: \u0026quot;snowpack build\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;echo \\\u0026quot;This template does not include a test runner by default.\\\u0026quot; \u0026amp;\u0026amp; exit 1\u0026quot;, \u0026quot;format\u0026quot;: \u0026quot;prettier --write \\\u0026quot;src/**/*.","title":"使用 Snowpack + Typescript 來建置一個 Web App"},{"content":"github Source code #tag: restapi_nodejs\nKEYWORD： MongoDB Cloud Services、Node.js、REST API、JWT、加解密、MongoDB Compass、Postman、express、cryptojs、dotenv、jsonwebtoken、mongoose\n設置專案環境 $ node --version # 檢測環境已裝妥 node.js (若已安裝會顯示目前安裝的版本） $ mkdir ecommerceapi \u0026amp;\u0026amp; cd ecommerceapi ＃ 建立一個專案目錄 $ npm init -y\t＃ 産一專案設定檔 package.json $ touch index.js\t＃ 産生一個新檔案 $ yarn add express mongoose dotenv\t# 加入相依套件 $ yarn add --dev nodemon # 加入開發時期相依套件 $ git init $ echo \u0026#39;node_modules/\u0026#39; \u0026gt; .gitignore # 新增 git ignore 設定檔，並設定 node_modules/ 目錄不加入版控 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 建立第一版本的資訊  設定專案啟動指令（如第七行的指令設定），當輸入 npm start 時系統自動以 node 來執行 index.js 程式，並即時監測 index.js 檔案有變化存檔時馬上重新啟動 node index.js 來執行該程式。\n { \u0026#34;name\u0026#34;: \u0026#34;ecom\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;nodemon index.js\u0026#34;  }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;dotenv\u0026#34;: \u0026#34;^16.0.0\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;^4.17.3\u0026#34;, \u0026#34;mongoose\u0026#34;: \u0026#34;^6.3.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;nodemon\u0026#34;: \u0026#34;^2.0.15\u0026#34; } }  在 index.js 中加入此行程式，並在 vscode Terminal 中輸入 npm start\n console.log(\u0026#34;Hi NodeJS...\u0026#34;)\t 顯示結果如下\n Hi NodeJS... 建立一個 Express 應用程式  使用以下程式覆蓋 index.js 檔案\n const express = require(\u0026#34;express\u0026#34;); const app = express(); app.get(\u0026#34;api/test\u0026#34;, () =\u0026gt; { console.log(\u0026#34;test is successful\u0026#34;); }); app.listen(5000, () =\u0026gt; { console.log(\u0026#34;Backend server is running...\u0026#34;); })  存檔後，開啟 瀏覽器，輸入 localhost:5000/api/test，在 vscode terminal 視窗中會顯示：\n Backend server is running... test is successful 使用 Node.js 連結 MongoDB 在使用 MongoDB 除了在 local 端安裝的方式外，也可以使用 Docker 的方式來啟用 MongoDB，而更方便的是直接使用 https://cloud.mongodb.com/ 線上的免費服務。\n在註冊完成後，可认在 Database / Connect / Connect your application 中找到連結字串  在程式中使用了 mongoose 這個套件的功能來連結 MongoDB 資料庫（第三行），並在程式第6行，connect function 中放入“連結字串”\n const express = require(\u0026#34;express\u0026#34;); const app = express(); const mongoose = require(\u0026#34;mongoose\u0026#34;);  mongoose .connect(\u0026#34;mongodb+srv://calv______ @cluster0.6f8ky.mongodb.net/myFirstDatabase?retryWrites=true\u0026amp;w=majority\u0026#34;)  .then(()=\u0026gt;console.log(\u0026#34;DB Connection successful\u0026#34;)) .catch((err)=\u0026gt; { console.log(err) } ); app.listen(5000, () =\u0026gt; { console.log(\u0026#34;Backend server is running...\u0026#34;); })  存檔後，在 vscode terminal 視窗中會顯示：\n Backend server is running... DB Connection successful  表示連結成功。\n 彈性管理程式中的“設定值”  使用 dotenv 套件的功能來管理程式中相關的設定值\n  首先在專案根目錄下建立一個名為 \u0026ldquo;.env\u0026rdquo; 的檔案  MONGO_URL=mongodb+srv://cal...............  在程式中先匯入 dotenv 套件(第1行），再“啟動它”(第2行），使用時透過 “process.env.MONGO_URL\u0026quot; 語法(第4行） 第十行程式碼中的 process.env.PORT 為相同的原則可在 .evn 檔案中加入 PORT 的設定值調整  const dotenv = require(\u0026#34;dotenv\u0026#34;); dotenv.config(); mongoose .connect(process.env.MONGO_URL) .then(()=\u0026gt;console.log(\u0026#34;DB Connection successful\u0026#34;)) .catch((err)=\u0026gt; { console.log(err) } ); app.listen(process.env.PORT || 5000, ()=\u0026gt;{ # port 預設為 5000 ，並可以在 .env 檔案中進行客製化 （如：PORT＝5001） console.log(\u0026#34;Backend server is running...\u0026#34;); }) 了解 Node.js 路由  新增 routes 目錄，在此目錄下新增 user.js 檔案\n  routes/user.js\n const router = require(\u0026#34;express\u0026#34;).Router(); router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); module.exports = router;  在 index.js 程式中先匯入 \u0026ldquo;./routes/user\u0026rdquo; 這個 router 設定檔，再透過 app.use 語法來使用這個 router(第18行)。完整的 route 為 http://localhost:5000/api/user/usertest\n const express = require(\u0026#34;express\u0026#34;); const app = express(); const mongoose = require(\u0026#34;mongoose\u0026#34;); const dotenv = require(\u0026#34;dotenv\u0026#34;); const userRoute = require(\u0026#34;./routes/user\u0026#34;);  dotenv.config(); mongoose .connect(process.env.MONGO_URL) .then(()=\u0026gt;console.log(\u0026#34;DB Connection successful\u0026#34;)) .catch((err)=\u0026gt; { console.log(err) } ); app.use(\u0026#34;/api/users\u0026#34;, userRoute);  app.listen(process.env.PORT || 5000, ()=\u0026gt;{ console.log(\u0026#34;Backend server is running...\u0026#34;); });  開啟瀏覧器，輸入 http:5000/api/users/usertest，瀏覧器將呈現成功訊息\n user test is successfull  為 routes/user.js 再新增一個 post method\n const router = require(\u0026#34;express\u0026#34;).Router(); router.get(\u0026#34;/usertest\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;user test is successful\u0026#34;); }); router.post(\u0026#34;/userposttest\u0026#34;, (req, res) =\u0026gt; { const username = req.body.username; res.send(\u0026#34;your username is: \u0026#34; + username) })  module.exports = router;  使用 postman 來測試 post，結果回傳的是 Server Error，原因是 express 預設是不接受 json 格式的資料。\n  在 index.js 程式中加入如第一行的設定\n app.use(express.json()); app.use(\u0026#34;/api/users\u0026#34;, userRoute);  設定完成後就可正常了  使用 Node.js MongoDB 模型  接下來我們將資料寫入 MongoDB 資料庫中，首先要先建立 model file(模型檔案），在這個檔案中使用了 mongoose 的 Schema 的語法，只要在新增資料時套用這個這個模型檔，則會自動在 MongoDB 中建立相對應的 collection，將資料存入資料庫中。\n 新增 User 模型檔 (models/User.js)  先新增一個 models 目錄，在目錄下新增一個 User.js，內容如下\n const mongoose = require(\u0026#34;mongoose\u0026#34;); const UserSchema = new mongoose.Schema({ username: { type: String, required: true, unique: true }, email: { type: String, required: true, unique: true }, password: { type: String, required: true }, isAdmin: { type: Boolean, default: false }, }, { timestamps: true } // 透過這個屬性設定，會自動在collection中新增二個屬性: createdAt、updateedAt。 ); module.exports = mongoose.model(\u0026#34;User\u0026#34;, UserSchema); 建立 auth.js router file (routes/auth.js) 將使用者資料註冊和資用者帳號驗證的機制獨立在這個 route file 中，讓程式結構更清晰。內容如下：\nconst router = require(\u0026#34;express\u0026#34;).Router(); const User = require(\u0026#34;../models/User\u0026#34;); // 帳號註冊 router.post(\u0026#34;/register\u0026#34;, async (req, res) =\u0026gt; { const newUser = new User({  username: req.body.username, email: req.body.email, password: req.body.password, }); try { const savedUser = await newUser.save();  res.status(201).json(savedUser); } catch (err) { res.status(500).json(err); } }); module.exports = router;  在 index.js 引用這個新的 router\n const express = require(\u0026#34;express\u0026#34;); const app = express(); const mongoose = require(\u0026#34;mongoose\u0026#34;); const dotenv = require(\u0026#34;dotenv\u0026#34;); const userRoute = require(\u0026#34;./routes/user\u0026#34;); const authRoute = require(\u0026#34;./routes/auth\u0026#34;);  dotenv.config(); mongoose .connect(process.env.MONGO_URL) .then(()=\u0026gt;console.log(\u0026#34;DB Connection successful\u0026#34;)) .catch((err)=\u0026gt; { console.log(err) } ); app.use(express.json()); app.use(\u0026#34;/api/users\u0026#34;, userRoute); app.use(\u0026#34;/api/auth\u0026#34;, authRoute); app.listen(process.env.PORT || 5000, ()=\u0026gt;{ console.log(\u0026#34;Backend server is running...\u0026#34;); });  執行成功後，查看 MongoDB 資料庫的結果：  使用 crypto.js 來為敏感資料加密 由上述的查詢畫面可以得知 Password 欄位是以明碼儲存，此類敏感資料可以透過加密技術來加強它的安全性。\ncryptojs 是一個 javascript 的加解密函數庫，使用前先安裝套件： $ yarn add crypto-js\nconst CryptoJS = require(\u0026#34;crypto-js\u0026#34;); password: CryptoJS.AES.encrypt(req.body.password, process.env.PASS_SEC), encrypt function 參數除了要加密的字串外，需要一個加密 Key，為彈性起見，把它寫在 .env 檔案中\nMONGO_URL=mongodb+srv://cal......... PASS_SEC=cal 加密後的 password 如下：\n{ \u0026#34;username\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;,  \u0026#34;password\u0026#34;: \u0026#34;U2FsdGVkX19F5ULehTVaQfCzw3B0xIefomDIZTTop7g=\u0026#34;, \u0026#34;isAdmin\u0026#34;: false, \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 } login function (解密) 繼續完成 auth.js 中的 LOGIN 功能，\n// 帳號登錄 router.post(\u0026#34;/login\u0026#34;, async (req, res) =\u0026gt; { try { const user = await User.findOne({ username: req.body.username }); !user \u0026amp;\u0026amp; res.status(401).json(\u0026#34;Wrong Credentials!\u0026#34;); const hashedPassword = CryptoJS.AES.decrypt(user.password, process.env.PASS_SEC); const orginalPassword = hashedPassword.toString(CryptoJS.enc.Utf8); orginalPassword !== req.body.password \u0026amp;\u0026amp; res.status(401).json(\u0026#34;Wrong Credentials!\u0026#34;); res.status(200).json(user); } catch(err) { res.status(500).json(err) } })  使用 postman 來執行 Login   上圖的 User 回傳資料中為安全起見，應該把 password 欄位隱蔵起來。透過javascript 解構語法很容易就可完成這個需求。\n // 帳號登錄 router.post(\u0026#34;/login\u0026#34;, async (req, res) =\u0026gt; { try { const user = await User.findOne({ username: req.body.username }); !user \u0026amp;\u0026amp; res.status(401).json(\u0026#34;Wrong Credentials!\u0026#34;); const hashedPassword = CryptoJS.AES.decrypt(user.password, process.env.PASS_SEC); const orginalPassword = hashedPassword.toString(CryptoJS.enc.Utf8); orginalPassword !== req.body.password \u0026amp;\u0026amp; res.status(401).json(\u0026#34;Wrong Credentials!\u0026#34;); const { password, ...others } = user._doc; res.status(200).json(others); } catch(err) { res.status(500).json(err) } }) { \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;, \u0026#34;isAdmin\u0026#34;: false, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 } 在 Node.js 中使用 JWT 來進行 Token-Based 的使用者授權驗證 為使我們的應用程式更安全 Token-Based 的授權驗證方式來設計 API\n安裝套件：$ yarn add jsonwebtoken\n産生 JWT 在登入證驗中加入産生 Token 的邏輯，在檢核使用者輸入的密碼正確後，將 User ID (_id這個內部 Key)及 isAdmin這兩個屬性值透過 sign function 來産生 access token，並回傳給前端。\nconst jwt = require(\u0026#34;jsonwebtoken\u0026#34;); // 匯入 JsonWebToken套件 ... const accessToken = jwt.sign( { id: user._id, isAdmin: user.isAdmin }, process.env.JWT_SEC, { expiresIn: \u0026#34;3d\u0026#34; } ); ... res.status(200).json({ ...others, accessToken });  依照貫例將 Json web token 的 key 值放在 .env 檔案中\n MONGO_URL=mongodb+srv://cal....... PASS_SEC=cal JWT_SEC=cal  使用 postman 再 Login 一次，會發現回傳的資料中已經包含一個合乎的 JWT Token了\n 使用 JWT 在前端取得合法的 JWT Token後，來看看當使用者在呼叫其他 API 時一併回傳的 Token　如何在 server 端來進行驗證。\n首先我們要在 routes 目錄中新增一個名為 verifyToken.js 的 express Middleware\nconst jwt = require(\u0026#34;jsonwebtoken\u0026#34;); const verifyToken = (req, res, next) =\u0026gt; {  const authHeader = req.headers.token; if (authHeader) { const token = authHeader.split(\u0026#34; \u0026#34;)[1]; jwt.verify(token, process.env.JWT_SEC, (err, user) =\u0026gt; { if (err) res.status(403).json(\u0026#34;Token 不合法！\u0026#34;); req.user = user; next(); }) } else { return res.status(401).json(\u0026#34;未被授權執行本功能！\u0026#34;); } }; const verifyTokenAndAuthorization = (req, res, next) =\u0026gt; {  verifyToken(req, res, () =\u0026gt; { if (req.user.id === req.params.id || req.user.isAdmin) { next(); } else { res.status(403).json(\u0026#34;不允許執行本功能！\u0026#34;); } }) }; const verifyTokenAndAdmin = (req, res, next) =\u0026gt; {  verifyToken(req, res, () =\u0026gt; { if (req.user.isAdmin) { next(); } else { res.status(403).json(\u0026#34;非管理者不允許執行本功能！\u0026#34;); } }) }; module.exports = { verifyToken, verifyTokenAndAuthorization，　verifyTokenAndAdmin };  在 user.js　Route file 中加入 update username 的功能\n const router = require(\u0026#34;express\u0026#34;).Router(); const User = require(\u0026#34;../models/User\u0026#34;); const { verifyToken, verifyTokenAndAuthorization } = require(\u0026#34;./verifyToken\u0026#34;);  router.put(\u0026#34;/:id\u0026#34;, verifyTokenAndAuthorization, async (req, res) =\u0026gt; {  if (req.user.id === req.params.id || req.user.isAdmin) { if (req.body.password) { req.body.password = CryptoJS.AES.encrypt( req.body.password, process.env.PASS_SEC ).toString(); } }; try { const updatedUser = await User.findByIdAndUpdate(  req.params.id, { $set: req.body, }, { new: true } ); res.status(200).json(updatedUser); } catch(err) { res.status(403).json(err); } }); module.exports = router;  先取得 user collection 第一個 document 的 key id   在 postman 新增一個 put 的 request，URL = localhost:5000/api/users/6269f53be0bd74d778bb8934，其中的“6269f53be0bd74d778bb8934”　指的是要變更的 document 的ID。同時在Headers中新加入一個 token 的　header\n  其內容值 = \u0026ldquo;Bearer token_value\u0026rdquo;，注意 \u0026ldquo;Bearer\u0026rdquo; 後要有一個“空白字元”\n  這個 request 的 body 存放的是一個 json 格式的資料，也就是要變更的 username\n  送出 request 成功後回傳值的是修改後的 user document\n { \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;calUpdate\u0026#34;,  \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;U2FsdGVkX19F5ULehTVaQfCzw3B0xIefomDIZTTop7g=\u0026#34;, \u0026#34;isAdmin\u0026#34;: false, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-28T09:59:33.456Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 }  若送出 request 中未包含 Token 則會回傳“未被授權執行本功能”。\n  若送出 request 中包含的是不合法的 Token 則會回傳“Token不合法“。\n  緊接著在 user.js　Route file 中再加入 delete user 資料的功能\n router.delete(\u0026#34;/:id\u0026#34;, verifyTokenAndAuthorization, async (req, res) =\u0026gt; { try { await User.findByIdAndDelete(req.params.id);  res.status(200).json(updatedUser); } catch(err) { res.status(403).json(err); } });  另外在 user.js　Route file 中再加入 get user 的功能，而執行本功能的授權檢核邏輯改成 verifyTokenAndAdmin，也就是必須是具有 admin 身份的使用者才能執行本功能。\n router.get(\u0026#34;/find/:id\u0026#34;, verifyTokenAndAdmin, async (req, res) =\u0026gt; { try { const user = await User.findById(req.params.id);  const { password, ...others } = user._doc; res.status(200).json(other); } catch(err) { res.status(500).json(err); } });  若你使用的 token 所代表的 user isAdmin=false 的話，將回傳\u0026quot;非管理者不允許執行本功能！\u0026ldquo;的警告訊息。   我們再新註冊一個新的使用者：   並在 MongoDB 中把這個新使用者的isAdmin修改成true   使用這個帳號來登入並取後 token 值。   使用這個 token 值來呼叫 GET USER 功能就可以正常的取得要查詢的使用者資料了\n {  \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;, \u0026#34;isAdmin\u0026#34;: false, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-29T02:56:33.670Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 } 如何處理 URL 中的 query string  在　user.js Route file 中再加入 get all users 的功能。\n router.get(\u0026#34;/\u0026#34;, verifyTokenAndAdmin, async (req, res) =\u0026gt; { try { const users = await User.find(); res.status(200).json(users);  } catch(err) { res.status(500).json(err); } });  在 url 中輸入：localhost:5000/api/users/，將回傳所有的 users 資料\n [ { \u0026#34;_id\u0026#34;: \u0026#34;6269f53be0bd74d778bb8934\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;calvin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;cal@gmail.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;U2FsdGVkX19F5ULehTVaQfCzw3B0xIefomDIZTTop7g=\u0026#34;, \u0026#34;isAdmin\u0026#34;: false, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-28T02:00:27.195Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-29T02:56:33.670Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 }, { \u0026#34;_id\u0026#34;: \u0026#34;626b55f9af6c24eb6c911f40\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;admin@gmail.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;U2FsdGVkX190QQrScanCS64GYHup956hNIQ5ALKbjS4=\u0026#34;, \u0026#34;isAdmin\u0026#34;: true, \u0026#34;createdAt\u0026#34;: \u0026#34;2022-04-29T03:05:29.788Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2022-04-29T03:05:29.788Z\u0026#34;, \u0026#34;__v\u0026#34;: 0 } ]  如果想要由 url 中加入額外的 query string 來達到動態執行不同的邏輯，應該憅麼做呢？如：localhost:5000/api/users?new=true 我們來看看程式中要如何來處理 url 所傳入的 query string\n // GET ALL USERS router.get(\u0026#34;/\u0026#34;, verifyTokenAndAdmin, async (req, res) =\u0026gt; {  const query = req.query.new; // 透過 req.query.new 來取得 new 這個 query string 的值  try {  const users = query ? await User.find().sort({ _id: -1 }).limit(5) : await User.find(); res.status(200).json(users); } catch(err) { res.status(500).json(err); } });  上述的程式中 User.find().sort({ _id: -1 }).limit(5) 表示的是找出至多五筆的 User 資料並以 _id 來進行‘反’排序，-1表反排序。整個處理還輯表示若在 url 中輸入 localhost:5000/api/users 的話，會回傳所有 User 的資料。若於 url 中輸入 localhost:5000/api/users?new=true，則會回傳 最多五筆並以 _id 來進行‘反’排序的 User 資料。\n ","permalink":"https://calvinegs.github.io/posts/nodejs-restapi-example/","summary":"github Source code #tag: restapi_nodejs\nKEYWORD： MongoDB Cloud Services、Node.js、REST API、JWT、加解密、MongoDB Compass、Postman、express、cryptojs、dotenv、jsonwebtoken、mongoose\n設置專案環境 $ node --version # 檢測環境已裝妥 node.js (若已安裝會顯示目前安裝的版本） $ mkdir ecommerceapi \u0026amp;\u0026amp; cd ecommerceapi ＃ 建立一個專案目錄 $ npm init -y\t＃ 産一專案設定檔 package.json $ touch index.js\t＃ 産生一個新檔案 $ yarn add express mongoose dotenv\t# 加入相依套件 $ yarn add --dev nodemon # 加入開發時期相依套件 $ git init $ echo \u0026#39;node_modules/\u0026#39; \u0026gt; .gitignore # 新增 git ignore 設定檔，並設定 node_modules/ 目錄不加入版控 $ git add .","title":"使用 Node.js + express 建立一個電子商務後端服務的 REST API"},{"content":"rest 和 spread 之間的主要區別在於，rest 運算符將使用者提供的特定的值的“其餘”部分放入 JavaScript 陣列中。但是擴展語法將可疊代物件擴展為各別的元素。\nrest 的範例 // 將使用者提供的某些值放入陣列中 function myBio(firstName, lastName, ...otherInfo) {  return otherInfo; } // 呼叫 myBio 功能時傳入五個參數值: myBio(\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;); // 回傳以下陣列: [\u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;] // 宣告二個一般變數及一個 rest 變數，再使用 destructruing 方式給值: const [firstName, lastName, ...otherInfo] = [  \u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34; ]; console.log(otherInfo); // 結果: [\u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;] // ES7+的物件屬性其餘運算符 const {a, b, ...rest} = {a:1, b:2, c:3, d:4} //a=1, b=2, rest={c:3, d:4}  let options = { title: \u0026#34;Menu\u0026#34;, height: 200, width: 100 }; // title = property named title // rest = object with the rest of properties let {title, ...rest} = options; // now title=\u0026#34;Menu\u0026#34;, rest={height: 200, width: 100} alert(rest.height); // 200 alert(rest.width); // 100 function sum(...numbers) { let result = 0 result = numbers.reduce((orgValue, value) =\u0026gt; orgValue += value) return result } console.log(sum(1)); // 1 console.log(sum(1, 2, 3, 4, 5)); // 15 spread 的範例 // 定義一個有三個參數傳入值的功能 function myBio(firstName, lastName, company) { return `${firstName} ${lastName} runs ${company}`; } // 使用擴展運算符將陣列中的值展開至各別的參數中: myBio(...[\u0026quot;Oluwatobi\u0026quot;, \u0026quot;Sofela\u0026quot;, \u0026quot;CodeSweetly\u0026quot;]); // 上述程式的結果: “Oluwatobi Sofela runs CodeSweetly” let first = [1,3,5]; let second = [2,4,6]; second = [ ...first, ...second]; console.log(\u0026quot;second : \u0026quot;, second); // second [ 1, 3, 5, 2, 4, 6 ] const myName = \u0026#34;Oluwatobi Sofela\u0026#34;; console.log([...myName]); // The invocation above will return: [ \u0026#34;O\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;a\u0026#34; ] const numbers = [1, 3, 5, 7, 10, 200, 90, 59]; function addNumbers(a, b, c, d) { return a + b + c + d; } console.log(addNumbers(...numbers)); // The invocation above will return: 16 // 將擴展運算符運用在物件上 const myNames = [\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;]; const bio = { ...myNames, runs: \u0026#34;codesweetly.com\u0026#34; }; console.log(bio); // The invocation above will return: { 0: \u0026#34;Oluwatobi\u0026#34;, 1: \u0026#34;Sofela\u0026#34;, runs: \u0026#34;codesweetly.com\u0026#34; } // 相同屬性會被覆蓋 const myName = { firstName: \u0026#34;Tobi\u0026#34;, lastName: \u0026#34;Sofela\u0026#34; }; const bio = { ...myName, firstName: \u0026#34;Oluwatobi\u0026#34;, website: \u0026#34;codesweetly.com\u0026#34; }; console.log(bio); // The invocation above will return: { firstName: \u0026#34;Oluwatobi\u0026#34;, lastName: \u0026#34;Sofela\u0026#34;, website: \u0026#34;codesweetly.com\u0026#34; }; // myName 陣列的值都是 Primitive value, 所以 myName 陣列的變化不會反應到 aboutMe 陣列中 const myName = [\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;]; const aboutMe = [\u0026#34;Oluwatobi\u0026#34;, ...myName, \u0026#34;name.\u0026#34;]; console.log(aboutMe); // The invocation above will return: [\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;name.\u0026#34;]  myName.push(\u0026#34;real\u0026#34;);  console.log(myName); // [\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;real\u0026#34;] console.log(aboutMe); // [\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;name.\u0026#34;] // myName 陣列的值包含了 non-primitive value, 所以 myName 陣列的變化會影響 aboutMe 陣列 const myName = [[\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;]]; const aboutMe = [\u0026#34;Oluwatobi\u0026#34;, ...myName, \u0026#34;name.\u0026#34;]; console.log(aboutMe); // The invocation above will return: [ \u0026#34;Oluwatobi\u0026#34;, [\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;], \u0026#34;name.\u0026#34; ]  myName[0].push(\u0026#34;real\u0026#34;);  console.log(myName); // [[\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;real\u0026#34;]] console.log(aboutMe); // [\u0026#34;Oluwatobi\u0026#34;, [\u0026#34;Sofela\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;real\u0026#34;], \u0026#34;name.\u0026#34;] ","permalink":"https://calvinegs.github.io/posts/rest-spread-js/","summary":"rest 和 spread 之間的主要區別在於，rest 運算符將使用者提供的特定的值的“其餘”部分放入 JavaScript 陣列中。但是擴展語法將可疊代物件擴展為各別的元素。\nrest 的範例 // 將使用者提供的某些值放入陣列中 function myBio(firstName, lastName, ...otherInfo) {  return otherInfo; } // 呼叫 myBio 功能時傳入五個參數值: myBio(\u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;); // 回傳以下陣列: [\u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;] // 宣告二個一般變數及一個 rest 變數，再使用 destructruing 方式給值: const [firstName, lastName, ...otherInfo] = [  \u0026#34;Oluwatobi\u0026#34;, \u0026#34;Sofela\u0026#34;, \u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34; ]; console.log(otherInfo); // 結果: [\u0026#34;CodeSweetly\u0026#34;, \u0026#34;Web Developer\u0026#34;, \u0026#34;Male\u0026#34;] // ES7+的物件屬性其餘運算符 const {a, b, ...rest} = {a:1, b:2, c:3, d:4} //a=1, b=2, rest={c:3, d:4}  let options = { title: \u0026#34;Menu\u0026#34;, height: 200, width: 100 }; // title = property named title // rest = object with the rest of properties let {title, .","title":"透過範例了解 Javascript Rest ＆ Spread 運算符有何不同"},{"content":"物件解構 指定值給已存在的變數 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, color : \u0026#34;red\u0026#34; }; const { name, power, color } = superHero; console.log(\u0026#34;name:\u0026#34;, name); // Spiderman console.log(\u0026#34;color:\u0026#34;, color); // red console.log(\u0026#34;power:\u0026#34;, power); // Spider Sense 重新指定值的用法 const superMan = { name : \u0026#34;Superman\u0026#34;, power : \u0026#34;Super Sense\u0026#34;, color : \u0026#34;blue\u0026#34; }; ({ name, power, color } = superMan); console.log(\u0026#34;name:\u0026#34;, name); console.log(\u0026#34;color:\u0026#34;, color); console.log(\u0026#34;power:\u0026#34;, power); 指定值給新的變數 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, color : \u0026#34;red\u0026#34; }; const { name : n, power : p, color : c } = superHero; console.log(\u0026#34;color:\u0026#34;, c); // red console.log(\u0026#34;power:\u0026#34;, p); // Spider Sense console.log(\u0026#34;name:\u0026#34;, n); // Spiderman 預設值 const person = { name: \u0026#39;Skay\u0026#39;, age: 38 }; // Assign default value of Canada to country if undefined const { name, age, country = \u0026#39;Canada\u0026#39; } = person; console.log(`I am ${name}from ${country}and I am ${age}years old.`); // Output -\u0026gt; I am Skay from Canada and I am 38 years old.\u0026#39; 解構回傳值 const data = () =\u0026gt; ({ name: \u0026#39;George\u0026#39;, role: \u0026#39;SA\u0026#39; }); const { name, role } = data(); 槽狀的解構 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, \u0026#34;character\u0026#34; : { \u0026#34;realName\u0026#34; : \u0026#34;Tom Holland\u0026#34;, \u0026#34;citizenship\u0026#34; : \u0026#34;British\u0026#34;, \u0026#34;appearances\u0026#34; : { \u0026#34;movie\u0026#34; : \u0026#34;captain america civil war\u0026#34;, \u0026#34;releaseDate\u0026#34; : \u0026#34;6 May 2016\u0026#34; } } }; const { character } = superHero; console.log(character); { realName: \u0026#39;Tom Holland\u0026#39;, citizenship: \u0026#39;British\u0026#39;, appearances: { movie: \u0026#39;captain america civil war\u0026#39;, releaseDate: \u0026#39;6 May 2016\u0026#39; } } const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, \u0026#34;character\u0026#34; : { \u0026#34;realName\u0026#34; : \u0026#34;Tom Holland\u0026#34;, \u0026#34;citizenship\u0026#34; : \u0026#34;British\u0026#34;, \u0026#34;appearances\u0026#34; : { \u0026#34;movie\u0026#34; : \u0026#34;captain america civil war\u0026#34;, \u0026#34;releaseDate\u0026#34; : \u0026#34;6 May 2016\u0026#34; } } }; const { character : {appearances : { movie }} } = superHero; console.log(movie); captain america civil war 陣列解構 // we have an array with the name and surname let arr = [\u0026#34;John\u0026#34;, \u0026#34;Smith\u0026#34;] // destructuring assignment // sets firstName = arr[0] // and surname = arr[1] let [firstName, surname] = arr;  console.log(firstName); // John console.log(surname); // Smith let [firstName, surname] = \u0026#34;John Smith\u0026#34;.split(\u0026#39; \u0026#39;); alert(firstName); // John alert(surname); // Smith // 變數值互換 const a = 1, b = 2; [b, a] = [a, b] //a=2, b=1 const [a, [b, [c, d]]] = [1, [2, [[[3, 4], 5], 6]]]; console.log(c); //[ [ 3, 4 ], 5 ] 乎略某些值 // second element is not needed let [firstName, , title] = [\u0026#34;Julius\u0026#34;, \u0026#34;Caesar\u0026#34;, \u0026#34;Consul\u0026#34;, \u0026#34;of the Roman Republic\u0026#34;]; console.log(title); // Consul 支援任何可疊代的值 let [a, b, c] = \u0026#34;abc\u0026#34;; // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] let [one, two, three] = new Set([1, 2, 3]); 預設值 let [a, b, c] = \u0026#34;abc\u0026#34;; // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] let [one, two, three] = new Set([1, 2, 3]); ","permalink":"https://calvinegs.github.io/posts/destructuring-js/","summary":"物件解構 指定值給已存在的變數 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, color : \u0026#34;red\u0026#34; }; const { name, power, color } = superHero; console.log(\u0026#34;name:\u0026#34;, name); // Spiderman console.log(\u0026#34;color:\u0026#34;, color); // red console.log(\u0026#34;power:\u0026#34;, power); // Spider Sense 重新指定值的用法 const superMan = { name : \u0026#34;Superman\u0026#34;, power : \u0026#34;Super Sense\u0026#34;, color : \u0026#34;blue\u0026#34; }; ({ name, power, color } = superMan); console.log(\u0026#34;name:\u0026#34;, name); console.log(\u0026#34;color:\u0026#34;, color); console.log(\u0026#34;power:\u0026#34;, power); 指定值給新的變數 const superHero = { name : \u0026#34;Spiderman\u0026#34;, power : \u0026#34;Spider Sense\u0026#34;, color : \u0026#34;red\u0026#34; }; const { name : n, power : p, color : c } = superHero; console.","title":"透過範例了解 Javascript Destructuring (解構指定值)"},{"content":"Keyboard Shortcuts For Ubuntu Terminal 基本操作  Ctrl+Alt+T: 開啟新終端機\nCtrl+Shift+W：關閉終端機 (關閉 Tab）\nCtrl+D：關閉未輸入任何指令終端機 (關閉 Tab）\nCtrl+C：取消正在執行中的指令\nCtrl+L： 清除終端機畫面\nCtrl+Shift+T： 開啟新的 Tab\nALT+［數字鍵］： 移到第幾個 Tab\nCtrl+PgUp/PgDn： 切換 Tab\nCtrl+Shift+'+': Zoom In\nCtrl+'-': Zoom Out\n 在終端機中移動  Ctrl+A: 游標移動到一行開頭\nCtrl+E: 游標移動到一行結尾\nCtrl+F: 游標往前移動一個字元\nCtrl+B: 游標往後移動一個字元\nAlt+F: 游標往前移動一個字 (同 Alt+l)\nAlt+B: 游標往後移動一個字\n 修改文字的操作  Ctrl+D: 刪除游標所在的字元\nCtrl+H: 刪除游標所在的前一個字元\nCtrl+U: 刪除游標所在位置之前的所有字元\nCtrl+K: 刪除游標所在位置之後的所有字元（含游標所在的字元)\nCtrl+W: 刪除游標所在的這個一個字（除游標所在的字元外)\nCtrl+T: 交換游標所在的字元與前一個字元位置\nAlt+T: 交換游標所在的字與前一個字位置\nAlt+U: 將游標所在的字從游標開始的字元起轉換成大寫\n History  Ctrl+R: 以Key word方式反向搜尋 History 指令\nCtrl+P: 前一個 History 中的指令\nCtrl+N: 下一個 History 中的指令\n  $ HISTTIMEFORMAT=\u0026quot;%Y-%m-%d %T \u0026quot;\n ","permalink":"https://calvinegs.github.io/posts/terminal-shortcuts/","summary":"Keyboard Shortcuts For Ubuntu Terminal 基本操作  Ctrl+Alt+T: 開啟新終端機\nCtrl+Shift+W：關閉終端機 (關閉 Tab）\nCtrl+D：關閉未輸入任何指令終端機 (關閉 Tab）\nCtrl+C：取消正在執行中的指令\nCtrl+L： 清除終端機畫面\nCtrl+Shift+T： 開啟新的 Tab\nALT+［數字鍵］： 移到第幾個 Tab\nCtrl+PgUp/PgDn： 切換 Tab\nCtrl+Shift+'+': Zoom In\nCtrl+'-': Zoom Out\n 在終端機中移動  Ctrl+A: 游標移動到一行開頭\nCtrl+E: 游標移動到一行結尾\nCtrl+F: 游標往前移動一個字元\nCtrl+B: 游標往後移動一個字元\nAlt+F: 游標往前移動一個字 (同 Alt+l)\nAlt+B: 游標往後移動一個字\n 修改文字的操作  Ctrl+D: 刪除游標所在的字元\nCtrl+H: 刪除游標所在的前一個字元\nCtrl+U: 刪除游標所在位置之前的所有字元\nCtrl+K: 刪除游標所在位置之後的所有字元（含游標所在的字元)\nCtrl+W: 刪除游標所在的這個一個字（除游標所在的字元外)\nCtrl+T: 交換游標所在的字元與前一個字元位置\nAlt+T: 交換游標所在的字與前一個字位置\nAlt+U: 將游標所在的字從游標開始的字元起轉換成大寫\n History  Ctrl+R: 以Key word方式反向搜尋 History 指令","title":"Ubuntu 終端機常用快速鍵"},{"content":"網頁製作時，手刻 HTML/CSS 即傷神又容易出錯，讓我們來看看 Emmet 如何快速又便捷的協助我們進行 HTML/CSS 的輸入。\nElements 輸入 div 按下 Enter 或 Tab 鍵，輸入 innerHtml - abc 再按下 Ctrl+Enter 鍵\n\u0026lt;div\u0026gt;abc\u0026lt;/div\u0026gt; 輸入 p 按下 Enter 或 Tab 鍵，輸入 innerHtml -abc 再按下 Ctrl+Enter 鍵\n\u0026lt;p\u0026gt;abc\u0026lt;/p\u0026gt; Nesting operators Child: \u0026gt; div\u0026gt;ul\u0026gt;li\n\u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; Sibling: + div+p+bq\n\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; Climb-up: ^ div+div\u0026gt;p\u0026gt;span+em\ndiv+div\u0026gt;p\u0026gt;span+em^bq\ndiv+div\u0026gt;p\u0026gt;span+em^^^bq\n\u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em^bq --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em^^^bq --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; Multiplication: * ul\u0026gt;li*5\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Grouping: () div\u0026gt;(header\u0026gt;ul\u0026gt;li*2\u0026gt;a)+footer\u0026gt;p\n\u0026lt;div\u0026gt; \u0026lt;header\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; (div\u0026gt;dl\u0026gt;(dt+dd)*3)+footer\u0026gt;p\n\u0026lt;div\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; Attribute operators abbr#anId.aClass[style=color:blue; title=\u0026lsquo;Hypertext Markup Language\u0026rsquo;]{HTML}\n\u0026lt;abbr title=\u0026quot;Hypertext Markup Language\u0026quot; id=\u0026quot;anId\u0026quot; class=\u0026quot;aClass\u0026quot; style=\u0026quot;color:blue;\u0026quot; \u0026gt;HTML\u0026lt;/abbr \u0026gt; ID and CLASS div#header+div.page+div#footer.class1.class2.class3\n\u0026lt;div id=\u0026quot;header\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;page\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;footer\u0026quot; class=\u0026quot;class1 class2 class3\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; div.class1\n\u0026lt;div class=\u0026quot;class1\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; (header\u0026gt;ul.nav\u0026gt;li*5)+footer\n\u0026lt;header\u0026gt; \u0026lt;ul class=\u0026quot;nav\u0026quot;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;footer\u0026gt;\u0026lt;/footer\u0026gt; Custome attributes td[title=\u0026ldquo;Hello world!\u0026rdquo; colspan=3]\n\u0026lt;td title=\u0026quot;Hello world!\u0026quot; colspan=\u0026quot;3\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; a:blank\n\u0026lt;a href=\u0026quot;http://\u0026quot; target=\u0026quot;_blank\u0026quot; rel=\u0026quot;noopener noreferrer\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; Item numbering: $ ul\u0026gt;li.item$*5\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item1\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item2\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item$$$*5\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item001\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item002\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item003\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item004\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item005\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item$@-*5\n註: @-: 表示反向排序\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item2\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item1\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item$@3*5\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item6\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item7\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item$@-3*5\n\" data-lang=\"\" \u0026lt;li class=\u0026quot;item7\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item6\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul\u0026gt;li.item${Item $@3}*5\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item1\u0026quot;\u0026gt;Item 3\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item2\u0026quot;\u0026gt;Item 4\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;Item 5\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;Item 6\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item5\u0026quot;\u0026gt;Item 7\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ul.my-list\u0026gt;(li.my-list-item#id-$$)*6\n\u0026lt;ul class=\u0026quot;my-list\u0026quot;\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-01\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-02\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-03\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-04\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-05\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;my-list-item\u0026quot; id=\u0026quot;id-06\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Text: a{Click me}\n\u0026lt;!-- a{click}+b{here} --\u0026gt; \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;click\u0026lt;/a\u0026gt;\u0026lt;b\u0026gt;here\u0026lt;/b\u0026gt; \u0026lt;!-- a\u0026gt;{click}+b{here} --\u0026gt; \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;click\u0026lt;b\u0026gt;here\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;!-- p\u0026gt;{Click }+a{here}+{ to continue} --\u0026gt; \u0026lt;p\u0026gt;Click \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; to continue\u0026lt;/p\u0026gt; \u0026lt;!-- p{Click }+a{here}+{ to continue} --\u0026gt; \u0026lt;p\u0026gt;Click\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; to continue Implicit .class1\n\u0026lt;div class=\u0026quot;class1\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; em\u0026gt;.class1\n\u0026lt;em\u0026gt;\u0026lt;span class=\u0026quot;class1\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/em\u0026gt; ul\u0026gt;.class1\n\u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;class1\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; table\u0026gt;.row\u0026gt;.col\n\u0026lt;table\u0026gt; \u0026lt;tr class=\u0026quot;row\u0026quot;\u0026gt; \u0026lt;td class=\u0026quot;col\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Forms \u0026amp; Inputs form:get\n\u0026lt;form action=\u0026quot;\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt;\u0026lt;/form\u0026gt; form:post\n\u0026lt;form action=\u0026quot;\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt;\u0026lt;/form\u0026gt; Lorem lpsum lorem\nlorem20\nul.mylist\u0026gt;lorem4.item*5\n\u0026lt;ul class=\u0026quot;mylist\u0026quot;\u0026gt; \u0026lt;li\u0026gt;Lorem ipsum dolor sit.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Repellendus iusto debitis vel.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Aperiam similique architecto odio!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Exercitationem iusto nesciunt maxime.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Minus reiciendis eaque nemo?\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; p*4\u0026gt;lorem4\n\u0026lt;p\u0026gt;Lorem ipsum dolor sit.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Accusantium odit nostrum modi.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Consequatur soluta voluptatibus amet.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Molestiae quo a asperiores!\u0026lt;/p\u0026gt; Advanced Structures p\u0026gt;{Click }+a{here}+{ to continue}\n\u0026lt;p\u0026gt;Click \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt; to continue\u0026lt;/p\u0026gt; CSS Abbreviations body { /* c#000 */ color: #000; /* c#f */ color: #fff; /* c#f4 */ color: #f4f4f4; /* p10 */ padding: 10px; /* default pixel */ /* p10% or p10p */ padding: 10%; /* p10r */ padding: 10rem; /* pr10 */ padding-right: 10px; /* pl10 pt10 pb10 */ padding-left: 10px; padding-top: 10px; padding-bottom: 10px; /* m20 ml20 mt20 mb20*/ margin: 20px; margin-left: 20px; margin-top: 20px; margin-bottom: 2%; /* t10 b10 db di dib */ top: 10px; bottom: 10px; display: block; display: inline; display: inline-block; /* w300 taj dn df*/ width: 300px; text-align: justify; display: none; display: flex; /* ff ffa fft ffv*/ font-family: serif; /* default font: serif */ font-family: Arial, \u0026#34;Helvetica Neue\u0026#34;, Helvetica, sans-serif; font-family: \u0026#34;Times New Roman\u0026#34;, Times, Baskerville, Georgia, serif; font-family: Verdana, Geneva, sans-serif; /* fwb fw700 fsi fsn fso */ font-weight: bold; font-weight: 700; font-style: italic; font-style: normal; font-style: oblique; /* fz2e */ font-size: 2em; /* pr15+ml10 */ padding-right: 15px; margin-left: 10px; } Custom Snippets 先設定 Emmet Snippets 要存放的目錄 (如: f:\\emmet )\n在該目錄下建立一個名為 snippets.json 檔案，內容如下\n{ \u0026#34;html\u0026#34;: { \u0026#34;snippets\u0026#34;: { \u0026#34;nl\u0026#34;: \u0026#34;nav.main-nav\u0026gt;ul\u0026gt;li.item$*4\u0026#34;, \u0026#34;ull\u0026#34;: \u0026#34;ul\u0026gt;li[id=${1} class=${2}]*2\u0026#34; } }, \u0026#34;css\u0026#34;: { \u0026#34;snippets\u0026#34;: { \u0026#34;cb\u0026#34;: \u0026#34;color: black\u0026#34;, \u0026#34;bsd\u0026#34;: \u0026#34;border: 1px solid ${1:red}\u0026#34; } } } 註:\n ${1} 表示為第一個游標停駐的地方，可直接進行 id 輸入, 當按下 Tab 鍵後，游標會自動停駐在 ${2} 的地方，方便輸入 class name。 ${1:red} 其中的 red 表示是預設值。  存檔後重新啟動 VS Code\n\u0026lt;!-- 在 html 樘中輪入 nl 按下 Tab 鍵 --\u0026gt; \u0026lt;nav class=\u0026quot;main-nav\u0026quot;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;item1\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item2\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item3\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;item4\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;!-- ull --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li id=\u0026quot;\u0026quot; class=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026quot;\u0026quot; class=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; /* cb */ color: black; /* bsd */ border: 1px solid red; ","permalink":"https://calvinegs.github.io/posts/emmet-syntax/","summary":"網頁製作時，手刻 HTML/CSS 即傷神又容易出錯，讓我們來看看 Emmet 如何快速又便捷的協助我們進行 HTML/CSS 的輸入。\nElements 輸入 div 按下 Enter 或 Tab 鍵，輸入 innerHtml - abc 再按下 Ctrl+Enter 鍵\n\u0026lt;div\u0026gt;abc\u0026lt;/div\u0026gt; 輸入 p 按下 Enter 或 Tab 鍵，輸入 innerHtml -abc 再按下 Ctrl+Enter 鍵\n\u0026lt;p\u0026gt;abc\u0026lt;/p\u0026gt; Nesting operators Child: \u0026gt; div\u0026gt;ul\u0026gt;li\n\u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; Sibling: + div+p+bq\n\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; Climb-up: ^ div+div\u0026gt;p\u0026gt;span+em\ndiv+div\u0026gt;p\u0026gt;span+em^bq\ndiv+div\u0026gt;p\u0026gt;span+em^^^bq\n\u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- div+div\u0026gt;p\u0026gt;span+em^bq --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!","title":"透過範例學習 Emmet 語法"},{"content":"使用 Typescript 來開發前端應用程式已是一個趨勢，這篇筆記是用來紀錄如何用 Parcel.js 來建置一個簡潔又有彈性的開發環境用來學習 Typescript。\n使用的工具 \u0026amp; 作業系統  git vscode Mint 20.2 (作業系統)  專案初始化 $ mkdir parcel_ts \u0026amp;\u0026amp; cd parcel_ts # 建立專案目錄 $ npm init -y # 初始化專案目錄 $ touch Startup.ts Employee.ts index.html # 新增三個空白程式檔 $ npm install --save-dev parcel parcel-bundler # 安裝 parcel \u0026amp; parcel-bundler $ code . # 開啟 vs code 在 package.json 中建立執行程式的 script \u0026#34;script\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;parcel index.html\u0026#34; } 使用 Typescript 撰寫程式  Employee.ts\n export class Employee { constructor( private name: string = \u0026#34;no name\u0026#34;, private department: string = \u0026#34;no department\u0026#34; ) {} displayInfo(): string { return `${this.name}department is ${this.department}`; } }  Startup.ts\n import { Employee } from \u0026#34;./Employee\u0026#34;; window.onload = () =\u0026gt; { let information = document.querySelector(\u0026#34;#info\u0026#34;); const employee = new Employee(\u0026#34;Dany Green\u0026#34;, \u0026#34;Market\u0026#34;); if (employee) information.innerHTML = employee.displayInfo(); };  index.html\n \u0026lt;!-- ! : 輸入 \u0026#34;!\u0026#34; 按下 Tab 或 Enter鍵，Emmet 將自動建立 html5 樣版檔案--\u0026gt; \u0026lt;!-- 透過 Tab 鍵可快速跳至 \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;What\u0026#39;s up\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 直接輸入以下 Emmet 語法: div[name=\u0026#34;container\u0026#34;]\u0026gt;h2#info, 即可産生以下 Html div 內容--\u0026gt; \u0026lt;div name=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2 id=\u0026#34;info\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 直接輸入以下 Emmet 語法: script[type=\u0026#34;module\u0026#34; src=\u0026#34;Startup.ts\u0026#34;] , 即可産生以下 Html script 內容--\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;Startup.ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 註: 可參考另一編筆記是紀錄如何使用 Emmet 語法 透過範例學習 Emmet 語法\n執行程式 $ npm run dev \u0026gt; parcel_ts@1.0.0 dev \u0026gt; parcel index.html Server running at http://localhost:1234 ✨ Built in 22ms Typescript 轉譯成 Javascript  程式執行後，可發現在 dist 目錄下，Parcel.js 已經自動的 Typescript 程式轉譯成 Javascript 了。  同時也把 HTML 檔案中的 .ts 自動的轉成 .js 除錯  按下快速鍵 Ctrl+Shift+D 叫出 \u0026ldquo;Run and Debug\u0026rdquo; 功能，點選 create a launch.sjon file   點選 \u0026ldquo;Edge: Launch\u0026rdquo;   自動産生 launch.sjon\n { // Use IntelliSense to learn about possible attributes.  // Hover to view descriptions of existing attributes.  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387  \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;pwa-msedge\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Launch Edge against localhost\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://localhost:8080\u0026#34;, // 8080 改成 1234  \u0026#34;webRoot\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; } ] }  先將 \u0026ldquo;url\u0026rdquo;: \u0026ldquo;http://localhost:8080\u0026rdquo; Port 改成1234,，並在檔案尾部加入以下設定，並存檔。\n \u0026#34;breakOnLoad\u0026#34;: true, \u0026#34;sourceMapPathOverrides\u0026#34;: { \u0026#34;../*\u0026#34;: \u0026#34;${webRoot}/*\u0026#34; }  再次按下快速鍵 Ctrl+Shift+D 叫出 \u0026ldquo;Run and Debug\u0026rdquo; 功能， 下拉選單中選擇 “Launch Edge against localhost\u0026quot;。在 Source code 中設定中斷點，再以滑鼠點選右邊的綠色三角型按鍵，開始進行除錯。VSCode 會自動啟動 edge 瀏覽器，同時程式會暫停在中斷點處。  結論  你會發現透過 Parcel 的幫助，當使用 Typescript 來撰寫 網站程式即方便又快速。\n ","permalink":"https://calvinegs.github.io/posts/parcel-typescript/","summary":"使用 Typescript 來開發前端應用程式已是一個趨勢，這篇筆記是用來紀錄如何用 Parcel.js 來建置一個簡潔又有彈性的開發環境用來學習 Typescript。\n使用的工具 \u0026amp; 作業系統  git vscode Mint 20.2 (作業系統)  專案初始化 $ mkdir parcel_ts \u0026amp;\u0026amp; cd parcel_ts # 建立專案目錄 $ npm init -y # 初始化專案目錄 $ touch Startup.ts Employee.ts index.html # 新增三個空白程式檔 $ npm install --save-dev parcel parcel-bundler # 安裝 parcel \u0026amp; parcel-bundler $ code . # 開啟 vs code 在 package.json 中建立執行程式的 script \u0026#34;script\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;parcel index.html\u0026#34; } 使用 Typescript 撰寫程式  Employee.","title":"使用 Parcel.js + Typescript 來建置一個 Web App"},{"content":"當已有現存的資料庫(此以 Oracle 為例)並且存在有歷史資料，或與其他系統共用資料庫，在這前題下，通常無法隨意的去更改資料庫結構，這時若要採用 Entity Framework 架構就容易遇到資料庫結構正規化的問題。另一種情境是，舊系統使用了非常的SQL語法，要將這些邏輯\u0026quot;翻譯\u0026quot;成合理的 Entity Framework 架構有技術上或時間上的限制時，就會考慮使用 Dapper 這個輕量的 ORM 搭配上 SQL 語法。\n使用 dotnet cli 建立專案 $ dotnet new webapi -o OracleDapperRepository \u0026amp;\u0026amp; cd OracleDapperRepository $ dotnet build $ dotnet run $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; $ dotnet new gitignore $ dotnet add package Dapper --2.0.123 # 加入 Dapper package $ dotnet add package Oracle.ManagedDataAccess.Core --3.21.50 # 加入 連結 Oracle package $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add Dapper \u0026amp; Oracle Data Access NuGet packages\u0026#34; $ cat OracleDapperRepository.csproj 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt;  \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Dapper\u0026#34; Version=\u0026#34;2.0.123\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Oracle.ManagedDataAccess.Core\u0026#34; Version=\u0026#34;3.21.50\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;6.2.3\u0026#34; /\u0026gt;  \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;   Open VS Code 在 appsettings.json 檔案中加入 Connection String\n{ \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;OracleConnection\u0026#34;:\u0026#34;Data Source=192.0.0.1/ORCLCDB;User ID=username;Password=password\u0026#34; }, //... } 在專案目錄結構中建立新資料夾 在專案目錄中新增 Models 和 Repositories 二個目錄，並在 Repositories 目錄下建立一個 Interfaces 子目錄\n在 Models 資料夾中新增 Data Model 使用快捷鍵 Ctrl+N,C 來新增 Model class : Models\\sysmstaf.cs\nnamespace OracleDapperRepository.Models { public class sysmstaf { public string? STAFF_ID { get; set; } public int ROLE_ID { get; set; } public string? PASS_TX { get; set; } public string? LOGIN_TX { get; set; } } } 在 Interfaces 目錄下新增一個 ISysmstafRepository.cs Interface file using OracleDapperRepository.Models; namespace OracleDapperRepository.Repositories.Interfaces { public interface ISysmstafRepository { Task\u0026lt;sysmstaf\u0026gt; GetByStaffID(string staffId); Task\u0026lt;sysmstaf\u0026gt; GetByLoginID(string loginID); Task\u0026lt;IEnumerable\u0026lt;sysmstaf\u0026gt;\u0026gt; GetAllData(); } } 在 Repositories 目錄下新增 SysmstafRepository.cs using System.Data; using Dapper; using Oracle.ManagedDataAccess.Client; using OracleDapperRepository.Models; using OracleDapperRepository.Repositories.Interfaces; namespace OracleDapperRepository.Repositories { public class SysmstafRepository : ISysmstafRepository { private readonly string _connectionString; public SysmstafRepository(string connectionStr) { _connectionString = connectionStr; } public IDbConnection Connection { get { return new OracleConnection(_connectionString); } } public async Task\u0026lt;sysmstaf\u0026gt; GetByLoginID(string loginID) { using (IDbConnection conn = Connection) { string sSQL = \u0026#34;select * from sysmstaf where login_tx= :LOGIN_ID\u0026#34;; return await conn.QueryFirstOrDefaultAsync\u0026lt;sysmstaf\u0026gt;(sSQL, new { LOGIN_ID = loginID }); } } public async Task\u0026lt;sysmstaf\u0026gt; GetByStaffID(string staffId) { using (IDbConnection conn = Connection) { string sSQL = \u0026#34;select * from sysmstaf where staff_id= :STAFF_ID\u0026#34;; return await conn.QueryFirstOrDefaultAsync\u0026lt;sysmstaf\u0026gt;(sSQL, new { STAFF_ID = staffId }); } } public async Task\u0026lt;IEnumerable\u0026lt;sysmstaf\u0026gt;\u0026gt; GetAllData() { using (IDbConnection conn = Connection) { string sSql = \u0026#34;select * from sysmstaf Order by login_tx\u0026#34;; var result = await conn.QueryAsync\u0026lt;sysmstaf\u0026gt;(sSql); return result.ToList(); } } } } 在 Controllers 目錄下新增 SysmstafController.cs using Microsoft.AspNetCore.Mvc; using OracleDapperRepository.Models; using OracleDapperRepository.Repositories.Interfaces; namespace OracleDapperRepository.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class SysmstafController : ControllerBase { private readonly ISysmstafRepository _sysmstafRepo; public SysmstafController(ISysmstafRepository sysmstafRepo) { _sysmstafRepo = sysmstafRepo; } [HttpGet] [Route(\u0026#34;StaffId/{staffId}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;sysmstaf\u0026gt;\u0026gt; GetByStaffID(string staffId) { return await _sysmstafRepo.GetByStaffID(staffId); } [HttpGet] [Route(\u0026#34;LoginId/{loginId}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;sysmstaf\u0026gt;\u0026gt; GetByLoginID(string loginId) { return await _sysmstafRepo.GetByLoginID(loginId); } [HttpGet] [Route(\u0026#34;GetAllData\u0026#34;)] public async Task\u0026lt;IEnumerable\u0026lt;sysmstaf\u0026gt;\u0026gt; GetAllData() { return await _sysmstafRepo.GetAllData(); ; } } } 在 Program.cs 中將 SysmstafRepository 注入 Container 中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  using OracleDapperRepository.Repositories; using OracleDapperRepository.Repositories.Interfaces; var builder = WebApplication.CreateBuilder(args); string ConnectionString = builder.Configuration.GetConnectionString(\u0026#34;OracleConnection\u0026#34;); // 取得 appsettings.json 中的 ConnectionStrings 設定值  // Add services to the container. builder.Services.AddTransient\u0026lt;ISysmstafRepository\u0026gt;(x =\u0026gt; new SysmstafRepository(ConnectionString)); // 將  builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); var app = builder.Build(); // ...   透過 swagger (OpenAPI) 來看結果 github Source code #tag: dapper_oracle\n","permalink":"https://calvinegs.github.io/posts/dotnet6-webapi-oracle-dapper/","summary":"當已有現存的資料庫(此以 Oracle 為例)並且存在有歷史資料，或與其他系統共用資料庫，在這前題下，通常無法隨意的去更改資料庫結構，這時若要採用 Entity Framework 架構就容易遇到資料庫結構正規化的問題。另一種情境是，舊系統使用了非常的SQL語法，要將這些邏輯\u0026quot;翻譯\u0026quot;成合理的 Entity Framework 架構有技術上或時間上的限制時，就會考慮使用 Dapper 這個輕量的 ORM 搭配上 SQL 語法。\n使用 dotnet cli 建立專案 $ dotnet new webapi -o OracleDapperRepository \u0026amp;\u0026amp; cd OracleDapperRepository $ dotnet build $ dotnet run $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; $ dotnet new gitignore $ dotnet add package Dapper --2.0.123 # 加入 Dapper package $ dotnet add package Oracle.ManagedDataAccess.Core --3.21.50 # 加入 連結 Oracle package $ git add .","title":"ASP.NET Core 6 Web API 使用 Dapper ORM 連結 Oracle"},{"content":"   組合鍵 說明     Ctrl+K F Close folder   Ctrl+K Ctrl+O Open folder   Ctrl+R Open Project (透過歷史記錄清單)   Ctrl+Shift+E Explorer / Editor 間的焦點切換   Ctrl+0 Focus Side Bar 將焦點切換至 Side Bar   Ctrl+B 顯示/隠蔵 Side Bar   Ctrl+[1~9] 在 Editor Groups 間焦點切換   Ctrl+Enter 在 新 Group 中打開新指定檔案   Ctrl+\\ 拆分編輯視窗   Ctrl+K Ctrl+\\ 在新 Group 中(在現在 Group 的下方)打開游標在的檔案   Ctrl+F4 or Crtl+W Close Editor   Ctrl+Alt+←→ 在 Groups 間移動檔案   Ctrl+Shift+PgUp/PgDn 在同一個 Group 中移動目前的 editor 到左/右邊   Ctrl+PgDn/PgUp 在 Tabs 間的焦點切換(跨 Groups)   Ctrl+Tab 在同一個 Group 在已開啟的檔案清單中切換(往下)   Ctrl+Shift+Tab 在同一個 Group在已開啟的檔案清單中切換(往上)   Ctrl+K Ctrl+C 註解游標在的這行   Ctrl+Shift+\\ 找到對應的括弧   Ctrl+K Ctrl+U 移除註解 (游標在的這行)   Ctrl+/ 在 \u0026ldquo;註解/移除註解\u0026rdquo; 間切換 (游標在的這行)   Shift+Alt+A 切換區塊註解 (針對被選擇的程式碼)   Shift+Alt+F 將檔案中程式碼格式化   Ctrl+K Ctrl+F 將被選取的程式碼格式化   Ctrl+L 全選整行 (重覆則可往下選擇多行)   Ctrl+X 或 Ctrl+Shift+K 刪除一行   Ctrl + backspace 刪除游標前的字句   Ctrl+K Ctrl+X 刪除行尾的空白字元   Ctrl+, Settings 顯示設定功能   Ctrl+K V 顯示/隱藏 Markdown file 的 Preview 功能   Alt+[1~9] 在Group 中 Tabs 間作焦點切換   Alt+0 移至同一個 Group 中最後一個 editor Tab   Alt+Shift+0 切換 Groups 成為並列或並排   Ctrl+Shift+P Show Command Palette   Ctrl+P Open File   Ctrl+K Ctrl+S Keyboard Shortcuts   Ctrl+K S Save All Files   Ctrl+N New File   Ctrl+K Ctrl+W 關閉所有開啟的檔案   Ctrl+K W 關閉現行 Group   Ctrl+I 顯示系統建議   Ctrl+Shift+T 重新開啟關閉的檔案   Ctrl+K M 切換檔案格式 Change Language Mode   Ctrl+K Enter Keep preview mode editor open (將目前以 Preview 模式開啟的檔案轉換成編輯模式)   Ctrl+K P Copy path of an active file (將目前的檔案目徑含檔名複製到剪貼簿中)   Ctrl+K R Reveal active file in Explorer (將目前的檔案開啟在新的 檔案總管視窗 中)   Ctrl+K O Show active file in a new window/instance (將目前的檔案開啟在新的 vscode 中)   Ctrl+Alt N run code in code runner (屬擴充套件的功能)   Ctrl+= 放大   Ctrl+- 縮小   Ctrl+0 (Num Lock) 恢復原來大小   Ctrl+Shift+L 用你已選擇的字串來標示(選擇)整個檔案中所有符合的文字   Ctrl+F2 不須要先選擇目標字串即可有同上的功能   Shift+Alt+←→ Select until the end of the word   Ctrl+F Find   Ctrl+Shift+O Show Symbol Document Outline   Ctrl+Shift+F File Find   Ctrl+Shift+G Git   Ctrl+Shift+D Debug   Ctrl+Shift+X Extension   Ctrl+Alt+↑↓ Multi line column selection   Ctrl+D Multi Currsor selection   Alt+z 切換斷行功能   Alt+Shift+↓ 複製焦點在的這一行   Alt+↑↓ 移動焦點在的這一行往上/往下   Alt+←→ Go back / forward (往前/後 曾經的操作過程)   Alt+F5 在程式碼比對視窗中，移動到下一個程式碼有變動處   Alt+Shift+F5 在程式碼比對視窗中，移動到上一個程式碼有變動處   F12 Go to Definition (跳至\u0026quot;Function\u0026quot; / \u0026ldquo;變數\u0026rdquo; 定義地方)   Shift+F12 Go to References (檢視 \u0026ldquo;Function\u0026rdquo; / \u0026ldquo;變數\u0026rdquo; 使用的地方)   Ctrl+F12 Go to implementations (跳至\u0026quot;Function\u0026quot; / \u0026ldquo;變數\u0026rdquo; 實現的地方)   Alt+F12 Peek definition (檢視 \u0026ldquo;Function\u0026rdquo; / \u0026ldquo;變數\u0026rdquo; 的出處及定義內容)   Ctrl + ‵ (or Ctrl+J) 切換整合是終端機   Ctrl + shift + ‵ 建立新的整合終端機   Ctrl + shift + c 建立新的終端機 (焦點在 Terminal 時無效)   Ctrl + shift + 5 切割終端機   Alt + ↑↓←→ 切換整合終端機聚焦點   Alt + U 若所在檔案不是 ts 檔，則顯示對應的 ts 檔案。若是 ts 檔，則顯示前一個檔案   Alt + I 若所在檔案不是 css 檔，則顯示對應的 css 檔案。若是 css 檔，則顯示前一個檔案   Alt + O 若所在檔案不是 html 檔，則顯示對應的 html 檔案。若是 html 檔，則顯示前一個檔案   Alt + P 若所在檔案不是 spec.ts 檔，則顯示對應的 spec.ts 檔案。若是 spec.ts 檔，則顯示前一個檔案    註: 後四項是 VSCide Extension angular2-switcher 所支援\n","permalink":"https://calvinegs.github.io/posts/vscod-shortcut/","summary":"組合鍵 說明     Ctrl+K F Close folder   Ctrl+K Ctrl+O Open folder   Ctrl+R Open Project (透過歷史記錄清單)   Ctrl+Shift+E Explorer / Editor 間的焦點切換   Ctrl+0 Focus Side Bar 將焦點切換至 Side Bar   Ctrl+B 顯示/隠蔵 Side Bar   Ctrl+[1~9] 在 Editor Groups 間焦點切換   Ctrl+Enter 在 新 Group 中打開新指定檔案   Ctrl+\\ 拆分編輯視窗   Ctrl+K Ctrl+\\ 在新 Group 中(在現在 Group 的下方)打開游標在的檔案   Ctrl+F4 or Crtl+W Close Editor   Ctrl+Alt+←→ 在 Groups 間移動檔案   Ctrl+Shift+PgUp/PgDn 在同一個 Group 中移動目前的 editor 到左/右邊   Ctrl+PgDn/PgUp 在 Tabs 間的焦點切換(跨 Groups)   Ctrl+Tab 在同一個 Group 在已開啟的檔案清單中切換(往下)   Ctrl+Shift+Tab 在同一個 Group在已開啟的檔案清單中切換(往上)   Ctrl+K Ctrl+C 註解游標在的這行   Ctrl+Shift+\\ 找到對應的括弧   Ctrl+K Ctrl+U 移除註解 (游標在的這行)   Ctrl+/ 在 \u0026ldquo;註解/移除註解\u0026rdquo; 間切換 (游標在的這行)   Shift+Alt+A 切換區塊註解 (針對被選擇的程式碼)   Shift+Alt+F 將檔案中程式碼格式化   Ctrl+K Ctrl+F 將被選取的程式碼格式化   Ctrl+L 全選整行 (重覆則可往下選擇多行)   Ctrl+X 或 Ctrl+Shift+K 刪除一行   Ctrl + backspace 刪除游標前的字句   Ctrl+K Ctrl+X 刪除行尾的空白字元   Ctrl+, Settings 顯示設定功能   Ctrl+K V 顯示/隱藏 Markdown file 的 Preview 功能   Alt+[1~9] 在Group 中 Tabs 間作焦點切換   Alt+0 移至同一個 Group 中最後一個 editor Tab   Alt+Shift+0 切換 Groups 成為並列或並排   Ctrl+Shift+P Show Command Palette   Ctrl+P Open File   Ctrl+K Ctrl+S Keyboard Shortcuts   Ctrl+K S Save All Files   Ctrl+N New File   Ctrl+K Ctrl+W 關閉所有開啟的檔案   Ctrl+K W 關閉現行 Group   Ctrl+I 顯示系統建議   Ctrl+Shift+T 重新開啟關閉的檔案   Ctrl+K M 切換檔案格式 Change Language Mode   Ctrl+K Enter Keep preview mode editor open (將目前以 Preview 模式開啟的檔案轉換成編輯模式)   Ctrl+K P Copy path of an active file (將目前的檔案目徑含檔名複製到剪貼簿中)   Ctrl+K R Reveal active file in Explorer (將目前的檔案開啟在新的 檔案總管視窗 中)   Ctrl+K O Show active file in a new window/instance (將目前的檔案開啟在新的 vscode 中)   Ctrl+Alt N run code in code runner (屬擴充套件的功能)   Ctrl+= 放大   Ctrl+- 縮小   Ctrl+0 (Num Lock) 恢復原來大小   Ctrl+Shift+L 用你已選擇的字串來標示(選擇)整個檔案中所有符合的文字   Ctrl+F2 不須要先選擇目標字串即可有同上的功能   Shift+Alt+←→ Select until the end of the word   Ctrl+F Find   Ctrl+Shift+O Show Symbol Document Outline   Ctrl+Shift+F File Find   Ctrl+Shift+G Git   Ctrl+Shift+D Debug   Ctrl+Shift+X Extension   Ctrl+Alt+↑↓ Multi line column selection   Ctrl+D Multi Currsor selection   Alt+z 切換斷行功能   Alt+Shift+↓ 複製焦點在的這一行   Alt+↑↓ 移動焦點在的這一行往上/往下   Alt+←→ Go back / forward (往前/後 曾經的操作過程)   Alt+F5 在程式碼比對視窗中，移動到下一個程式碼有變動處   Alt+Shift+F5 在程式碼比對視窗中，移動到上一個程式碼有變動處   F12 Go to Definition (跳至\u0026quot;Function\u0026quot; / \u0026ldquo;變數\u0026rdquo; 定義地方)   Shift+F12 Go to References (檢視 \u0026ldquo;Function\u0026rdquo; / \u0026ldquo;變數\u0026rdquo; 使用的地方)   Ctrl+F12 Go to implementations (跳至\u0026quot;Function\u0026quot; / \u0026ldquo;變數\u0026rdquo; 實現的地方)   Alt+F12 Peek definition (檢視 \u0026ldquo;Function\u0026rdquo; / \u0026ldquo;變數\u0026rdquo; 的出處及定義內容)   Ctrl + ‵ (or Ctrl+J) 切換整合是終端機   Ctrl + shift + ‵ 建立新的整合終端機   Ctrl + shift + c 建立新的終端機 (焦點在 Terminal 時無效)   Ctrl + shift + 5 切割終端機   Alt + ↑↓←→ 切換整合終端機聚焦點   Alt + U 若所在檔案不是 ts 檔，則顯示對應的 ts 檔案。若是 ts 檔，則顯示前一個檔案   Alt + I 若所在檔案不是 css 檔，則顯示對應的 css 檔案。若是 css 檔，則顯示前一個檔案   Alt + O 若所在檔案不是 html 檔，則顯示對應的 html 檔案。若是 html 檔，則顯示前一個檔案   Alt + P 若所在檔案不是 spec.","title":"VS Code 中常用快捷鍵"},{"content":"在另一篇筆記中 ASP.NET Core 5 Web API - 從無到有 已經了解如何從無到有 使用 Dotnet core 5.0 建立 一個 Web API，本篇筆記將以此有基礎來記錄如何使用 Asp.Net Core Identity framework 及 JWT 來建置一個簡單又安全的 \u0026ldquo;使用者權限管理\u0026quot;功能。\ngithub Source code #tag: identity_jwt\n使用 Asp.Net Core Identity framework 來管理使用者使用權限 ASP.NET Core Identity:\n 支援使用者介面 (UI) 登入功能的 API。 管理使用者、密碼、設定檔資料、角色、宣告、權杖、電子郵件確認等。  ASP.Net Core Identity Framework 是一個很方便且還算完善的使用權限管理架構。\n安裝給 AspNetCore Idendity Framework 使用的相關套件 $ dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore --version 5.0.13 $ dotnet add package Microsoft.AspNetCore.Identity.UI --version 5.0.13 除了安裝相關套件外，還要調整相關程式:\n 在 Startup.cs 檔案中將 AspNetCore Identity Service 注入到 container 中 (before services.AddControllers())  # 在 startup.cs 檔案中 services.AddControllers() 指令前加入以下指令 services.AddDefaultIdentity\u0026lt;IdentityUser\u0026gt;(options =\u0026gt; options.SignIn.RequireConfirmedAccount = true) .AddEntityFrameworkStores\u0026lt;ApiDbContext\u0026gt;();  在 Startup.cs 檔案中 HTTP request pipeline 中 新加入 UseAuthentication()  # 在 startup.cs 檔案中 app.UseAuthorization() 指令前加入以下指令 app.UseAuthentication();  使用 AspNetCore Identity，則 DataContext (ApiDbContext.cs 中) 必須要繼承 IdentityDbContext， 同時 Model creationg 時要改成呼叫 base.OnModelCreation  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public partial class ApiDbContext : IdentityDbContext { public DbSet\u0026lt;ItemData\u0026gt; ItemData { get; set; }  public ApiDbContext() { } // ...  protected override void OnModelCreating(ModelBuilder modelBuilder) { // OnModelCreatingPartial(modelBuilder);  base.OnModelCreating(modelBuilder);  } }   新增一個 entity framework 遷移 並 更新資料庫 完成上述程式調整後，來執行資料庫遷移(migrations)\n$ dotnet build $ dotnet ef migrations add \u0026#34;Add Identity Framework\u0026#34; $ dotnet ef database update (app.db 產生 Identity Framework 會使用到的資料表) 新增 使用者註冊和登入時使用的 Data model class (Models/AuthData.cs) using System.Collections.Generic; using System.ComponentModel.DataAnnotations; namespace Todo5.Models { public class RegistrationResponse { public string Token { get; set; } public bool Success { get; set; } public List\u0026lt;string\u0026gt; Errors { get; set; } } public class UserLoginRequest { [Required] [EmailAddress] public string Email { get; set; } [Required] public string Password { get; set; } } public class UserRegistrationDto { [Required] public string Username { get; set; } [Required] [EmailAddress] public string Email { get; set; } [Required] public string Password { get; set; } } } 新增 註冊和登入邏輯 (Controllers/AuthManagementControll.cs) using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Identity; using Microsoft.AspNetCore.Mvc; using Todo5.Models; namespace Todo5.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] // api/authManagement [ApiController] public class AuthManagementController : ControllerBase { private readonly UserManager\u0026lt;IdentityUser\u0026gt; _userManager; public AuthManagementController( UserManager\u0026lt;IdentityUser\u0026gt; userManager) { _userManager = userManager; } [HttpPost] [Route(\u0026#34;Register\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Register([FromBody] UserRegistrationDto user) { if (ModelState.IsValid) { // We can utilise the model  var existingUser = await _userManager.FindByEmailAsync(user.Email); if (existingUser != null) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Email already in use\u0026#34; }, Success = false }); } var newUser = new IdentityUser() { Email = user.Email, UserName = user.Username }; var isCreated = await _userManager.CreateAsync(newUser, user.Password); if (isCreated.Succeeded) { return Ok(new RegistrationResponse() { Success = true, }); } else { return BadRequest(new RegistrationResponse() { Errors = isCreated.Errors.Select(x =\u0026gt; x.Description).ToList(), Success = false }); } } return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid payload\u0026#34; }, Success = false }); } [HttpPost] [Route(\u0026#34;Login\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Login([FromBody] UserLoginRequest user) { if (ModelState.IsValid) { var existingUser = await _userManager.FindByEmailAsync(user.Email); if (existingUser == null) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid login request\u0026#34; }, Success = false }); } var isCorrect = await _userManager.CheckPasswordAsync(existingUser, user.Password); if (!isCorrect) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid login request\u0026#34; }, Success = false }); } return Ok(new RegistrationResponse() { Success = true, }); } return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid payload\u0026#34; }, Success = false }); } } } 使用者帳號註冊 註冊成功 使用已註冊成功帳號來進行登入 建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add Asp.Net Core Identity framework\u0026#34; 新增 JWT 功能 到目前為止我們已透過 Dotnet Core Identity framework 完成了簡易的使用者資料驗證的功能(註冊/登入)，下面要繼續完成採用 JWT 進行 Token-based 的身分驗證與授權實作。\nJWT(Json Web Token)是一個實現授權功能上相對簡單又安全方式。實作的步驟包含了三個部分：\n 產生合法有效的 JWT Token 驗證合法有效的 JWT Token 限制特定 API 只能在通過 JWT 驗證的 HTTP 要求才能存取  首先，先加入相關套件:\n$ dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 5.0.13 $ dotnet add package Microsoft.IdentityModel.Tokens --version 6.11.1 產生合法有效的 JWT Token  在前述的　Controller 程式(Controllers/AuthManagementControll.cs)中加入 GenerateJwtToken Function\n private string GenerateJwtToken(IdentityUser user) { var key = Encoding.ASCII.GetBytes(_appSettings.Secret); var claims = new ClaimsIdentity(new [] { new Claim(\u0026#34;Id\u0026#34;, user.Id), new Claim(JwtRegisteredClaimNames.Email, user.Email), new Claim(JwtRegisteredClaimNames.Sub, user.Email), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }); var tokenDescriptor = new SecurityTokenDescriptor { Subject = claims, Expires = DateTime.UtcNow.AddHours(6), SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature) }; var jwtTokenHandler = new JwtSecurityTokenHandler(); var token = jwtTokenHandler.CreateToken(tokenDescriptor); var jwtToken = jwtTokenHandler.WriteToken(token); return jwtToken; }  並在 Login \u0026amp; Register function 中去呼叫　GenerateJwtToken function，並回傳 Token ()\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100  [HttpPost] [Route(\u0026#34;Register\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Register([FromBody] UserRegistrationDto user) { if (ModelState.IsValid) { // We can utilise the model  var existingUser = await _userManager.FindByEmailAsync(user.Email); if (existingUser != null) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Email already in use\u0026#34; }, Success = false }); } var newUser = new IdentityUser() { Email = user.Email, UserName = user.Username }; var isCreated = await _userManager.CreateAsync(newUser, user.Password); if (isCreated.Succeeded) { var jwtToken = GenerateJwtToken(newUser);  return Ok(new RegistrationResponse() { Success = true, Token = jwtToken  }); } else { return BadRequest(new RegistrationResponse() { Errors = isCreated.Errors.Select(x =\u0026gt; x.Description).ToList(), Success = false }); } } return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid payload\u0026#34; }, Success = false }); } [HttpPost] [Route(\u0026#34;Login\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Login([FromBody] UserLoginRequest user) { if (ModelState.IsValid) { var existingUser = await _userManager.FindByEmailAsync(user.Email); if (existingUser == null) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid login request\u0026#34; }, Success = false }); } var isCorrect = await _userManager.CheckPasswordAsync(existingUser, user.Password); if (!isCorrect) { return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid login request\u0026#34; }, Success = false }); } var jwtToken = GenerateJwtToken(existingUser);  return Ok(new RegistrationResponse() { Success = true, Token = jwtToken  }); } return BadRequest(new RegistrationResponse() { Errors = new List\u0026lt;string\u0026gt;() { \u0026#34;Invalid payload\u0026#34; }, Success = false }); }   驗證合法有效的 JWT Token 先在 Helpers 目錄下新增 AppSettings Class 用來存放 JWT 使用到的 Key\nnamespace Todo5.Helpers { public class AppSettings { public string Secret { get; set; } } } 並在 appsettings.json 設定檔中加入 Secret 值:\n{ \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;DefaultConnection\u0026#34;: \u0026#34;Data Source=app.db; Cache=Shared\u0026#34; }, \u0026#34;AppSettings\u0026#34;: { \u0026#34;Secret\u0026#34;: \u0026#34;This is a test for Authorization in asp.net webapi. Using JWT Technology to keep user info.\u0026#34; }, \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } 再到 Startup.cs 檔案中注入 \u0026ldquo;驗證合法有效 JWT Token 的功能\u0026rdquo;\n// 開始: 為 JWT 新增的程式碼 services.Configure\u0026lt;AppSettings\u0026gt;(Configuration.GetSection(\u0026#34;AppSettings\u0026#34;)); var key = Encoding.ASCII.GetBytes(Configuration[\u0026#34;AppSettings:Secret\u0026#34;]); var TokenValidationParameters = new TokenValidationParameters { ValidateIssuerSigningKey = true, // this will validate the 3rd part of the jwt token using the secret that we added in the appsettings and verify we have generated the jwt token  IssuerSigningKey = new SymmetricSecurityKey(key), // Add the secret key to our Jwt encryption  ValidateIssuer = false, ValidateAudience = false, ValidateLifetime = true, RequireExpirationTime = false, }; services .AddAuthentication(options =\u0026gt; { options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; }) .AddJwtBearer(cfg =\u0026gt; { cfg.RequireHttpsMetadata = false; cfg.TokenValidationParameters = TokenValidationParameters; }); // 結束: 為 JWT 新增的程式碼 限制特定 API 只能在通過 JWT 驗證的 HTTP 要求才能存取 在欲限制的功能(function in Controller)前加入 \u0026ldquo;[Authorize]\u0026rdquo; 屬性 (TodoController.cs 程式中)\n// GET: api/Todo [HttpGet] [Authorize] # 加入屬性 public async Task\u0026lt;ActionResult\u0026lt;IEnumerable\u0026lt;ItemData\u0026gt;\u0026gt;\u0026gt; GetItemData() { return await _context.ItemData.ToListAsync(); } 為 Swagger 加入 JWT 功能 程式到此已完成加入 JWT 功能，下面是為了使用 Swagger 進行 API 測試時，可以有 JWT 相關功能而調整的部份\n// 註解掉原有程式碼 (以下三行) // services.AddSwaggerGen(c =\u0026gt; // { // c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;Todo5\u0026#34;, Version = \u0026#34;v1\u0026#34; }); // });  // 改成下面的程式，讓 Swagger 具備有 JWT 的相關功能 services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;TodoApp\u0026#34;, Version = \u0026#34;v1\u0026#34; }); c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { In = ParameterLocation.Header, Description = \u0026#34;Please enter JWT with Bearer into field\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, Type = SecuritySchemeType.ApiKey }); c.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} }, new string[] {} } }); }); 在 Swagger 的 UI 中，畫面右上角多出了 \u0026ldquo;Authorize\u0026rdquo; 按鈕。此功能是用來記錄 登入成功後所回傳的 Token\n此刻 API 已要求要擕帶有合法 Token，若在未透過\u0026quot;Authorize\u0026quot;功能填入 Token 時來操作 API，將會回傳\u0026quot;未授權\u0026quot;的錯誤。如下圖: 先以合法使用者帳號登入，在登入成功後，回傳的 Response body 中會帶有 Token，將此 Token 值複製下來 按下 Authorize 按鈕後，填入該 Token 值，並在 Token 值前鍵入 \u0026ldquo;bearer \u0026quot; 再次操作 Get API，即可成功取得回傳值。 ","permalink":"https://calvinegs.github.io/posts/dotnet5-webapi-ii/","summary":"在另一篇筆記中 ASP.NET Core 5 Web API - 從無到有 已經了解如何從無到有 使用 Dotnet core 5.0 建立 一個 Web API，本篇筆記將以此有基礎來記錄如何使用 Asp.Net Core Identity framework 及 JWT 來建置一個簡單又安全的 \u0026ldquo;使用者權限管理\u0026quot;功能。\ngithub Source code #tag: identity_jwt\n使用 Asp.Net Core Identity framework 來管理使用者使用權限 ASP.NET Core Identity:\n 支援使用者介面 (UI) 登入功能的 API。 管理使用者、密碼、設定檔資料、角色、宣告、權杖、電子郵件確認等。  ASP.Net Core Identity Framework 是一個很方便且還算完善的使用權限管理架構。\n安裝給 AspNetCore Idendity Framework 使用的相關套件 $ dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore --version 5.0.13 $ dotnet add package Microsoft.AspNetCore.Identity.UI --version 5.0.13 除了安裝相關套件外，還要調整相關程式:","title":"ASP.NET Core 5 Web API 加入權限管理 (Dotnet Core Identity Framework + JWT)"},{"content":"在此要討論的是有關 TypeScript 的 型別推論(type inference) 與 型別註記(type annotation)\n關於 Javascript 的型別 Javascript 是個動態型別的語言，也就是說擁有 \u0026lsquo;型別\u0026rsquo; 的是 \u0026lsquo;值\u0026rsquo; 而不是變數。\nlet myVar; console.log(`${myVar}: ${typeof myVar}`); // undefined : undefined myVar = 20; console.log(`${myVar}: ${typeof myVar}`); // 20 : number myVar = \u0026#34;Hi\u0026#34;; console.log(`${myVar}: ${typeof myVar}`); // Hi : string myVar = true; console.log(`${myVar}: ${typeof myVar}`); // true : boolean Type Annotation (型別註記) TypeScript 提供靜型別功能，讓我們可以明確指定變數的型別。編譯器在轉譯過程即可偵測到使用不同型別時主動抛出錯誤訊息。下面的例子就是使用型別註記來定義靜態型別:\nfunction calculateTax(amount: number): number { return amount * 1.2; } console.log(`${20}: ${calculateTax(20)}`); //20: 24 console.log(`${\u0026#34;Hello\u0026#34;}: ${calculateTax(\u0026#34;Hello\u0026#34;)}`); //error console.log(`${true}: ${calculateTax(true)}`); //error Type inference (型別推論) TypeScript 編譯器可以根據變數宣告時給定的值來推論它的型別。\nfunction calculateTax(amount: number): number { return amount * 1.2; } let price = 100; //未給定資料型別，由給定的值推論此時的 price 變數型別為 number let taxAmount = calculateTax(price); //未給定資料型別，由回傳值推論此時的變數型別為 number，因為 calculateTax 型別註記為 number let halfShare = taxAmount / 2; //未給定資料型別，由計算結果值推論此時的變數型別為 number console.log(`Full amount in tax: ${taxAmount}`); //Full amount in tax: 120 console.log(`Half share: ${halfShare}`); //Half share: 60 調整 tsc 編輯參數來查看編譯器所採用的型別 tsc 編譯器推論的型別若與預期的有出入，可以在 tscconfig.json \u0026ldquo;compilerOptions\u0026quot;中加入一條\u0026quot;declaration\u0026rdquo;: true 的設定值\n{ \u0026quot;compilerOptions\u0026quot;: { \u0026quot;target\u0026quot;: \u0026quot;es2020\u0026quot;, \u0026quot;outDir\u0026quot;: \u0026quot;./dist\u0026quot;, \u0026quot;rootDir\u0026quot;: \u0026quot;./src\u0026quot;, \u0026quot;declaration\u0026quot;: true } } 上述範例改成:\nfunction calculateTax(amount: number) { return (amount * 1.2).toFixed(2); } let price = 100; //未給定資料型別，由給定的值推論此時的 price 變數型別為 number let taxAmount = calculateTax(price); //未給定資料型別，由回傳值推論此時的變數型別為 string，因為 calculateTax function toFixed(2) 結果是 string let halfShare = taxAmount / 2; // 產生錯誤 console.log(`Full amount in tax: ${taxAmount}`); //Full amount in tax: 120 console.log(`Half share: ${halfShare}`); //Half share: 60 由於 toFixed(2) 回傳的是 string，導致 taxAmount 變數型別被推論成 string 而產生錯誤警告。 tsc 因為在 tscconfig.json 多加入了編輯參數 \u0026ldquo;declaration\u0026rdquo;: true，這個參數告訴編譯器，除了輸出程式碼轉譯外，還要輸芔包含型別宣告資訊的 .d.ts 檔，所以會在 build 目錄中產生一個 index.d.js，內容如下圖，可以看到 taxAmount 被推論成 string\ndeclare function calculateTax(amount: number): string; declare let price: number; declare let taxAmount: string; declare let halfShare: number; 關於 Any 的型別推論 將範例改成如下圖，calculateTax 回傳值及傳入參數皆註記成為 any\nfunction calculateTax(amount: any): any { return (amount * 1.2).toFixed(2); } let price = 100; //未給定資料型別，由給定的值推論此時的 price 變數型別為 number let taxAmount = calculateTax(price); //由於 calcaulateTax 型別註記為 any，故被推論成 any let halfShare = taxAmount / 2; // 未給定資料型別，(any / 2) 計算結果會被推論成 number console.log(`Full amount in tax: ${taxAmount}`); //Full amount in tax: 120.00 console.log(`Half share: ${halfShare}`); //Half share: 60 結果發現在 index.d.js 檔中 taxAmount 也被推論成 any，且編譯結果正常。\ndeclare function calculateTax(amount: any): any; declare let price: number; declare let taxAmount: any; declare let halfShare: number; 但這樣的使用 any 型別，你會發現這和寫 javascript 程式碼無任何差別，也就是說你讓程式自行承擔結東，而沒有用到 TypeScript 靜態型別的好處(編譯時期即可檢查出程式可能出問題的地方)。\n我們來測試一下，將 calculateTax function 改成如下:\nfunction calculateTax(amount: any): any { return `$${(amount * 1.2).toFixed(2)}`; } 再執行看看，發現編譯程式時正常，確在執行時期產生非預期結果\nFull amount in tax: $120.00 Half share: NaN 結論就是你應該儘可能的不要有 any 這樣的型別註記。\nContextual Typing (依照背景來進行的型態推論) TypeScript 使用變量的位置來推斷它們的類型，這就是所謂的 contextual typing\ndocument.addEventListener(\u0026#34;click\u0026#34;, function (event) { console.log(event.button); // }); 在這個例子中，TypeScript 因為 click 事件而知道 event 參數是 MouseEvent 的一個實例。\ndocument.addEventListener(\u0026#34;scroll\u0026#34;, function (event) { console.log(event.button); // compiler error }); 而在這個例子中，因為是 \u0026lsquo;scroll\u0026rsquo; 事件，所以參數中不能是 button，因此轉譯時會產生錯誤。\nwindow.onmousedown = function(mouseEvent) { console.log(mouseEvent.button); //\u0026lt;- OK  console.log(mouseEvent.kangaroo); //\u0026lt;- Error! }; Typescript 型別檢查器使用 Window.onmousedown 函數的型別來推斷賦值右邊的函數運算式的型別。因此，它能夠推斷出 mouseEvent 參數的型別，它確實包含一個按鈕屬性，但不包含袋鼠屬性。\n","permalink":"https://calvinegs.github.io/posts/ts-type-inferenc-annotation/","summary":"在此要討論的是有關 TypeScript 的 型別推論(type inference) 與 型別註記(type annotation)\n關於 Javascript 的型別 Javascript 是個動態型別的語言，也就是說擁有 \u0026lsquo;型別\u0026rsquo; 的是 \u0026lsquo;值\u0026rsquo; 而不是變數。\nlet myVar; console.log(`${myVar}: ${typeof myVar}`); // undefined : undefined myVar = 20; console.log(`${myVar}: ${typeof myVar}`); // 20 : number myVar = \u0026#34;Hi\u0026#34;; console.log(`${myVar}: ${typeof myVar}`); // Hi : string myVar = true; console.log(`${myVar}: ${typeof myVar}`); // true : boolean Type Annotation (型別註記) TypeScript 提供靜型別功能，讓我們可以明確指定變數的型別。編譯器在轉譯過程即可偵測到使用不同型別時主動抛出錯誤訊息。下面的例子就是使用型別註記來定義靜態型別:\nfunction calculateTax(amount: number): number { return amount * 1.2; } console.","title":"型別推論(type inference) 與 型別註記(type annotation)"},{"content":"github Source code #tag: web_api\n本文將記錄如何一步步從無到有使用 Dotnet Core 5.0 建立 ASP.NET Core 5 Web API，其中將會使用到下列技術:\n Dotnet cli Entity Framework Sqlite ASP.NET Core Generator  使用 dotnet cli 建立專案 $ dotnet --version # 檢查 dotnet 版本，目前版本為: 5.0.201 $ dotnet new webapi -n \u0026#34;Todo5\u0026#34; \u0026amp;\u0026amp; cd \u0026#34;Todo5\u0026#34; $ ls # 查看 專案檔案結構 $ dotnet new gitignore # 使用 dotnet cli 來產生預設的 git ignore 檔案 建立 git 初始版本 $ git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Initial commit\u0026#34; 安裝本機工具 此方式安裝的工具，僅限本機存取(只針對目前的目錄和子目錄)， 首先透過 dotnet new tool-manifest 命令來產生工具資訊清單檔，再使用 dotnet tool install 來安裝各式工具程式。這樣的方式好處是在專案若多人協助方式時，則可利用 dotnet tool restore 命令將紀錄在 .config/dotnet-tools.json 的工具資訊清單檔重建在不同協助人員的電腦中。\n$ dotnet new tool-manifest #會產生 .config/dotnet-tools.json 檔案 $ dotnet tool install dotnet-ef --version 5.0.13 #使用 local 安裝方式來安裝 Entity Framework 工具 $ dotnet tool install dotnet-aspnet-codegenerator --version 5.0.2 #使用 local 安裝方式來安裝 Code Generator 工具 $ cat .\\.config\\dotnet-tools.json # 查看安裝上述二項工具後的設定資訊 1 2 3 4 5 6 7 8 9 10 11 12 13 14  { \u0026#34;version\u0026#34;: 1, \u0026#34;isRoot\u0026#34;: true, \u0026#34;tools\u0026#34;: { \u0026#34;dotnet-ef\u0026#34;: {  \u0026#34;version\u0026#34;: \u0026#34;5.0.13\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-ef\u0026#34;] }, \u0026#34;dotnet-aspnet-codegenerator\u0026#34;: {  \u0026#34;version\u0026#34;: \u0026#34;5.0.2\u0026#34;, \u0026#34;commands\u0026#34;: [\u0026#34;dotnet-aspnet-codegenerator\u0026#34;] } } }   安裝程式使用的相關套件 $ dotnet add package Microsoft.EntityFrameworkCore.Sqlite --version 5.0.13 #Sqlite 使用的套件 $ dotnet add package Microsoft.EntityFrameworkCore.Tools --version 5.0.13 #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.Design --version 5.0.13 #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 5.0.13 #使用 dotnet Entity Framework時必須安裝此套件 $ dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 5.0.2 #搭配 dotnet-aspnet-codegenerator 使用 安裝的程式套件資訊紀錄在 \u0026ldquo;專案\u0026rdquo;.csproj 檔案中\n$ cat .\\Todo5.csproj #查看 安裝套件的相關設定值 1\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; 2 3 \u0026lt;PropertyGroup\u0026gt; 4 \u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; 5 \u0026lt;RootNamespace\u0026gt;_5Todo\u0026lt;/RootNamespace\u0026gt; 6 \u0026lt;/PropertyGroup\u0026gt; 7 8 \u0026lt;ItemGroup\u0026gt; 9 \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Design\u0026#34; Version=\u0026#34;5.0.13\u0026#34;\u0026gt; 10 \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; 11 \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; 12 \u0026lt;/PackageReference\u0026gt; 13 \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Sqlite\u0026#34; Version=\u0026#34;5.0.13\u0026#34; /\u0026gt; 14 \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.SqlServer\u0026#34; Version=\u0026#34;5.0.13\u0026#34; /\u0026gt; 15 \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;5.0.13\u0026#34;\u0026gt; 16 \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; 17 \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; 18 \u0026lt;/PackageReference\u0026gt; 19 \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;5.0.2\u0026#34; /\u0026gt; 20 \u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;5.6.3\u0026#34; /\u0026gt; 21 \u0026lt;/ItemGroup\u0026gt; 22 23\u0026lt;/Project\u0026gt; 建立 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Add EFCore NuGet packages\u0026#34; 新增 database context (自動產生) $ dotnet ef dbcontext scaffold \u0026#34;Data Source=app.db; Cache=Shared\u0026#34; Microsoft.EntityFrameworkCore.Sqlite -c ApiDbContext -o Data #在專案目錄 ./Data 子目錄下新建立一個 ApiDbContext.cs 的 DB Context file $ dotnet run #可使用 dotnet watch run 命令來自動監控程式碼的變動 開啟瀏覽器查看以下網址 \u0026ldquo;https://localhost:5001/WeatherForecast\u0026rdquo; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  [ { \u0026#34;date\u0026#34;: \u0026#34;2022-01-11T11:44:43.1899069+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: -6, \u0026#34;temperatureF\u0026#34;: 22, \u0026#34;summary\u0026#34;: \u0026#34;Hot\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-12T11:44:43.190114+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 28, \u0026#34;temperatureF\u0026#34;: 82, \u0026#34;summary\u0026#34;: \u0026#34;Balmy\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-13T11:44:43.1901167+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 23, \u0026#34;temperatureF\u0026#34;: 73, \u0026#34;summary\u0026#34;: \u0026#34;Hot\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-14T11:44:43.1901169+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 42, \u0026#34;temperatureF\u0026#34;: 107, \u0026#34;summary\u0026#34;: \u0026#34;Warm\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2022-01-15T11:44:43.1901171+08:00\u0026#34;, \u0026#34;temperatureC\u0026#34;: 22, \u0026#34;temperatureF\u0026#34;: 71, \u0026#34;summary\u0026#34;: \u0026#34;Cool\u0026#34; } ]   開啟瀏覽器查看以下 Swagger 網址 \u0026ldquo;https://localhst:5001/swagger/index.html\u0026rdquo; 建立另一個 git 新版本 $ git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Create dbcontext classes using dotnet-ef\u0026#34; Open VS Code $ Code . 在 Models 目錄下新增一個 model(模型) class - ItemData 1 2 3 4 5 6 7 8 9 10  namespace Todo5.Models { public class ItemData { public int Id { get; set; } public string Title { get; set; } public string Details { get; set; } public bool Done { get; set; } } }   在 ApiDbContext.cs 中宣告一個 ItemData table public DbSet\u0026lt;ItemData\u0026gt; ItemDatas { get; set; }\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  using System; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata; using Todo5.Models; #nullable disable namespace Todo5.Data { public partial class ApiDbContext : DbContext { public DbSet\u0026lt;ItemData\u0026gt; ItemDatas { get; set; }  public ApiDbContext() { } //...  } }   在 appsettings.json 檔案中新增 ConnectionString 設定資料 \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;DefaultConnection\u0026#34;: \u0026#34;Data Source=app.db;Cache=Shared\u0026#34; }, 在 Startup.cs 檔案中註冊 database context (連絡到 Sqlite DB) 15 16 17 18 19  services.AddDbContext\u0026lt;ApiDbContext\u0026gt;(options =\u0026gt; options.UseSqlite( Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;)  ) );   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  namespace TodoApp { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } // This method gets called by the runtime. Use this method to add services to the container.  public void ConfigureServices(IServiceCollection services) { services.AddDbContext\u0026lt;ApiDbContext\u0026gt;(options =\u0026gt; options.UseSqlite( Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;)  ) ); services.AddControllers(); // ...  } }; }   移除預設產生的樣本程式碼 Weather Forecast 程式碼是預設自動產生的，可直接將 WeatherForecast.cs \u0026amp; WeatherForecastController.cs 刪除\nAdd the initial migration to create the database $ dotnet build $ dotnet ef migrations add \u0026#34;Initial Migrations\u0026#34; $ dotnet ef database update # 在根目錄產生 app.db sqlite database 使用 ASPNET Codegenerator 自動產生 Todo Controller $ dotnet aspnet-codegenerator controller -name TodoController -async -api -m ItemData -dc ApiDbContext -outDir Controllers 執行 Swagger 開啟瀏覽器查看以下網址 \u0026ldquo;https://localhst:5001/swagger/index.html\u0026rdquo;\n透過 POST Method 新增一筆資料\n使用 GET Method 查詢資料 ","permalink":"https://calvinegs.github.io/posts/dotnet5-webapi/","summary":"github Source code #tag: web_api\n本文將記錄如何一步步從無到有使用 Dotnet Core 5.0 建立 ASP.NET Core 5 Web API，其中將會使用到下列技術:\n Dotnet cli Entity Framework Sqlite ASP.NET Core Generator  使用 dotnet cli 建立專案 $ dotnet --version # 檢查 dotnet 版本，目前版本為: 5.0.201 $ dotnet new webapi -n \u0026#34;Todo5\u0026#34; \u0026amp;\u0026amp; cd \u0026#34;Todo5\u0026#34; $ ls # 查看 專案檔案結構 $ dotnet new gitignore # 使用 dotnet cli 來產生預設的 git ignore 檔案 建立 git 初始版本 $ git init \u0026amp;\u0026amp; git add .","title":"ASP.NET Core 5 Web API - 從無到有"},{"content":"Angular 的版本更新迭代的相當快 (所有的前端開於工具都有相同的情形)，安裝及使用 Angular Cli 時必須在有 Node.js 的環境下才能進行。\n當你在同一台電腦中使用不同版本的 Angular 時就容易在安裝相關套件時遇到警語，原因常是因為 Angular 與 Node.js 版本搭配的關係。\n至於為何有同時使用不同版本的 Angular 呢? 除了開發的專案沒有全部都一起升級至統一版本(這是一件複雜的事)的因素外，個人最常遇到的狀況是: 當在網上(github)找到很棒的 Demo / Sample 程式，在 git clone 回電腦後發現它的版本是舊版本 Angular 所撰寫，使用 npm install 安裝相關套件時，出現警告訊息，甚至無法安裝成功。\n為了要管理同一台電腦中存在著有不同版 Node.js，讓你很容易在各版本中自由的進行切換 (甚至在進入不同目錄時自動切換對應的 Node.js 版本)，你需要 Node.js 版本管理工具，如: NVM 或 NVS，在這個筆記中要記錄的是 NVS。\n安裝 nvs F:\\\u0026gt; choco list nvs #先查看是否已安裝了 nvs F:\\\u0026gt; choco install nvs #安裝 nvs F:\\\u0026gt; nvs --version #查看是否安裝成功，並顯示 nvs 版本  註：安裝完成後若遇到在 cmd 中可正常執行，但在Windows PowerShell 無法使用時，可使用‘系統管理員’身份開啟 Posershell，並執行 PS\u0026gt;Set-ExecutionPolicy RemoteSigned 應可解決這個問題。\n 安裝不同版本 Node.js 以個人工作環境為例，目前使用的 Angular 是 13.0 搭配的 Node.js 版本是 V16.10.0。\n當我需要參考其他範例時，如在 github 找到一個範例程式，git clone 後，查看該專案發現它撰寫時使用 Angular 8.2.0 這個版本\nPS F:\\test\\angular-forms-workshop\u0026gt; cat package.json\n{ \u0026#34;name\u0026#34;: \u0026#34;angular-forms-workshop\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34; }, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;@angular/animations\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@ng-bootstrap/ng-bootstrap\u0026#34;: \u0026#34;^5.1.0\u0026#34;, \u0026#34;@ng-dynamic-forms/core\u0026#34;: \u0026#34;^9.0.1\u0026#34;, \u0026#34;@ng-dynamic-forms/ui-ng-bootstrap\u0026#34;: \u0026#34;^9.0.1\u0026#34;, \u0026#34;angular2-text-mask\u0026#34;: \u0026#34;^9.0.0\u0026#34;, \u0026#34;bootstrap\u0026#34;: \u0026#34;^4.3.1\u0026#34;, \u0026#34;rxjs\u0026#34;: \u0026#34;~6.4.0\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;^1.10.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;~0.9.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;~0.802.0\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@angular/language-service\u0026#34;: \u0026#34;~8.2.0\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;~8.9.4\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~3.3.8\u0026#34;, \u0026#34;@types/jasminewd2\u0026#34;: \u0026#34;~2.0.3\u0026#34;, \u0026#34;codelyzer\u0026#34;: \u0026#34;^5.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~3.4.0\u0026#34;, \u0026#34;jasmine-spec-reporter\u0026#34;: \u0026#34;~4.2.1\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~4.1.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~2.2.0\u0026#34;, \u0026#34;karma-coverage-istanbul-reporter\u0026#34;: \u0026#34;~2.0.1\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~2.0.1\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;^1.4.0\u0026#34;, \u0026#34;protractor\u0026#34;: \u0026#34;~5.4.0\u0026#34;, \u0026#34;ts-node\u0026#34;: \u0026#34;~7.0.0\u0026#34;, \u0026#34;tslint\u0026#34;: \u0026#34;~5.15.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~3.5.3\u0026#34; } } 若直接使用 npm install 來回復此專案的套件，將會出現許多的警告訊息，如下圖:\n查閱對照表後發現 Angular 8.2 版本應該搭配的是 Node.js 10.9.0 ( Angular 與 Node.js 對照表 )\n此時可透過 nvs 來額外再安裝 Node.js 10.9.0 版本到你的系統中，並將 Node.js 使用版本 切換到 10.9.0\nPS F:\\test\\angular-forms-workshop\u0026gt; nvs add 10.9.0 PS F:\\test\\angular-forms-workshop\u0026gt; nvs use 10.9.0 完成後，使用這個 正確 的版本就可以順利安裝相關的套件了。\n同一時間，我又在 github 找到另一個合適的範例程式，git clone 後，查看該專案撰寫時是使用那個版本的 Angular，發現是 11.2.13\nPS F:\\test\\angular-forms-workshop\u0026gt; cd ..\\angular.io-example\\ PS F:\\test\\angular.io-example\u0026gt; cat package.json { \u0026#34;name\u0026#34;: \u0026#34;angular.io-example\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;rxjs\u0026#34;: \u0026#34;6.6.7\u0026#34;, \u0026#34;tslib\u0026#34;: \u0026#34;2.2.0\u0026#34;, \u0026#34;zone.js\u0026#34;: \u0026#34;0.10.3\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;3.6.0\u0026#34;, \u0026#34;@angular/core\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/forms\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/common\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/router\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;jasmine-marbles\u0026#34;: \u0026#34;0.6.0\u0026#34;, \u0026#34;@angular/compiler\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/animations\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;@angular/platform-browser\u0026#34;: \u0026#34;11.2.13\u0026#34;, \u0026#34;angular-in-memory-web-api\u0026#34;: \u0026#34;0.11.0\u0026#34;, \u0026#34;@angular/platform-browser-dynamic\u0026#34;: \u0026#34;11.2.13\u0026#34; }, \u0026#34;scripts\u0026#34;: { \u0026#34;ng\u0026#34;: \u0026#34;ng\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;ng build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;ng test\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;ng lint\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;ng e2e\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@angular-devkit/build-angular\u0026#34;: \u0026#34;~0.1102.12\u0026#34;, \u0026#34;@angular/cli\u0026#34;: \u0026#34;~11.2.12\u0026#34;, \u0026#34;@angular/compiler-cli\u0026#34;: \u0026#34;~11.2.13\u0026#34;, \u0026#34;@types/jasmine\u0026#34;: \u0026#34;~3.6.0\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^12.11.1\u0026#34;, \u0026#34;codelyzer\u0026#34;: \u0026#34;^6.0.0\u0026#34;, \u0026#34;jasmine-core\u0026#34;: \u0026#34;~3.6.0\u0026#34;, \u0026#34;jasmine-spec-reporter\u0026#34;: \u0026#34;~5.0.0\u0026#34;, \u0026#34;karma\u0026#34;: \u0026#34;~6.1.0\u0026#34;, \u0026#34;karma-chrome-launcher\u0026#34;: \u0026#34;~3.1.0\u0026#34;, \u0026#34;karma-coverage\u0026#34;: \u0026#34;~2.0.3\u0026#34;, \u0026#34;karma-jasmine\u0026#34;: \u0026#34;~4.0.0\u0026#34;, \u0026#34;karma-jasmine-html-reporter\u0026#34;: \u0026#34;^1.5.0\u0026#34;, \u0026#34;protractor\u0026#34;: \u0026#34;~7.0.0\u0026#34;, \u0026#34;ts-node\u0026#34;: \u0026#34;~8.3.0\u0026#34;, \u0026#34;tslint\u0026#34;: \u0026#34;~6.1.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;~4.1.5\u0026#34; } } 一樣的道理，透過 nvs 再多安裝 Node.js 12.11.1 版本\nPS F:\\test\\angular-forms-workshop\u0026gt; nvs add 12.11.1 nvs 的使用方法 查看目前所有已安裝的 Node.js 版本\nPS F:\\test\\angular-forms-workshop\u0026gt; nvs ls\nnode/16.10.0/x64 #Angular 13 所搭配的 Node.js 版本 node/14.15.5/x64 (Fermium) #Angular 12 所搭配的 Node.js 版本 node/12.11.1/x64 #Angular 11 所搭配的 Node.js 版本 node/10.9.0/x64 #Angular 8 所搭配的 Node.js 版本 node/8.9.4/x64 #Angular 7 所搭配的 Node.js 版本 手動切換 PS F:\\test\\angular-forms-workshop\u0026gt; nvs use 10 #使用(切換到)第十版，在範例中會自動切換到 10.9.0 PS F:\\test\\angular-forms-workshop\u0026gt; node -v #顯示目前使用中的 Node.js 版本 v10.9.0 PS F:\\test\\angular-forms-workshop\u0026gt; nvs ls #前導 \u0026#39;\u0026gt;\u0026#39; 符號表示是目前`使用中`的版本 node/16.10.0/x64 node/14.15.5/x64 (Fermium) node/12.11.1/x64 \u0026gt;node/10.9.0/x64 node/8.9.4/x64 (Carbon) 自動切換 每個目錄若搭配 .node-version 檔名的文字檔，且內容是 Node.js 的版本資訊:\nPS F:\\test\u0026gt; node -v \u0026gt; .node-version #將版本資訊寫入 .node-version 檔案中 PS F:\\test\u0026gt; cat .node-version #查看內容 v10.9.0 除有上述檔案及內容外，還必須搭配 開啓 nvs 自動切換 功能\nPS F:\\test\u0026gt; nvs auto on \n以上兩個條件都成立時，當切換不同現行目錄時，系統會自動選擇套用不同的 Node.js 版本\nPS F:\\test\u0026gt; cd .\\angular.io-example\\ PATH += $env:LOCALAPPDATA\\nvs\\node\\12.11.1\\x64 PS F:\\test\\angular.io-example\u0026gt; node -v v12.11.1 PS F:\\test\\angular.io-example\u0026gt; cat .\\.node-version v12.11.1 PS F:\\test\\angular.io-example\u0026gt; cd ..\\angular-forms-workshop\\ PATH -= $env:LOCALAPPDATA\\nvs\\node\\12.11.1\\x64 PATH += $env:LOCALAPPDATA\\nvs\\node\\10.9.0\\x64 PS F:\\test\\angular-forms-workshop\u0026gt; node -v v10.9.0 半自動型手動切換 若 nvs 自動切換 功能設為 off 則可視為所謂的 半自動 模式。\n無.node-version 檔案，也無 nvs 也無設定預設版本的情況:\nPS F:\\test\u0026gt; nvs use\n上述指令等同 nvs use default (nvs use auto、nvs auto 亦同義) 就是切換所在目錄的 Node.js 版本，系統第一優先查看的現行目錄中的 .node-version 檔案裡所指定的 Node.js 版本，若無 .node-version 檔案，則使用 nvs default (預設)版本，若 nvs 也無設定預設版本，則會將目前的 \u0026lsquo;使用版本\u0026rsquo; reset 成 null。\n","permalink":"https://calvinegs.github.io/posts/nvs-using/","summary":"Angular 的版本更新迭代的相當快 (所有的前端開於工具都有相同的情形)，安裝及使用 Angular Cli 時必須在有 Node.js 的環境下才能進行。\n當你在同一台電腦中使用不同版本的 Angular 時就容易在安裝相關套件時遇到警語，原因常是因為 Angular 與 Node.js 版本搭配的關係。\n至於為何有同時使用不同版本的 Angular 呢? 除了開發的專案沒有全部都一起升級至統一版本(這是一件複雜的事)的因素外，個人最常遇到的狀況是: 當在網上(github)找到很棒的 Demo / Sample 程式，在 git clone 回電腦後發現它的版本是舊版本 Angular 所撰寫，使用 npm install 安裝相關套件時，出現警告訊息，甚至無法安裝成功。\n為了要管理同一台電腦中存在著有不同版 Node.js，讓你很容易在各版本中自由的進行切換 (甚至在進入不同目錄時自動切換對應的 Node.js 版本)，你需要 Node.js 版本管理工具，如: NVM 或 NVS，在這個筆記中要記錄的是 NVS。\n安裝 nvs F:\\\u0026gt; choco list nvs #先查看是否已安裝了 nvs F:\\\u0026gt; choco install nvs #安裝 nvs F:\\\u0026gt; nvs --version #查看是否安裝成功，並顯示 nvs 版本  註：安裝完成後若遇到在 cmd 中可正常執行，但在Windows PowerShell 無法使用時，可使用‘系統管理員’身份開啟 Posershell，並執行 PS\u0026gt;Set-ExecutionPolicy RemoteSigned 應可解決這個問題。","title":"使用 nvs 來管理不同版本 Node.js 執行環境"},{"content":" ","permalink":"https://calvinegs.github.io/posts/ngcli-nodejs-verion/","summary":" ","title":"Angular cli 與 Node.js 版本對照"},{"content":"TypeScript 不僅已可使用在主機端來進行 Node.js 程式的開發，也支援前端開發的眾多架構，使用 TypeScript 有許多額外的好處，因此學習 TypeScript 是現在軟體開發工程師不可缺的一項技能。本文是用來記錄如何設置一個簡易的 TypeScript 開發環境，用來學習 TypeScript。\n開始設置 建立一個目錄\n$ mkdir typescript-starter $ cd typescript-starter 透過 npm 產生 package.json 檔案\n$ npm init -y 在 Local 端安裝 TypeScript\n$ npm install typescript --save-dev #or -D 為 Node.js 安裝類型檔\n$ npm install @types/node --save-dev 透過 tsc 建立 TypeScript 的設定檔 (tsconfig.json)\n$ npx tsc --init P.S. 由於 typescript 是安裝在 local，執行時要透過 npx 指令(由 npm 所提供)\n指定額外的參數\n$ npx tsc --init --init --rootDir src --outDir build --esModuleInterop --resolveJsonModule --lib es6 --module commonjs --allowJs true --noImplicitAny true  rootDir: tsc 轉碼器找尋程式的地方。 outDir: TypeScript 轉譯成 JavaScript 所存放的地方。 esModuleInterop: 若使用 commonjs 為此專案的 module system，則此設定值必須設定為 true。 resolveJsonModule: 若此專案會使用 JSON，則此設定值必須設定為 true。 lib: 指定為 \u0026lsquo;es6\u0026rsquo; 指可使用到新版 JS 的一些語言特性，指定 \u0026lsquo;es5\u0026rsquo; 則會有較高的相容易。 module: 指存 module system，如: commonjs。 allowJs: 此選項將允許您在 .ts 文件中包含 .js 文件。 noImplicitAny: 值為 true 時，在 TypeScript 文件中，不允許不明確地指定類型。  將多餘不會使用的參數移除\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;lib\u0026#34;: [\u0026#34;es6\u0026#34;], \u0026#34;allowJs\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;src\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;noImplicitAny\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;resolveJsonModule\u0026#34;: true } } 建立 src 目錄，並在此目錄下寫程式\n$ mkdir src $ touch src/index.ts 程式如下:\nimport * as cowsay from \u0026#34;cowsay\u0026#34;; console.log( cowsay.say({ text: \u0026#34;I\u0026#39;m a moooodule\u0026#34;, e: \u0026#34;oO\u0026#34;, T: \u0026#34;U \u0026#34;, }) ); 因為程式中使用到額外的 library - cowsay，要先安裝\n$ npm install cowsay 利用 tsc 來轉譯 TypeScript 成為 JavaScript\n$ npx tsc 轉譯成 es5 版本 JavaScript 的結果:\n\u0026#34;use strict\u0026#34;; // const aVar = \u0026#39;abc\u0026#39;; // console.log(\u0026#39;Hello world!\u0026#39; + `${aVar}`) var __createBinding = (this \u0026amp;\u0026amp; this.__createBinding) || (Object.create ? function (o, m, k, k2) { if (k2 === undefined) k2 = k; Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; }, }); } : function (o, m, k, k2) { if (k2 === undefined) k2 = k; o[k2] = m[k]; }); var __setModuleDefault = (this \u0026amp;\u0026amp; this.__setModuleDefault) || (Object.create ? function (o, v) { Object.defineProperty(o, \u0026#34;default\u0026#34;, { enumerable: true, value: v }); } : function (o, v) { o[\u0026#34;default\u0026#34;] = v; }); var __importStar = (this \u0026amp;\u0026amp; this.__importStar) || function (mod) { if (mod \u0026amp;\u0026amp; mod.__esModule) return mod; var result = {}; if (mod != null) for (var k in mod) if (k !== \u0026#34;default\u0026#34; \u0026amp;\u0026amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k); __setModuleDefault(result, mod); return result; }; Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); var cowsay = __importStar(require(\u0026#34;cowsay\u0026#34;)); console.log( cowsay.say({ text: \u0026#34;I\u0026#39;m a moooodule\u0026#34;, e: \u0026#34;Ox\u0026#34;, T: \u0026#34;V \u0026#34;, }) ); 使用一些有用的設定及 Script 安裝 ts-node 和 nodemon\nts-node 是一個 TypeScript 執行引擎和 Node.js 的 REPL。它以JIT方式將TypeScript轉譯為 JavaScript，使你能夠直接在 Node.js上 執行 TypeScript 而不需要預轉譯。通過 node 的模組載入 API 來實現的，使其能夠與其他 Node.js 工具和程式庫一起無縫使用。\nnodemon 是一個工具，它通過檢測程式目錄中的文件更改時可以自動重新啟動應用程式(本範例中是啟動 Node.js)，以此協助應用程式開發。\n$ npm install --save-dev ts-node nodemon 新增一個 nodemon 的設定檔 nodemon.json\n$ touch nodemon.json 內容如下:\n{ \u0026#34;watch\u0026#34;: [\u0026#34;src\u0026#34;], \u0026#34;ext\u0026#34;: \u0026#34;.ts,.js\u0026#34;, \u0026#34;ignore\u0026#34;: [], \u0026#34;exec\u0026#34;: \u0026#34;npx ts-node ./src/index.ts\u0026#34; } 在 package.json 中加入啟動的 script\n\u0026#34;start\u0026#34;: \u0026#34;nodemon\u0026#34;, 執行 scripts\nPS F:\\test\\ts\\ts-starter\u0026gt; npm start # npm start 是 npm run start 的 alias \u0026gt; ts-starter@1.0.0 start \u0026gt; nodemon [nodemon] 2.0.15 [nodemon] to restart at any time, enter `rs` [nodemon] watching path(s): src\\**\\* [nodemon] watching extensions: ts,js [nodemon] starting `npx ts-node ./src/index.ts` ________________________ \u0026lt; I\u0026#39;m a slaughtered deer \u0026gt; ------------------------ \\  ^__^ \\  (Ox)\\_______ (__)\\  )\\/\\  V ||----w | || || [nodemon] clean exit - waiting for changes before restart 直接修改程式碼，將 index.ts 中的 slaughtered deer 改成 deer，存檔後，系統將自動轉譯程式碼，並透過 Node.js 顯示出結果:\n","permalink":"https://calvinegs.github.io/posts/setup-typescript-env/","summary":"TypeScript 不僅已可使用在主機端來進行 Node.js 程式的開發，也支援前端開發的眾多架構，使用 TypeScript 有許多額外的好處，因此學習 TypeScript 是現在軟體開發工程師不可缺的一項技能。本文是用來記錄如何設置一個簡易的 TypeScript 開發環境，用來學習 TypeScript。\n開始設置 建立一個目錄\n$ mkdir typescript-starter $ cd typescript-starter 透過 npm 產生 package.json 檔案\n$ npm init -y 在 Local 端安裝 TypeScript\n$ npm install typescript --save-dev #or -D 為 Node.js 安裝類型檔\n$ npm install @types/node --save-dev 透過 tsc 建立 TypeScript 的設定檔 (tsconfig.json)\n$ npx tsc --init P.S. 由於 typescript 是安裝在 local，執行時要透過 npx 指令(由 npm 所提供)\n指定額外的參數\n$ npx tsc --init --init --rootDir src --outDir build --esModuleInterop --resolveJsonModule --lib es6 --module commonjs --allowJs true --noImplicitAny true  rootDir: tsc 轉碼器找尋程式的地方。 outDir: TypeScript 轉譯成 JavaScript 所存放的地方。 esModuleInterop: 若使用 commonjs 為此專案的 module system，則此設定值必須設定為 true。 resolveJsonModule: 若此專案會使用 JSON，則此設定值必須設定為 true。 lib: 指定為 \u0026lsquo;es6\u0026rsquo; 指可使用到新版 JS 的一些語言特性，指定 \u0026lsquo;es5\u0026rsquo; 則會有較高的相容易。 module: 指存 module system，如: commonjs。 allowJs: 此選項將允許您在 .","title":"設置 TypeScript 開發環境 (Node.js)"},{"content":"Hugo 內容文件中使用基本 Markdown 語法，還額外支援由 Hugo 所提供的加強語法(也支援基本 HTML 元素)。\n標題 (Headings) 要建立標題，請在文字前添加井字符號 #(請注意井字符號後要加入一個空格)。使用的井字符號的數量應與標題級別相對應。例如，要建立三級標題 (\u0026lt;h3\u0026gt;)，請使用三個井字符號（例如，### My Header）。\n段落 (Paragraphs) 一個 Markdown 段落是由一個或多個連續的文字行組成，它的前後要有一個以上的空行。\n文字區塊引用 (Blockquotes) 在段落的第一行最前面加\u0026quot;\u0026gt;\u0026quot;\n未註明出處的文字區塊引用 (Blockquote without attribution)  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n 註明出處的文字區塊引用 (Blockquote with attribution)  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n 斷行 (Line Breaks) 要建立換行符號 (\u0026lt;br\u0026gt;)，請以兩個或多個空格結束一行，然後鍵入 return 鍵。\n表格 (Tables) 表格功能並不是 Markdown 規格, 不過 Hugo 支援這個好用的功能.\n   Name Age     Bob 27   Alice 23    表格內支援內嵌 Markdown 語法    Italics Bold Code     italics bold code    表格內的對齊功能    Number Next number Previous number     Five Six Four   Ten Eleven Nine   Seven Eight Six   Two Three One    程式碼區塊 (Code Blocks) 使用 \u0026lsquo;反引號\u0026rsquo; 的程式碼區塊 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   使用 \u0026lsquo;四個空格\u0026rsquo; 的程式碼區塊 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  使用 Hugo 內部支援 highlight shortcode 的程式碼區塊 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   使用 Gist 的程式區塊 \u0026lt;script src=\u0026quot;https://gist.github.com/spf13/7896402.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n 清單 有序清單  First item Second item Third item  無序清單  List item Another item And another item  巢狀清單  Fruit  Apple Orange Banana   Dairy  Milk Cheese     First item Second item Third item  Indented item Indented item   Fourth item  以數字開頭的無序清單 將\u0026rsquo;段落\u0026rsquo;加入清單中   This is the first list item.\n  Here\u0026rsquo;s the second list item.\nI need to add another paragraph below the second list item.\n  And here\u0026rsquo;s the third list item.\n  將\u0026rsquo;文字區塊引用\u0026rsquo;加入清單中   This is the first list item.\n  Here\u0026rsquo;s the second list item.\n A blockquote would look great below the second list item.\n   And here\u0026rsquo;s the third list item.\n  將\u0026rsquo;程式區塊\u0026rsquo;加入清單中   Open the file.\n  Find the following code block on line 21:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt;    Update the title to match the name of your website.\n  將\u0026rsquo;圖檔\u0026rsquo;加入清單中   Open the file containing the Linux mascot.\n  Marvel at its beauty.\n  Close the file.\n  Task List 反引號的使用 水平線 (Horizontal Rules) Try to put a blank line before\u0026hellip;\n \u0026hellip;and after a horizontal rule.\n連結 (Links) My favorite search engine is Duck Duck Go.\nI love supporting the EFF.\nThis is the Markdown Guide.\nSee the section on code.\n斜體 \u0026amp; 強調 使用 * 符號套用在文字的前後方，即可將文字改為斜體字；而使用連續兩個*加在文字的前後方則會是強調文字。\n有時候，你得停一下腳步，等一等 心靈，讓心情平和，想一想自己生活中擁有的所有 美好 的東西。\n使用跳脫字元 要顯示原本用於格式化 Markdown 文件中的文字字元，請在該字符前添加反斜線 (\\)。\n其他元素的使用 — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://calvinegs.github.io/posts/markdown-syntax/","summary":"Hugo 內容文件中使用基本 Markdown 語法，還額外支援由 Hugo 所提供的加強語法(也支援基本 HTML 元素)。\n標題 (Headings) 要建立標題，請在文字前添加井字符號 #(請注意井字符號後要加入一個空格)。使用的井字符號的數量應與標題級別相對應。例如，要建立三級標題 (\u0026lt;h3\u0026gt;)，請使用三個井字符號（例如，### My Header）。\n段落 (Paragraphs) 一個 Markdown 段落是由一個或多個連續的文字行組成，它的前後要有一個以上的空行。\n文字區塊引用 (Blockquotes) 在段落的第一行最前面加\u0026quot;\u0026gt;\u0026quot;\n未註明出處的文字區塊引用 (Blockquote without attribution)  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n 註明出處的文字區塊引用 (Blockquote with attribution)  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n 斷行 (Line Breaks) 要建立換行符號 (\u0026lt;br\u0026gt;)，請以兩個或多個空格結束一行，然後鍵入 return 鍵。","title":"Hugo 中使用的 Markdown 語法介紹"},{"content":"GitHub Page 功能是 GitHub 提供的一項支援靜態網頁的服務，只要在你的 repository 中加入一個名為 gh-pages 的分支，則 GitHub 便會預設將此分支內的檔案以靜態網頁的方式呈現，因此利用此特性就可很容易的製作一個簡單的網站。GitHub Pages 提供了二種不同形態的頁面 \u0026ldquo;User or organization site\u0026rdquo; \u0026amp; \u0026ldquo;Project Site\u0026rdquo;。其中個人/組織 網站一個 GitHub 帳號只能有一個、而專案網站則可以很多個。\n https://calvinegs.github.io #只有一個 https://calvinegs.github.io/project1\nhttps://calvinegs.github.io/project2\nhttps://calvinegs.github.io/project3\n\u0026hellip;\n 安裝步驟 Step 1: 在 GitHub 上建立一個 new repository Repository name 若為 Owner_name.github.io 即所謂的 User site，Repository name 即為靜態網站的網址。以下圖為例，有效網址為 https://calvinegs.github.io\nStep 2: 使用 GitHub Action 構建 Hugo 透過 GitHub Action 功能，在你每次將新版本的 Hugo 網站內容推送到 GitHub repository 時，GitHub 將自動建置網站。\n新增一個 .github/workflows/gh-pages.yml，內容如下:\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public Step 3: GitHub Page 的設置 在第一次推送 Hugo 網站內容推送到 GitHub repository 時，透過 GitHub Action 的建置，將在你的 repository 中新新一個分支名稱叫 gh-pages。請在 GitHub Page 的設置功能中將它由 \u0026ldquo;Main\u0026rdquo; 指向 \u0026ldquo;gh-pages\u0026rdquo; 分支。\nStep 4: 設置 Hugo 設定檔 將 Hugo 設定檔 config.toml 中的 baseURL 設定成 https://Owner_name.github.io。\nbaseurl = \u0026#34;https://calvinabba.github.io\u0026#34; DefaultContentLanguage = \u0026#34;en\u0026#34; title = \u0026#34;Beautiful Blog\u0026#34; theme = \u0026#34;beautifulhugo\u0026#34; ","permalink":"https://calvinegs.github.io/posts/deployhugo-githubpages/","summary":"GitHub Page 功能是 GitHub 提供的一項支援靜態網頁的服務，只要在你的 repository 中加入一個名為 gh-pages 的分支，則 GitHub 便會預設將此分支內的檔案以靜態網頁的方式呈現，因此利用此特性就可很容易的製作一個簡單的網站。GitHub Pages 提供了二種不同形態的頁面 \u0026ldquo;User or organization site\u0026rdquo; \u0026amp; \u0026ldquo;Project Site\u0026rdquo;。其中個人/組織 網站一個 GitHub 帳號只能有一個、而專案網站則可以很多個。\n https://calvinegs.github.io #只有一個 https://calvinegs.github.io/project1\nhttps://calvinegs.github.io/project2\nhttps://calvinegs.github.io/project3\n\u0026hellip;\n 安裝步驟 Step 1: 在 GitHub 上建立一個 new repository Repository name 若為 Owner_name.github.io 即所謂的 User site，Repository name 即為靜態網站的網址。以下圖為例，有效網址為 https://calvinegs.github.io\nStep 2: 使用 GitHub Action 構建 Hugo 透過 GitHub Action 功能，在你每次將新版本的 Hugo 網站內容推送到 GitHub repository 時，GitHub 將自動建置網站。\n新增一個 .github/workflows/gh-pages.yml，內容如下:\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.","title":"在 Github Pages 部署 Hugo 靜態網站"},{"content":"Hugo 是一個静態網站生成器，搭配 git 很適合來建立個人部落格。在一系列的筆記中將介紹如何安裝/使用相關工具與技術，目的是搭建一個完全免費的個人部落格。\n使用的相關工具/技術:\n Hugo git vs code gist github page Markdown  Chocolatey Chocolatey 是一個 Windows 上的套件管理工具，它結合了 Nuget 基礎服務與 powershell 指令，提供快速安裝應用程式與工具的服務，將安裝軟體的內容封裝到一個安裝包中，在 Chocolatey 中只需要一條簡單的指令就能完成搜尋、安裝、更新、解安裝等操作。\n在 Windows 10 上安裝 Chocolatey 以‘系統管理員’身份開啟 \u0026lsquo;Windows PowerShell\u0026rsquo;,　執行以下指令來進行 Chocolatey 安裝\nPS C:\\\u0026gt;Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 移除 Chocolatey 刪除 C:\\ProgramData\\chocolatey 目錄及移除環境變數即可，搜尋 \u0026ldquo;編輯系統環境變數\u0026rdquo; \\ \u0026ldquo;進階\u0026rdquo; \\ \u0026ldquo;環境變數\u0026rdquo;\n安裝 hugo Step 1: 在 Windows 10 上使用 choco 安裝 hugo C:\\\u0026gt; choco install hugo -confirm C:\\\u0026gt; choco install hugo-extended - config C:\\\u0026gt; hugo version Step 2: Create a New Site (建立部落格網站) C:\\\u0026gt; hugo new site quickstart C:\\\u0026gt; hugo new site quickstart -f yml # 若要使用 config.yaml 為 config 設定檔，則加入額外參數 Step 3: Add a Theme (新增部落格主題) 請先確認在您的作業系統中已經安裝了 git\nC:\\\u0026gt; cd quickstart C:\\\u0026gt; git init C:\\\u0026gt; git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke C:\\\u0026gt; git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 在 config.toml 中加入 theme = \u0026ldquo;ananke\u0026rdquo;\nC:\\\u0026gt; echo \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml Step 4: Add Some Content (建立新文章) C:\\\u0026gt; hugo new posts/my-first-post.md 在 md file 中加入以下內容\n # Test Page\nThis is my first test page.\n Step 5: Start the Hugo server (本機測試) C:\\\u0026gt; hugo server -D 開啟瀏覽器，輸入網址 https://localhost:1313 ","permalink":"https://calvinegs.github.io/posts/installhugo-windows/","summary":"Hugo 是一個静態網站生成器，搭配 git 很適合來建立個人部落格。在一系列的筆記中將介紹如何安裝/使用相關工具與技術，目的是搭建一個完全免費的個人部落格。\n使用的相關工具/技術:\n Hugo git vs code gist github page Markdown  Chocolatey Chocolatey 是一個 Windows 上的套件管理工具，它結合了 Nuget 基礎服務與 powershell 指令，提供快速安裝應用程式與工具的服務，將安裝軟體的內容封裝到一個安裝包中，在 Chocolatey 中只需要一條簡單的指令就能完成搜尋、安裝、更新、解安裝等操作。\n在 Windows 10 上安裝 Chocolatey 以‘系統管理員’身份開啟 \u0026lsquo;Windows PowerShell\u0026rsquo;,　執行以下指令來進行 Chocolatey 安裝\nPS C:\\\u0026gt;Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 移除 Chocolatey 刪除 C:\\ProgramData\\chocolatey 目錄及移除環境變數即可，搜尋 \u0026ldquo;編輯系統環境變數\u0026rdquo; \\ \u0026ldquo;進階\u0026rdquo; \\ \u0026ldquo;環境變數\u0026rdquo;\n安裝 hugo Step 1: 在 Windows 10 上使用 choco 安裝 hugo C:\\\u0026gt; choco install hugo -confirm C:\\\u0026gt; choco install hugo-extended - config C:\\\u0026gt; hugo version Step 2: Create a New Site (建立部落格網站) C:\\\u0026gt; hugo new site quickstart C:\\\u0026gt; hugo new site quickstart -f yml # 若要使用 config.","title":"在 Windows 10 使用 Hugo"}]